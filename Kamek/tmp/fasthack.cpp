//
// processed\../src/profile.cpp
//

#include <profile.h>

/* SPRITES */

SpriteData sprites[SpriteId::Num] = { 0 };

class SpritesSetter
{
public:
    SpritesSetter();
};

SpritesSetter::SpritesSetter()
{
    for (u32 i = 0; i < 483; i++)
        sprites[i] = originalSprites[i];
}

static SpritesSetter doSetSprites;

/* PROFILES */

Profile* profiles[ProfileId::Num] = { 0 };
extern "C" Profile** ObjectProfileList;

class ProfileSetter
{
public:
    ProfileSetter();
};

ProfileSetter::ProfileSetter()
{
    ObjectProfileList = &profiles[0];

    for (u32 i = 0; i < 750; i++) {
        profiles[i] = originalProfiles[i];
    }
}

static ProfileSetter doSetProfiles;

void SetObjectProfileList()
{
    ObjectProfileList = &profiles[0];
}

/* SPRITE FILES */

extern "C" const char** spriteFiles[483];
const char** customSpriteFiles[SpriteId::Num - 483] = { 0 };

/* PROFILE NAMES*/

extern "C" const char* profileNames[750];
const char* customProfileNames[ProfileId::Num - 750] = { 0 };

const char* GetProfileName(u32 profileId)
{
    if (profileId < 750) {
        return profileNames[profileId];
    }

    return customProfileNames[profileId - 750];
}

/* CUSTOM PROFILE CTOR */

Profile::Profile(dActor_c* (*buildFunc)(), u32 spriteId, const SpriteData &spriteData, u16 executeOrderProfileId, u16 drawOrderProfileId, const char* name, const char** files)
{
    this->buildFunc = buildFunc;
    this->executeOrderProfileId = executeOrderProfileId;
    this->drawOrderProfileId = drawOrderProfileId;

    sprites[spriteId] = spriteData;
    if (spriteId < 483) {
        spriteFiles[spriteId] = files;
    }
    else {
        customSpriteFiles[spriteId - 483] = files;
    }

    profiles[spriteData.profileId] = this;
    if (spriteData.profileId < 750) {
        profileNames[spriteData.profileId] = name;
    }
    else {
        customProfileNames[spriteData.profileId - 750] = name;
    }
}

//
// processed\../src/0.cpp
//

#include <game.h>

//#include "0.h"
u8 LastLevelPlayed[2] = {0xFF,0xFF};	//Powerup Jam fix
//bool enableDebugMode = true;			//Powerup Jam fix


void Test() {
	//OSReport("DoSceneChange finished\n");
	//SaveBlock *save = GetSaveFile()->GetBlock(-1);
	//save->addToLevelNum = 0;
	//OSReport("addToLevelNum: %p\n", save->addToLevelNum);
	
}




/*
stockItemLayoutCreate(){
	dStockItem_c *stockItem;
	stockItem = (dStockItem_c*)CreateParentedObject(STOCK_ITEM, this, 0, 0);
	
}*/



extern "C" int dStockItem(int i);
int dStockItemCreate(int i) {
	int orig_val = dStockItem(i);
	
	//OSReport("Orig: %p\n", orig_val);
	
	//DVD_LoadFile(GetDVDClass(), "Maps", "SI_hammer", 0);
	//if (orig_val==0) {
	//	OSReport("Loaded stockItem!\n");
	//	//DVD_LoadFile(GetDVDClass(), "Maps", "SI_hammer", 0);
	//	OSReport("Loaded SI_hammer!\n");
	//}
	
	return orig_val;
}










int AddToLevelNum(int orig) {
	//orig += GetSaveFile()->GetBlock(-1)->addToLevelNum;
	return orig;
}

extern u8 World;
int subWorld = 1;
int pointNode = 5;
extern u8 AssembleScWorldMapSettings(u8 world, int subworld, int pointNode);
extern void DoShitWithWMPlayer(int node);
extern char CS_ptr1[4];
extern char CS_ptr2[4];
extern char CS_ptr3[4];
extern char CS_ptr4[4];
extern char aWorld1;
extern char aWorld2;


//extern int reportCrashAdress;


extern int goToSpecificWorld(int world, int supworld, int node);



u8 getActualLevelNum(u8 level) {
	/*if(GetSaveFile()->GetBlock(-1)->addToLevelNum == 10) {
		switch(level) {
			case 0:
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
				level += 9;
				break;
			case 20:
			case 21:
				level -= 4;
				break;
			case 23:
				level -= 5;
				break;
			case 35:
			case 37:
				level -= 13;
				break;
			default:
				break;
		}
	}*/
	return level;
}


u8 SetLevelIdentifier(u8 world,u8 level,u8 *world_ptr,u8 *level_ptr) {
	//OSReport("1: %p, 2: %p, 3: %p, 4: %p\n\n", world, level, world_ptr, level_ptr);
	//level += 1;

	level = getActualLevelNum(level);

	*world_ptr = world;
	*level_ptr = level;
	//OSReport("1: %p, 2: %p, 3: %p, 4: %p\n\n", world, level, world_ptr, level_ptr);
	return 1;
}





void SetConditionInWorldDataForWorldAndLevel(int* structWithWorldData, int world, int level, unsigned int condition) {
	//OSReport("SetConditionInWorldDataForWorldAndLevel: %p, %p, %p, %p\n\n", structWithWorldData, world, level, condition);
	
	//level = getActualLevelNum(level);
	
	(structWithWorldData + world * 0x2a + level)[0x1b] |= condition;
	return;
}

unsigned int CheckIfConditionIsCompletedForWorldAndLevel(int* structWithWorldData, int world, int level, unsigned int condition) {
	//OSReport("CheckIfConditionIsCompletedForWorldAndLevel: %p, %p, %p, %p\n\n", structWithWorldData, world, level, condition);
	return (-(condition & structWithWorldData[world * 0x2a + level + 0x1b]) | condition & structWithWorldData[world * 0x2a + level + 0x1b]) >> 0x1f;
}





void SetSpecificStarCoinToCollected(int* structWithWorldData, int world, int level, unsigned int starCoin) {
	//OSReport("SetSpecificStarCoinToCollected: %p, %p, %p, %p\n\n", structWithWorldData, world, level, condition);

	
	//level = getActualLevelNum(level);

    (structWithWorldData + world * 0x2a + level)[0x1b] |= starCoin & 7;
	return;
}


unsigned int CheckIfWeHaveASpecificStarCoin(int* structWithWorldData, int world, int level, unsigned int starCoin) {
	//OSReport("CheckIfWeHaveASpecificStarCoin: %p, %p, %p, %p\n\n", structWithWorldData, world, level, starCoin);

	//level = getActualLevelNum(level);

	return 1 << starCoin & structWithWorldData[world * 0x2a + level + 0x1b] & 0xff;
}

/*
504 -> Welt 5
501 -> Welt 2
500 -> Welt 1
*/














/*float rewrite_fail(char *str) {
	return 1.0f;
}

float rewrite(char *str) {
	float fVar1;
	int iVar2;
	float fVar3;
	if (*str == 'W') {
		fVar1 = (float)atoi(str + 3);
		switch(str[2]) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			iVar2 = atoi(str + 3);
			fVar3 = (float)(iVar2 + -0x40800001);
			break;
		case 'A':
			fVar3 = fVar1;
			break;
		case 'C':
			fVar3 = fVar1;
			break;
		case 'G':
			fVar3 = fVar1;
			break;
		case 'K':
			fVar3 = 1.00000000;
			break;
		case 'S':
			fVar3 = 1.00000000;
			break;
		case 'T':
			fVar3 = fVar1;
			break;
		case 'W':
			fVar3 = (float)((int)fVar1 + (int)168.00000000);
			break;
		case 'X':
			fVar3 = -999999.87500000;
		}
	}
	return fVar3;
}
*/

//
// processed\../src/apDebug.cpp
//

#include <game.h>
#define GEKKO
#include "rvl/mtx.h"
#include "rvl/GXEnum.h"
#include "rvl/GXStruct.h"
#include "rvl/GXTransform.h"
#include "rvl/GXGeometry.h"
#include "rvl/GXDispList.h"
#include "rvl/GXLighting.h"
#include "rvl/GXTev.h"
#include "rvl/GXTexture.h"
#include "rvl/GXCull.h"
#include "rvl/GXPixel.h"
#include "rvl/GXBump.h"
#include "rvl/GXVert.h"
#include "rvl/vifuncs.h"

class APDebugDrawer : public m3d::proc_c {
	public:
		APDebugDrawer();

		bool amISetUp;
		mHeapAllocator_c allocator;

		void setMeUp();

		void drawMe();

		void drawOpa();
		void drawXlu();
};


static APDebugDrawer defaultInstance;
static bool enableDebugMode = true;

int APDebugDraw() {
	if (enableDebugMode)
		defaultInstance.drawMe();
	return 1;
}


APDebugDrawer::APDebugDrawer() {
	amISetUp = false;
}

void APDebugDrawer::setMeUp() {
	allocator.setup(GameHeaps[0], 0x20);
	setup(&allocator);
}

void APDebugDrawer::drawMe() {
	if (!amISetUp) {
		setMeUp();
		amISetUp = true;
	}

	scheduleForDrawing();
}

void APDebugDrawer::drawOpa() {
	drawXlu();
}
void APDebugDrawer::drawXlu() {
	GXClearVtxDesc();

	GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
	GXSetVtxDesc(GX_VA_CLR0, GX_DIRECT);

	GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
	GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);

	GXSetNumIndStages(0);
	for (int i = 0; i < 0x10; i++)
		GXSetTevDirect((GXTevStageID)i);

	GXSetNumChans(1);
	GXSetChanCtrl(GX_COLOR0A0, GX_DISABLE, GX_SRC_REG, GX_SRC_VTX, GX_LIGHT_NULL, GX_DF_NONE, GX_AF_NONE);
	GXSetChanAmbColor(GX_COLOR0A0, (GXColor){255,255,255,255});
	GXSetChanMatColor(GX_COLOR0A0, (GXColor){255,255,255,255});
	GXSetNumTexGens(0);

	GXSetNumTevStages(1);
	GXSetNumIndStages(0);

	GXSetTevSwapModeTable(GX_TEV_SWAP0, GX_CH_RED, GX_CH_GREEN, GX_CH_BLUE, GX_CH_ALPHA);

	GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD_NULL, GX_TEXMAP_NULL, GX_COLOR0A0);
	GXSetTevOp(GX_TEVSTAGE0, GX_PASSCLR);
//	GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_RASC, GX_CC_ZERO);
//	GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
//	GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_RASA, GX_CA_ZERO);
//	GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);

	GXSetZCompLoc(GX_FALSE);
	GXSetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_SET);
	GXSetZMode(GX_TRUE, GX_ALWAYS, GX_FALSE);
	GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);

	GXSetFog(GX_FOG_NONE, 0, 0, 0, 0, (GXColor){0,0,0,0});
	GXSetFogRangeAdj(GX_FALSE, 0, 0);

	GXSetCullMode(GX_CULL_NONE);

	GXSetDither(GX_TRUE);
	GXSetLineWidth(18, GX_TO_ZERO);

	GXSetTevColor(GX_TEVREG0, (GXColor){255,255,255,255});
	GXSetTevColor(GX_TEVREG1, (GXColor){0,0,0,255});

	nw4r::g3d::Camera cam(GetCameraByID(GetCurrentCameraID()));
	Mtx matrix;
	cam.GetCameraMtx(&matrix);
	GXLoadPosMtxImm(matrix, 0);
	GXSetCurrentMtx(0);

	ActivePhysics *ap = ActivePhysics::globalListHead;

	while (ap) {
//		if (ap->owner->name == PLAYER)
//			OSReport("Player has : DistToC=%f,%f DistToEdge=%f,%f Pos=%f,%f Scale=%f,%f\n",
//					ap->info.xDistToCenter, ap->info.yDistToCenter,
//					ap->info.xDistToEdge, ap->info.yDistToEdge,
//					ap->owner->pos.x, ap->owner->pos.y,
//					ap->owner->scale.x, ap->owner->scale.y);

		u32 uptr = (u32)ap;
		u8 r = (uptr>>16)&0xFF;
		u8 g = (uptr>>8)&0xFF;
		u8 b = uptr&0xFF;
		u8 a = 0xFF;

		GXBegin(GX_LINES, GX_VTXFMT0, 10);

		float centreX = ap->owner->pos.x + ap->info.xDistToCenter;
		float centreY = ap->owner->pos.y + ap->info.yDistToCenter;
		float edgeDistX = ap->info.xDistToEdge;
		float edgeDistY = ap->info.yDistToEdge;

		float tlX = centreX - edgeDistX, tlY = centreY + edgeDistY;
		float trX = centreX + edgeDistX, trY = centreY + edgeDistY;

		float blX = centreX - edgeDistX, blY = centreY - edgeDistY;
		float brX = centreX + edgeDistX, brY = centreY - edgeDistY;

		switch (ap->collisionCheckType) {
			case 2: // vert trapezoid
				tlY = centreY + ap->trpValue0;
				trY = centreY + ap->trpValue1;
				blY = centreY + ap->trpValue2;
				brY = centreY + ap->trpValue3;
				break;
			case 3: // horz trapezoid
				tlX = centreX + ap->trpValue0;
				trX = centreX + ap->trpValue1;
				blX = centreX + ap->trpValue2;
				brX = centreX + ap->trpValue3;
				break;
		}

		// Top
		GXPosition3f32(tlX, tlY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(trX, trY, 9000.0f);
		GXColor4u8(r,g,b,a);

		// Left
		GXPosition3f32(tlX, tlY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(blX, blY, 9000.0f);
		GXColor4u8(r,g,b,a);

		// Right
		GXPosition3f32(trX, trY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(brX, brY, 9000.0f);
		GXColor4u8(r,g,b,a);

		// Bottom
		GXPosition3f32(blX, blY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(brX, brY, 9000.0f);
		GXColor4u8(r,g,b,a);

		// Diagonal
		GXPosition3f32(trX, trY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(blX, blY, 9000.0f);
		GXColor4u8(r,g,b,a);

		GXEnd();

		ap = ap->listPrev;
	}

	Physics *p = Physics::globalListHead;

	while (p) {
		u32 uptr = (u32)p;
		u8 r = (uptr>>16)&0xFF;
		u8 g = (uptr>>8)&0xFF;
		u8 b = uptr&0xFF;
		u8 a = 0xFF;

		GXBegin(GX_LINES, GX_VTXFMT0, 10);

		float tlX = p->unkArray[0].x;
		float tlY = p->unkArray[0].y;
		float trX = p->unkArray[3].x;
		float trY = p->unkArray[3].y;
		float blX = p->unkArray[1].x;
		float blY = p->unkArray[1].y;
		float brX = p->unkArray[2].x;
		float brY = p->unkArray[2].y;

		// Top
		GXPosition3f32(tlX, tlY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(trX, trY, 9000.0f);
		GXColor4u8(r,g,b,a);

		// Left
		GXPosition3f32(tlX, tlY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(blX, blY, 9000.0f);
		GXColor4u8(r,g,b,a);

		// Right
		GXPosition3f32(trX, trY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(brX, brY, 9000.0f);
		GXColor4u8(r,g,b,a);

		// Bottom
		GXPosition3f32(blX, blY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(brX, brY, 9000.0f);
		GXColor4u8(r,g,b,a);

		// Diagonal
		GXPosition3f32(trX, trY, 9000.0f);
		GXColor4u8(r,g,b,a);
		GXPosition3f32(blX, blY, 9000.0f);
		GXColor4u8(r,g,b,a);

		GXEnd();

		p = p->next;
	}


	// Basic Colliders
	BasicCollider *bc = BasicCollider::globalListHead;
	while (bc) {
		u32 uptr = (u32)bc;
		u8 r = (uptr>>16)&0xFF;
		u8 g = (uptr>>8)&0xFF;
		u8 b = uptr&0xFF;
		u8 a = 0xFF;

		switch (bc->type) {
			case 0: case 2:
				GXBegin(GX_LINES, GX_VTXFMT0, 2);
				GXPosition3f32(bc->leftX, bc->leftY, 9000.0f);
				GXColor4u8(r,g,b,a);
				GXPosition3f32(bc->rightX, bc->rightY, 9000.0f);
				GXColor4u8(r,g,b,a);
				GXEnd();
				break;
		}

		bc = bc->next;
	}


	// Now, the hardest one.. CollisionMgr_c!
	fBase_c *fb = 0;
	while ((fb = fBase_c::searchByBaseType(2, fb))) {
		u8 *testMe = ((u8*)fb) + 0x1EC;
		if (*((u32*)testMe) != 0x8030F6D0)
			continue;

		u32 uptr = (u32)fb;
		u8 r = u8((uptr>>16)&0xFF)+0x20;
		u8 g = u8((uptr>>8)&0xFF)-0x30;
		u8 b = u8(uptr&0xFF)+0x80;
		u8 a = 0xFF;

		dStageActor_c *ac = (dStageActor_c*)fb;

		sensorBase_s *sensors[4] = {
			ac->collMgr.pBelowInfo, ac->collMgr.pAboveInfo,
			ac->collMgr.pAdjacentInfo, ac->collMgr.pAdjacentInfo};

		for (int i = 0; i < 4; i++) {
			sensorBase_s *s = sensors[i];
			if (!s)
				continue;

			float mult = (i == 3) ? -1.0f : 1.0f;

			switch (s->flags & SENSOR_TYPE_MASK) {
				case SENSOR_POINT:
					GXBegin(GX_POINTS, GX_VTXFMT0, 1);
					GXPosition3f32(
							ac->pos.x + (mult * (s->asPoint()->x / 4096.0f)),
							ac->pos.y + (s->asPoint()->y / 4096.0f),
							8005.0f);
					GXColor4u8(r,g,b,a);
					GXEnd();
					break;
				case SENSOR_LINE:
					GXBegin(GX_LINES, GX_VTXFMT0, 2);
					if (i < 2) {
						GXPosition3f32(
								ac->pos.x + (s->asLine()->lineA / 4096.0f),
								ac->pos.y + (s->asLine()->distanceFromCenter / 4096.0f),
								8005.0f);
						GXColor4u8(r,g,b,a);
						GXPosition3f32(
								ac->pos.x + (s->asLine()->lineB / 4096.0f),
								ac->pos.y + (s->asLine()->distanceFromCenter / 4096.0f),
								8005.0f);
						GXColor4u8(r,g,b,a);
					} else {
						GXPosition3f32(
								ac->pos.x + (mult * (s->asLine()->distanceFromCenter / 4096.0f)),
								ac->pos.y + (s->asLine()->lineA / 4096.0f),
								8005.0f);
						GXColor4u8(r,g,b,a);
						GXPosition3f32(
								ac->pos.x + (mult * (s->asLine()->distanceFromCenter / 4096.0f)),
								ac->pos.y + (s->asLine()->lineB / 4096.0f),
								8005.0f);
						GXColor4u8(r,g,b,a);
					}
					GXEnd();
					break;
			}
		}
	}
}

//
// processed\../src/codeDebug.cpp
//

#include <game.h>
/* Code Debugging Functions */

/* CDPrintCurrentAddress()
   This function prints the address the code execution is at when calling this functions (link register).
*/
extern "C" void CDPrintCurrentAddress();
int actuallyPrintLine(int addr){
	OSReport("Code execution at: 0x%x\n", addr);
	return addr;
}

/* CDWait()
   This function adds an infinite jump to itself, effectively halting the code execution. Pause the game in
   dolphin once the window shows 0 fps and replace the current instruction with a nop instruction. You now
   are at the current address the game is executing and can start debugging. 
*/
inline void CDWait() {
	while(true) {}
}

/* CDFloat2Hex(float f)
   This function prints a float in it's hex representation, if you don't have an internet connection and
   can't use https://www.h-schmidt.net/FloatConverter/IEEE754.html for example.
*/
void CDFloat2Hex(float f) {
	OSReport("Float: %f = Hex: 0x%x\n", f, f);
}
//
// processed\../src/creditsMgr.cpp
//

#include <game.h>
#include <sfx.h>
#include <dCourse.h>
#include <stage.h>
#include <playeranim.h>
#define GEKKO
#include "rvl/mtx.h"
#include "rvl/GXEnum.h"
#include "rvl/GXStruct.h"
#include "rvl/GXTransform.h"
#include "rvl/GXGeometry.h"
#include "rvl/GXDispList.h"
#include "rvl/GXLighting.h"
#include "rvl/GXTev.h"
#include "rvl/GXTexture.h"
#include "rvl/GXCull.h"
#include "rvl/GXPixel.h"
#include "rvl/GXBump.h"
#include "rvl/GXVert.h"
#include "rvl/vifuncs.h"
#include <rvl/GXFrameBuffer.h>
#include <rvl/tpl.h>
#include <newer.h>
void *EGG__Heap__alloc(unsigned long size, int unk, void *heap);
void EGG__Heap__free(void *ptr, void *heap);

extern char CameraLockEnabled;
extern VEC2 CameraLockPosition;

extern char isLockPlayerRotation;
extern s16 lockedPlayerRotation;

extern bool NoMichaelBuble;

mTexture_c efbTexture;
bool getNextEFB = false;
int thing = 0;

const char *CreditsFileList[] = {"CreditsBG", 0};

extern "C" void GXPixModeSync();
extern "C" void *MakeMarioEnterDemoMode();
extern "C" void *MakeMarioExitDemoMode();

struct FireworkInfo {
	const char *name;
	float xOffset, yOffset;
	int delay;
};

extern void *SoundRelatedClass;

extern u16 DanceValues_AnimSpeed; // 80427C2E
extern u8 DanceValues_DummyBlockAndGrass; // 8042A049
extern u8 DanceValues_Bahps; // 8042A04A
extern u8 DanceValues_CreditsControl; // 8042A04B


void WriteAsciiToTextBox(nw4r::lyt::TextBox *tb, const char *source) {
	int i = 0;
	wchar_t buffer[1024];
	while (i < 1023 && source[i]) {
		buffer[i] = source[i];
		i++;
	}
	buffer[i] = 0;

	tb->SetString(buffer);
}

class dFlipbookRenderer_c : public m3d::proc_c {
	public:
		dFlipbookRenderer_c();
		~dFlipbookRenderer_c();

		mAllocator_c allocator;
		void drawOpa();
		void drawXlu();
		void execute();

		bool isEnabled;
		int flipFrame;

		int scheduledBG;

		char *tplBuffer[2];
		u32 tplBufferSize[2];
		GXTexObj bgTexObj[2];

		void loadNewBG(int bgID, bool isBackface);
};

struct danceInfo_s {
	u32 when;
	u8 animSpeed, dummyBlockFlag, bahpFlag, creditsFlag;
};

class dCreditsMgr_c : public dActorState_c {
	public:
		int onCreate();
		int onDelete();
		int onExecute();
		int onDraw();

		int currentPathID;

		bool isOutOfView() { return false; }
		Vec2 _vf70();

		dDvdLoader_c scriptLoader;
		const u8 *scriptPos;

		dFlipbookRenderer_c renderer;

		bool loadLayout();
		bool loadTitleLayout();
		bool layoutLoaded;
		bool titleLayoutLoaded;
		m2d::EmbedLayout_c layout;
		m2d::EmbedLayout_c titleLayout;

		bool titleLayoutVisible;

		int countdown;

		bool fireworks;
		int fireworksCountdown;
		int fwID;

		int fauxScrollFrame;
		float fauxScrollMinX, fauxScrollMaxX, fauxScrollY;

		VEC2 endingLockPositions[4];

		danceInfo_s *danceCommand;
		int danceTimer;

		nw4r::lyt::TextBox
			*Title, *TitleS,
			*Name, *NameS,
			*LeftName, *LeftNameS,
			*RightName, *RightNameS;
		nw4r::lyt::Pane
			*TitleContainer, *NamesContainer,
			*OneNameC, *TwoNamesC, *N_proportionC_00;

		void doAutoscroll(int pathID);
		void positionPlayers();

		void animComplete();

		void enableZoom();
		void disableZoom();
		void playerWinAnim();
		void playerLookUp();
		void theEnd();
		void exitStage();

		bool endingMode;

//		USING_STATES(dCreditsMgr_c);
//		DECLARE_STATE(Wait);
//		DECLARE_STATE(PlayLayoutAnim);
//		DECLARE_STATE(Flipping);

		static dCreditsMgr_c *build();
		static dCreditsMgr_c *instance;
};
// CREATE_STATE(dCreditsMgr_c, Wait);
// CREATE_STATE(dCreditsMgr_c, PlayLayoutAnim);
// CREATE_STATE(dCreditsMgr_c, Flipping);

dCreditsMgr_c *dCreditsMgr_c::instance = 0;

dCreditsMgr_c *dCreditsMgr_c::build() {
	void *buf = AllocFromGameHeap1(sizeof(dCreditsMgr_c));
	return new(buf) dCreditsMgr_c;
}


int dCreditsMgr_c::onCreate() {
	NoMichaelBuble = true;

	instance = this;

	if (!loadLayout())
		return false;
	if (!loadTitleLayout())
		return false;

	if (!scriptLoader.load("/NewerRes/NewerStaffRoll.bin"))
		return false;

	scriptPos = (const u8*)scriptLoader.buffer;

	getNextEFB = true; // make sure we have a texture

	renderer.allocator.setup(GameHeaps[0], 0x20);
	bool result = renderer.setup(&renderer.allocator);

	renderer.loadNewBG(0, false);

	//acState.setState(&StateID_Wait);

	return true;
}

int dCreditsMgr_c::onDelete() {
	instance = 0;

	isLockPlayerRotation = false;

	scriptLoader.unload();
	return layout.free() && titleLayout.free();
}
extern "C" bool SpawnEffect(const char*, int, Vec*, S16Vec*, Vec*);
int dCreditsMgr_c::onExecute() {
	danceTimer++;
	if (danceCommand == 0)
		danceCommand = (danceInfo_s*)getResource("CreditsBG", "/Dance.bin");

	char *autoscrInfo = ((char*)dBgGm_c::instance) + 0x900AC;

	fauxScrollFrame++;
	if (fauxScrollFrame > 60)
		fauxScrollFrame = 60;
	float fsMult = (1.0f / 60.0f) * float(fauxScrollFrame);
	float interp = float(fauxScrollMinX) + ((fauxScrollMaxX - fauxScrollMinX) * fsMult);
	CameraLockPosition.x = interp;
	CameraLockPosition.y = fauxScrollY;

	if (endingMode) {
		for (int i = 0; i < 4; i++) {
			dAcPy_c *player;
			if ((player = dAcPy_c::findByID(i))) {
				if (!player->testFlag(0x24)) {
					player->setAnimePlayWithAnimID(0);
				}
				player->setFlag(0x24);
				player->rot.y = 0;
				player->speed.x = player->speed.y = player->speed.z = 0.0f;
				player->pos.x = endingLockPositions[i].x;
				player->pos.y = endingLockPositions[i].y;
			}
		}
	}

	if (fireworks) {
		fireworksCountdown--;
		if (fireworksCountdown <= 0) {
			static const FireworkInfo fwInfo[] = {
				{"Wm_ob_fireworks_g", 20.000000f, 49.000000f, 8}, // ends @ 8
				{"Wm_ob_fireworks_1up", 154.000000f, 80.000000f, 14}, // ends @ 22
				{"Wm_ob_fireworks_b", 168.000000f, 27.000000f, 33}, // ends @ 55
				{"Wm_ob_fireworks_1up", 416.000000f, 22.000000f, 33}, // ends @ 88
				{"Wm_ob_fireworks_y", 179.000000f, 11.000000f, 8}, // ends @ 96
				{"Wm_ob_fireworks_star", 9.000000f, 35.000000f, 25}, // ends @ 121
				{"Wm_ob_fireworks_y", 398.000000f, 29.000000f, 11}, // ends @ 132
				{"Wm_ob_fireworks_g", 127.000000f, 64.000000f, 21}, // ends @ 153
				{"Wm_ob_fireworks_star", 439.000000f, 66.000000f, 3}, // ends @ 156
				{"Wm_ob_fireworks_k", 320.000000f, 18.000000f, 31}, // ends @ 187
				{"Wm_ob_fireworks_p", 158.000000f, 47.000000f, 42}, // ends @ 229
				{"Wm_ob_fireworks_star", 127.000000f, 1.000000f, 29}, // ends @ 258
				{"Wm_ob_fireworks_k", 164.000000f, 50.000000f, 18}, // ends @ 276
				{"Wm_ob_fireworks_g", 365.000000f, 25.000000f, 39}, // ends @ 315
				{"Wm_ob_fireworks_k", 2.000000f, 78.000000f, 44}, // ends @ 359
				{"Wm_ob_fireworks_g", 309.000000f, 25.000000f, 42}, // ends @ 401
				{"Wm_ob_fireworks_star", 222.000000f, 78.000000f, 44}, // ends @ 445
				//{"Wm_ob_fireworks_y", 269.000000f, 23.000000f, 38}, // ends @ 483
				{0, 0.0f, 0.0f, 0},
			};

			fireworksCountdown = fwInfo[fwID].delay;
			float xOffs = fwInfo[fwID].xOffset;
			float yOffs = fwInfo[fwID].yOffset;
			VEC3 efPos = {10208.0f + xOffs, -304.0f - yOffs, pos.z + 200.0f};

			SpawnEffect(fwInfo[fwID].name, 0, &efPos, 0, 0);

			nw4r::snd::SoundHandle handle;
			PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_OBJ_GOAL_FIREWORKS, 1);

			fwID++;
			if (!fwInfo[fwID].name)
				fireworks = false;
		}
	}

	if (countdown > 0) {
		countdown--;
	} else if (!renderer.isEnabled) {
		if (!endingMode)
			isLockPlayerRotation = false;

		// Execute commands if we can
		bool exitInterpreter = false;
		while (scriptPos && !exitInterpreter) {
			int u16_top, u16_bottom;
			int whatAnim;
			u8 *staffCreditScore;
			nw4r::lyt::Pane *paneThing;

			const u8 *read = scriptPos;
			int cmdSize = *(read++);
			int cmdType = *(read++);

			scriptPos += cmdSize;

			switch (cmdType) {
				case 0: // Stop running script
					scriptPos = 0;
					exitInterpreter = true;
					break;

				case 1: // Delay
					u16_top = *(read++);
					u16_bottom = *(read++);
					countdown = (u16_top << 8) | u16_bottom;
					exitInterpreter = true;
					break;

				case 2: // Switch scene
					doAutoscroll(*(read++));
					break;

				case 3: // Switch scene and wait
					doAutoscroll(*(read++));
					exitInterpreter = true;
					break;

				case 4: // Show scores
					staffCreditScore = GetStaffCreditScore();
					staffCreditScore[0x279] = 1;
					// Hide the high score bit
					paneThing = *((nw4r::lyt::Pane**)(staffCreditScore + 0x274));
					paneThing->SetVisible(false);
					OSReport("Staff Credit Score object is at %p, going to show it\n", staffCreditScore);
					break;

				case 5: // Show text
					layout.enableNonLoopAnim(0);
					break;
				case 6: // Hide text
					layout.enableNonLoopAnim(1);
					break;

				case 7: { // Set names. FUN!
					int titleLength = *(read++);
					int nameCount = *(read++);

					WriteAsciiToTextBox(Title, (const char*)read);
					WriteAsciiToTextBox(TitleS, (const char*)read);

					read += titleLength;

					WriteAsciiToTextBox(Name, (const char*)read);
					WriteAsciiToTextBox(NameS, (const char*)read);

					float calcHeight = 29.0f * nameCount;
					TitleContainer->trans.y = (calcHeight * 0.5f) + 3.0f;

					OneNameC->SetVisible(true);
					TwoNamesC->SetVisible(false);

					} break;

				case 8:
					titleLayoutVisible = true;
					break;
				case 9:
					titleLayoutVisible = false;
					break;
				case 10:
					whatAnim = *(read++);
					titleLayout.enableNonLoopAnim(whatAnim);
					break;

				case 11:
					endingMode = true;
					break;
				case 12:
					enableZoom();
					break;
				case 13:
					playerWinAnim();
					break;
				case 14:
					disableZoom();
					break;
				case 15:
					playerLookUp();
					break;
				case 16:
					theEnd();
					break;
				case 17:
					exitStage();
					exitInterpreter = true;
					break;
				case 18:
					GetTheEnd()->willHide = true;
					break;
				case 19:
					fireworks = true;
					fireworksCountdown = 25;
					break;
				case 20:
					fireworks = false;
					break;
			}
		}
	}

	layout.execAnimations();
	layout.update();

	titleLayout.execAnimations();
	titleLayout.update();

	//acState.execute();
	renderer.execute();

	return true;
}

int dCreditsMgr_c::onDraw() {
	renderer.scheduleForDrawing();
	layout.scheduleForDrawing();
	if (titleLayoutVisible)
		titleLayout.scheduleForDrawing();
	return true;
}


bool dCreditsMgr_c::loadLayout() {
	if (!layoutLoaded) {
		if (!layout.loadArc("StaffRoll.arc", false))
			return false;

		layout.build("StaffRoll.brlyt");

		static const char *brlanNames[] = {
			"StaffRoll_show.brlan",
			"StaffRoll_hide.brlan",
		};
		static const char *groupNames[] = {
			"TheOnlyGroup", "TheOnlyGroup"
		};

		layout.loadAnimations(brlanNames, 2);
		layout.loadGroups(groupNames, (int[2]){0, 1}, 2);
		layout.disableAllAnimations();
		layout.resetAnim(0);

		static const char *tbNames[] = {
			"Title", "TitleS",
			"Name", "NameS",
			"LeftName", "LeftNameS",
			"RightName", "RightNameS"
		};
		static const char *paneNames[] = {
			"TitleContainer", "NamesContainer",
			"OneNameC", "TwoNamesC",
		};

		layout.getTextBoxes(tbNames, &Title, 8);
		layout.getPanes(paneNames, &TitleContainer, 4);

		layoutLoaded = true;
	}
	return layoutLoaded;
}

bool dCreditsMgr_c::loadTitleLayout() {
	if (!titleLayoutLoaded) {
		if (!titleLayout.loadArc("StaffRollTitle.arc", false))
			return false;

		titleLayout.build("StaffRollTitle.brlyt");

		static const char *brlanNames[] = {
			"StaffRollTitle_appear1.brlan",
			"StaffRollTitle_appear2.brlan",
		};
		static const char *groupNames[] = {
			"TheOnlyGroup", "TheOnlyGroup"
		};

		titleLayout.loadAnimations(brlanNames, 2);
		titleLayout.loadGroups(groupNames, (int[2]){0, 1}, 2);
		titleLayout.disableAllAnimations();
		titleLayout.resetAnim(1);

		float propScale = 1.3f;
		if (!IsWideScreen())
			propScale *= 0.85f;

		N_proportionC_00 = titleLayout.findPaneByName("N_proportionC_00");
		N_proportionC_00->trans.y = -130.0f;
		N_proportionC_00->scale.x = propScale;
		N_proportionC_00->scale.y = propScale;

		titleLayoutLoaded = true;
	}
	return titleLayoutLoaded;
}

extern "C" dCourse_c::rail_s *GetRail(int id);

void dCreditsMgr_c::doAutoscroll(int pathID) {
	OSReport("Activating Autoscroll with path %d\n", pathID);

	getNextEFB = true;
	renderer.isEnabled = true;
	renderer.flipFrame = 0;
	renderer.scheduledBG = pathID;
	MakeMarioEnterDemoMode();

	char *autoscrInfo = ((char*)dBgGm_c::instance) + 0x900AC;
	*((u8*)(autoscrInfo + 0x14)) = pathID;
	*((u8*)(autoscrInfo + 0x15)) = 1; // unk11
	*((u8*)(autoscrInfo + 0x16)) = 0; // atEnd Related
	*((u8*)(autoscrInfo + 0x17)) = 2; // atEnd
	*((u8*)(autoscrInfo + 0x18)) = 0; // mode
	*((u8*)(autoscrInfo + 0x1A)) = 1; // isAutoscrolling
	*((u32*)(((char*)dBgGm_c::instance) + 0x900EC)) = 0; // node ID
	*((u32*)(((char*)dBgGm_c::instance) + 0x900F0)) = 0; // ?

	currentPathID = pathID;

	dCourse_c::rail_s *rail = GetRail(pathID);
	dCourse_c *course = dCourseFull_c::instance->get(GetAreaNum());

	dCourse_c::railNode_s *firstNode = &course->railNode[rail->startNode];
	dCourse_c::railNode_s *secondNode = &course->railNode[rail->startNode+1];

	fauxScrollFrame = 0;
	fauxScrollMinX = firstNode->xPos;
	fauxScrollMaxX = secondNode->xPos;
	fauxScrollY = -firstNode->yPos;

	CameraLockEnabled = 1;

	// set directions
	isLockPlayerRotation = true;
	lockedPlayerRotation = endingMode ? 0 : 0x3000;

	for (int i = 0; i < 4; i++) {
		dAcPy_c *player;
		if ((player = dAcPy_c::findByID(i))) {
			player->direction = 0;
			player->rot.y = 0x3000;
		}
	}
}

void dCreditsMgr_c::animComplete() {
	positionPlayers();
}


void dCreditsMgr_c::positionPlayers() {
	dCourse_c *course = dCourseFull_c::instance->get(GetAreaNum());
	dCourse_c::nextGoto_s *entrance = course->getNextGotoByID(currentPathID);

	float diff = endingMode ? 48.0f : 24.0f;
	float playerPositions[4];
	playerPositions[0] = entrance->xPos;
	playerPositions[1] = playerPositions[0] - diff;
	playerPositions[2] = playerPositions[0] + diff;
	playerPositions[3] = playerPositions[0] + diff + diff;

	// This is annoying
	dAcPy_c *players[4];
	for (int i = 0; i < 4; i++)
		players[i] = dAcPy_c::findByID(i);

	static const int crap[4] = {0,1,3,2};

	int whichPos = 0;
	for (int i = 0; i < 4; i++) {
		dAcPy_c *player = 0;
		// Find the player matching this ID
		for (int j = 0; j < 4; j++) {
			if (Player_ID[players[j]->settings & 0xF] == crap[i]) {
				player = players[j];
				break;
			}
		}

		if (player) {
			player->pos.x = playerPositions[whichPos];
			player->pos.y = -(entrance->yPos + 16);
			player->direction = 0;
			player->rot.y = 0x3000;
			player->speed.x = player->speed.y = player->speed.z = 0.0f;
			dPlayerModelHandler_c *pmh = (dPlayerModelHandler_c*)(((u32)player) + 0x2A60);
			pmh->mdlClass->startAnimation(0, 1.0f, 0.0f, 0.0f);
			whichPos++;

			u32 *pInactivityCounter = (u32*)(((u32)player) + 0x480);
			*pInactivityCounter = 177;

			endingLockPositions[i].x = player->pos.x;
			endingLockPositions[i].y = player->pos.y;
		}
	}
}


void dCreditsMgr_c::enableZoom() {
	BgGmBase::manualZoomEntry_s &zoom = dBgGm_c::instance->manualZooms[0];
	zoom.x1 = 10218.0f;
	zoom.x2 = 11000.0f;
	zoom.y1 = -200.0f;
	zoom.y2 = -600.0f;

	zoom.x1 = 1100.0f;
	zoom.x2 = 1300.0f;
	zoom.y1 = -400.0f;
	zoom.y2 = -550.0f;
	zoom.zoomLevel = 7;
	zoom.unkValue6 = 0;
	zoom.firstFlag = 0;
}
void dCreditsMgr_c::disableZoom() {
	BgGmBase::manualZoomEntry_s &zoom = dBgGm_c::instance->manualZooms[0];
	zoom.unkValue6 = 100;
}
void dCreditsMgr_c::playerWinAnim() {
	// who won?
	// First, get the amounts
	u8 *amountsU8 = GetStaffCreditScore() + 0x288;
	int *playerAmounts = (int*)(amountsU8);
	int maxSoFar = 0;

	for (int i = 0; i < 4; i++) {
		if (playerAmounts[i] > maxSoFar)
			maxSoFar = playerAmounts[i];
	}

	if (maxSoFar == 0)
		return;

	// did anyone win?
	for (int i = 0; i < 4; i++) {
		if (playerAmounts[i] == maxSoFar) {
			dAcPy_c *player = dAcPy_c::findByID(i);
			if (!player)
				continue;

			player->setAnimePlayWithAnimID(goal_puton_capA);
			player->setFlag(0x24);

			static const int vocs[4] = {
				SE_VOC_MA_CLEAR_NORMAL,
				SE_VOC_LU_CLEAR_NORMAL,
				SE_VOC_KO_CLEAR_NORMAL,
				SE_VOC_KO2_CLEAR_NORMAL
			};
			dPlayerModelHandler_c *pmh = (dPlayerModelHandler_c*)(((u32)player) + 0x2A60);
			int voc = vocs[pmh->mdlClass->player_id_2];
			nw4r::snd::SoundHandle handle;
			PlaySoundWithFunctionB4(SoundRelatedClass, &handle, voc, 1);

			int powerup = *((u32*)( 0x1090 + ((u8*)player) ));
			handle.SetPitch(powerup == 3 ? 1.5f : 1.0f);
		}
	}
}

void dCreditsMgr_c::playerLookUp() {
	_120 |= 8;
	lookAtMode = 2; // Higher maximum distance
}
void dCreditsMgr_c::theEnd() {
	GetTheEnd()->willShow = true;
}
void dCreditsMgr_c::exitStage() {
	SaveBlock *save = GetSaveFile()->GetBlock(-1);
	bool wasPreviouslyBeat = (save->bitfield & 2) != 0;
	save->bitfield |= 2;

	ExitStage(WORLD_MAP, wasPreviouslyBeat ? 0 : 0x20000000, BEAT_LEVEL, CIRCLE_WIPE);
}

Vec2 dCreditsMgr_c::_vf70() {
	// HACK OF THE MILLENIUM
	// DON'T TRY THIS AT HOME.
	Vec2 *v = (Vec2*)this;
	v->x = 10454.0f;
	v->y = -320.0f;
	return (const Vec2){12345.0f, 67890.f};
}



void EFBMagic2() {
	if (getNextEFB) {
		getNextEFB = false;

		GXRenderModeObj *ro = nw4r::g3d::G3DState::GetRenderModeObj();
		efbTexture.format = GX_TF_RGB565;
		efbTexture.width = ro->fbWidth;
		efbTexture.height = ro->efbHeight;
		efbTexture.wrapS = GX_CLAMP;
		efbTexture.wrapT = GX_CLAMP;

		if (efbTexture.getBuffer() == 0)
			efbTexture.allocateBuffer(GameHeaps[2]);

		GXSetTexCopySrc(0, 0, efbTexture.width, efbTexture.height);
		GXSetTexCopyDst(efbTexture.width, efbTexture.height, (GXTexFmt)efbTexture.format, GX_FALSE);
		GXSetCopyFilter(GX_FALSE, 0, GX_FALSE, 0);
		GXCopyTex(efbTexture.getBuffer(), GX_FALSE);

		GXPixModeSync();
		GXInvalidateTexAll();
	}
}

void dFlipbookRenderer_c::execute() {
	if (flipFrame == 7) {
		loadNewBG(scheduledBG, true);
	}

	if (isEnabled) {
		flipFrame += 7;

		ClassWithCameraInfo *cwci = ClassWithCameraInfo::instance;
		if (flipFrame > int(cwci->screenWidth)) {
			loadNewBG(scheduledBG, false);
			dCreditsMgr_c::instance->animComplete();

			if (!dCreditsMgr_c::instance->endingMode)
				MakeMarioExitDemoMode();
			isEnabled = false;
			OSReport("DONE!\n");
		}
	}
}


static void setupGXForDrawingCrap() {
	GXSetNumChans(0);
	GXSetChanCtrl(GX_COLOR0A0, GX_DISABLE, GX_SRC_REG, GX_SRC_REG, GX_LIGHT_NULL, GX_DF_NONE, GX_AF_NONE);
	GXSetChanAmbColor(GX_COLOR0A0, (GXColor){255,255,255,255});
	GXSetChanMatColor(GX_COLOR0A0, (GXColor){255,255,255,255});
	GXSetNumTexGens(1);
	GXSetTexCoordGen2(GX_TEXCOORD0, GX_TG_MTX3x4, GX_TG_NRM, GX_IDENTITY, GX_FALSE, GX_PTIDENTITY);

	GXSetNumTevStages(1);
	GXSetNumIndStages(0);
	for (int i = 0; i < 0x10; i++)
		GXSetTevDirect((GXTevStageID)i);

	GXSetTevOp(GX_TEVSTAGE0, GX_REPLACE);
	GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR_NULL);

	GXSetTevSwapModeTable(GX_TEV_SWAP0, GX_CH_RED, GX_CH_GREEN, GX_CH_BLUE, GX_CH_ALPHA);

	GXSetZCompLoc(GX_FALSE);
	GXSetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_SET);
	//GXSetBlendMode(GX_BM_NONE, GX_BL_ZERO, GX_BL_ZERO, GX_LO_SET);
	GXSetZMode(GX_TRUE, GX_ALWAYS, GX_FALSE);
	GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);

	GXSetFog(GX_FOG_NONE, 0, 0, 0, 0, (GXColor){0,0,0,0});
	GXSetFogRangeAdj(GX_FALSE, 0, 0);

	GXSetAlphaUpdate(GX_TRUE);

	GXSetCullMode(GX_CULL_NONE);

	GXSetDither(GX_TRUE);

	GXSetTevColor(GX_TEVREG0, (GXColor){255,255,255,255});
	GXSetTevColor(GX_TEVREG1, (GXColor){255,255,255,255});
	GXSetTevColor(GX_TEVREG2, (GXColor){255,255,255,255});

	GXSetZMode(GX_TRUE, GX_LEQUAL, GX_TRUE);

	nw4r::g3d::Camera cam(GetCameraByID(GetCurrentCameraID()));
	Mtx matrix;
	cam.GetCameraMtx(&matrix);
	GXLoadPosMtxImm(matrix, 0);
	GXSetCurrentMtx(0);

	GXClearVtxDesc();

	GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
	GXSetVtxDesc(GX_VA_NRM, GX_DIRECT);

	GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
	GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_NRM, GX_NRM_XYZ, GX_F32, 0);
}

void dFlipbookRenderer_c::drawXlu() {
	if (!isEnabled || flipFrame < 2)
		return;

	setupGXForDrawingCrap();

	ClassWithCameraInfo *cwci = ClassWithCameraInfo::instance;

	float screenTop = cwci->screenTop + Stage80::instance->screenYOffset;
	float left = cwci->screenLeft + Stage80::instance->screenXOffset;
	float right = left + cwci->screenWidth;

	float halfWidth = (cwci->screenWidth * 0.5f);
	float midpoint = left + halfWidth;

	float value = (flipFrame / cwci->screenWidth);
	float sinThing = 50.0f * sin(3.14159f * value);

	bool drawBackside = (flipFrame > halfWidth);

	float xformedFlipEdge = right - flipFrame;

	// EFB SPECIFIC VERTICAL VARIABLES
	float efbEffectiveHeight = cwci->screenHeight;
	if (!IsWideScreen())
		efbEffectiveHeight *= 1.295f;

	float efbHalfHeight = (efbEffectiveHeight * 0.5f);

	float efbYCentre = screenTop - (cwci->screenHeight * 0.5f);
	if (!IsWideScreen())
		efbYCentre += 1.0f;
	float efbTop = efbYCentre + efbHalfHeight;
	float efbBottom = efbYCentre - efbHalfHeight;

	float efbExCoord = (efbEffectiveHeight + sinThing + sinThing) * 0.5f;
	// TPL SPECIFIC VERTICAL VARIABLES
	float tplHalfHeight = cwci->screenHeight * 0.5f;
	float tplTop = screenTop;
	float tplBottom = screenTop - cwci->screenHeight;

	float tplExCoord = (cwci->screenHeight + sinThing + sinThing) * 0.5f;


	// EFB Left
	efbTexture.load(GX_TEXMAP0);

	GXBegin(GX_QUADS, GX_VTXFMT0, 4);
	{
		// Bottom Right
		GXPosition3f32(midpoint, efbBottom, 9990.0f);
		GXNormal3f32(0.5f, 1.0f, 1.0f);
		// Top Right
		GXPosition3f32(midpoint, efbTop, 9990.0f);
		GXNormal3f32(0.5f, 0.0f, 1.0f);
		// Top Left
		GXPosition3f32(left, efbTop, 9990.0f);
		GXNormal3f32(0.0f, 0.0f, 1.0f);
		// Bottom Left
		GXPosition3f32(left, efbBottom, 9990.0f);
		GXNormal3f32(0.0f, 1.0f, 1.0f);
	}
	GXEnd();

	// TPL Right
	GXLoadTexObj(&bgTexObj[1], GX_TEXMAP0);

	GXBegin(GX_QUADS, GX_VTXFMT0, 4);
	{
		// Bottom Right
		GXPosition3f32(right, tplBottom, 9990.0f);
		GXNormal3f32(1.0f, 1.0f, 1.0f);
		// Top Right
		GXPosition3f32(right, tplTop, 9990.0f);
		GXNormal3f32(1.0f, 0.0f, 1.0f);
		// Top Left
		GXPosition3f32(midpoint, tplTop, 9990.0f);
		GXNormal3f32(0.5f, 0.0f, 1.0f);
		// Bottom Left
		GXPosition3f32(midpoint, tplBottom, 9990.0f);
		GXNormal3f32(0.5f, 1.0f, 1.0f);

	}
	GXEnd();


	if (!drawBackside) {
		// Flipping right side: EFB

		efbTexture.load(GX_TEXMAP0);

		GXBegin(GX_QUADS, GX_VTXFMT0, 4);

		// EFB Right (Flipped)
		// Bottom Left
		GXPosition3f32(midpoint, efbBottom, 9990.0f);
		GXNormal3f32(efbHalfHeight * 0.5f, efbHalfHeight, efbHalfHeight);
		// Top Left
		GXPosition3f32(midpoint, efbTop, 9990.0f);
		GXNormal3f32(efbHalfHeight * 0.5f, 0.0f, efbHalfHeight);
		// Top Right
		GXPosition3f32(xformedFlipEdge, efbTop + sinThing, 9990.0f);
		GXNormal3f32(efbExCoord, 0.0f, efbExCoord);
		// Bottom Right
		GXPosition3f32(xformedFlipEdge, efbBottom - sinThing, 9990.0f);
		GXNormal3f32(efbExCoord, efbExCoord, efbExCoord);

		GXEnd();

	} else {
		// Flipping left side

		GXLoadTexObj(&bgTexObj[1], GX_TEXMAP0);

		GXBegin(GX_QUADS, GX_VTXFMT0, 4);

		// TPL Left (Flipped))
		// Bottom Left
		GXPosition3f32(xformedFlipEdge, tplBottom - sinThing, 9990.0f);
		GXNormal3f32(0.0f, tplExCoord, tplExCoord);
		// Top Left
		GXPosition3f32(xformedFlipEdge, tplTop + sinThing, 9990.0f);
		GXNormal3f32(0.0f, 0.0f, tplExCoord);
		// Top Right
		GXPosition3f32(midpoint, tplTop, 9990.0f);
		GXNormal3f32(tplHalfHeight * 0.5f, 0.0f, tplHalfHeight);
		// Bottom Right
		GXPosition3f32(midpoint, tplBottom, 9990.0f);
		GXNormal3f32(tplHalfHeight * 0.5f, tplHalfHeight, tplHalfHeight);

		GXEnd();
	}
}


void dFlipbookRenderer_c::drawOpa() {
	setupGXForDrawingCrap();

	GXLoadTexObj(&bgTexObj[0], GX_TEXMAP0);

	ClassWithCameraInfo *cwci = ClassWithCameraInfo::instance;
	float left = cwci->screenLeft + Stage80::instance->screenXOffset;
	float right = left + cwci->screenWidth;
	float top = cwci->screenTop + Stage80::instance->screenYOffset;
	float bottom = top - cwci->screenHeight;

	GXBegin(GX_QUADS, GX_VTXFMT0, 4);
	GXPosition3f32(right, bottom, -4000.0f);
	GXNormal3f32(1.0f, 1.0f, 1.0f);
	GXPosition3f32(right, top, -4000.0f);
	GXNormal3f32(1.0f, 0.0f, 1.0f);
	GXPosition3f32(left, top, -4000.0f);
	GXNormal3f32(0.0f, 0.0f, 1.0f);
	GXPosition3f32(left, bottom, -4000.0f);
	GXNormal3f32(0.0f, 1.0f, 1.0f);
	GXEnd();
}

#include <rvl/OSCache.h>

void dFlipbookRenderer_c::loadNewBG(int bgID, bool isBackface) {
	OSReport("Will load BG: %d\n", bgID);

	int setID = isBackface ? 1 : 0;

	char bgName[32];
	sprintf(bgName, isBackface ? "/Back%d.tpl.LZ" : "/BG%d.tpl.LZ", bgID);
	OSReport("Getting %s\n", bgName);

	u8 *sourceBuf = getResource("CreditsBG", bgName);
	u32 bufSize = CXGetUncompressedSize(sourceBuf);

	if (tplBuffer[setID] && (tplBufferSize[setID] != bufSize)) {
		OSReport("Current TPL buffer (%p) is size %d (0x%x), freeing\n", tplBuffer[setID], tplBufferSize[setID], tplBufferSize[setID]);
		EGG__Heap__free(tplBuffer[setID], GameHeaps[2]);
		tplBuffer[setID] = 0;
	}

	if (!tplBuffer[setID]) {
		OSReport("Allocating TPL buffer of size %d (0x%x)\n", bufSize, bufSize);
		tplBuffer[setID] = (char*)EGG__Heap__alloc(bufSize, 0x20, GameHeaps[2]);
		tplBufferSize[setID] = bufSize;
	}

	//CXUncompContextLH context;
	//CXInitUncompContextLH(&context, tplBuffer);
	//int result = CXReadUncompLH(&context, sourceBuf, 0x1000000);
	//OSReport("Source buf: %p / Dest buf: %p / Dest size: %d (0x%x)\n", sourceBuf, tplBuffer, bufSize, bufSize);
	//OSReport("CXReadUncompLH result: %d\n", result);
	CXUncompressLZ(sourceBuf, tplBuffer[setID]);
	OSReport("Butts. Decompressing %p to %p.\n", sourceBuf, tplBuffer[setID]);

	TPLBind((TPLPalettePtr)tplBuffer[setID]);
	TPLDescriptorPtr desc = TPLGet((TPLPalettePtr)tplBuffer[setID], 0);
	TPLHeaderPtr tex = desc->textureHeader;
	OSReport("Received TPLHeader %p; Data: %p; Size: %d x %d; Format; %d\n", tex, tex->data, tex->width, tex->height, tex->format);

	GXInitTexObj(&bgTexObj[setID], tex->data, tex->width, tex->height,
			(GXTexFmt)tex->format, tex->wrapS, tex->wrapT, GX_FALSE);
}

dFlipbookRenderer_c::dFlipbookRenderer_c() {
	scheduledBG = -1;
}

dFlipbookRenderer_c::~dFlipbookRenderer_c() {
	for (int setID = 0; setID < 2; setID++) {
		if (tplBuffer[setID]) {
			EGG__Heap__free(tplBuffer[setID], GameHeaps[2]);
			tplBuffer[setID] = 0;
		}
	}
}


void LoadDanceValues() {
	/*
	//OSReport("AnmSpd: %4d / DBAG: 0x%02x / Bahp: 0x%02x / Cred: 0x%02x\n",
	//	DanceValues_AnimSpeed, DanceValues_DummyBlockAndGrass, DanceValues_Bahps, DanceValues_CreditsControl);
	if (DanceValues_CreditsControl > 0)
		OSReport("[ORIG DANCE] Credits Control: 0x%02x\n", DanceValues_CreditsControl);
	// if (DanceValues_DummyBlockAndGrass > 0)
	// 	OSReport("[ORIG DANCE] DummyBlockAndGrass: 0x%02x\n", DanceValues_DummyBlockAndGrass);
	if (DanceValues_Bahps > 0)
		OSReport("[ORIG DANCE] Bahps: 0x%02x\n", DanceValues_Bahps);
	*/

	dCreditsMgr_c *cred = dCreditsMgr_c::instance;

	if (!cred)
		return;
	danceInfo_s *cmd = cred->danceCommand;
	if (!cmd)
		return;
	//OSReport("TIMER: %d\n", cred->danceTimer);

	if (cred->danceTimer == cmd->when) {
		//OSReport("Timer reached %d, triggering dance 0x%02x, next is at %d\n", cmd->when, cmd->bahpFlag, cmd[1].when);
		DanceValues_AnimSpeed = cmd->animSpeed;
		DanceValues_DummyBlockAndGrass = cmd->dummyBlockFlag;
		DanceValues_Bahps = cmd->bahpFlag;
		DanceValues_CreditsControl = cmd->creditsFlag;

		cred->danceCommand++;
	} else {
		DanceValues_AnimSpeed = 120;
		DanceValues_DummyBlockAndGrass = 0;
		DanceValues_Bahps = 0;
		DanceValues_CreditsControl = 0;
	}
}



//
// processed\../src/chestnut.cpp
//

#include <game.h>
#include <sfx.h>
const char *ChestnutFileList[] = {"chestnut", 0};

class daEnChestnut_c : public dEn_c {
	public:
		static daEnChestnut_c *build();

		mHeapAllocator_c allocator;
		nw4r::g3d::ResFile resFile;
		m3d::mdl_c model;
		m3d::anmChr_c animation;

		void playAnimation(const char *name, bool loop = false);
		void playLoopedAnimation(const char *name) {
			playAnimation(name, true);
		}

		int objNumber;
		int starCoinNumber;
		bool ignorePlayers;
		bool breaksBlocks;
		float shakeWindow, fallWindow;

		int timeSpentExploding;

		lineSensor_s belowSensor;

		float nearestPlayerDistance();

		int onCreate();
		int onDelete();
		int onExecute();
		int onDraw();

		void spawnObject();

		bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
		bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);

		bool CreateIceActors();

		u32 canBePowed();
		void powBlockActivated(bool isNotMPGP);

		USING_STATES(daEnChestnut_c);
		DECLARE_STATE(Idle);
		DECLARE_STATE(Shake);
		DECLARE_STATE(Fall);
		DECLARE_STATE(Explode);
};

CREATE_STATE(daEnChestnut_c, Idle);
CREATE_STATE(daEnChestnut_c, Shake);
CREATE_STATE(daEnChestnut_c, Fall);
CREATE_STATE(daEnChestnut_c, Explode);

daEnChestnut_c *daEnChestnut_c::build() {
	void *buf = AllocFromGameHeap1(sizeof(daEnChestnut_c));
	return new(buf) daEnChestnut_c;
}


int daEnChestnut_c::onCreate() {
	// Get settings
	int texNum = settings & 0xF;
	int rawScale = (settings & 0xF0) >> 4;
	starCoinNumber = (settings & 0xF00) >> 8;
	ignorePlayers = ((settings & 0x1000) != 0);
	breaksBlocks = ((settings & 0x2000) != 0);
	objNumber = (settings & 0xF0000) >> 16;

	if ((settings & 0x4000) != 0) {
		shakeWindow = 96.0f;
		fallWindow = 64.0f;
	} else {
		shakeWindow = 64.0f;
		fallWindow = 32.0f;
	}

	// Set up models
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	char rfName[64];
	sprintf(rfName, "g3d/t%02d.brres", texNum);

	resFile.data = getResource("chestnut", rfName);

	nw4r::g3d::ResMdl resMdl = resFile.GetResMdl("kuribo_iga");
	nw4r::g3d::ResAnmChr resAnm = resFile.GetResAnmChr("wait");

	model.setup(resMdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&model, 0);

	animation.setup(resMdl, resAnm, &allocator, 0);

	allocator.unlink();


	// Scale us
	scale.x = scale.y = scale.z = (1.0f + (float(rawScale) * 0.5f));

	// Physics and crap
	ActivePhysics::Info ccInfo;
	ccInfo.xDistToCenter = 0.0f;
	ccInfo.xDistToEdge = 12.0f * scale.x;
	ccInfo.yDistToCenter = 1.0f + (12.0f * scale.y);
	ccInfo.yDistToEdge = 12.0f * scale.y;

	ccInfo.category1 = 3;
	ccInfo.category2 = 0;
	ccInfo.bitfield1 = 0x6F;
	ccInfo.bitfield2 = 0xFFBAFFFE;

	ccInfo.unkShort1C = 0;
	ccInfo.callback = &dEn_c::collisionCallback;

	aPhysics.initWithStruct(this, &ccInfo);
	aPhysics.addToList();

	// WE'RE READY
	doStateChange(&StateID_Idle);

	return true;
}

void daEnChestnut_c::playAnimation(const char *name, bool loop) {
	animation.bind(&model, resFile.GetResAnmChr(name), !loop);
	model.bindAnim(&animation, 0.0f);
	animation.setUpdateRate(1.0f);
}

int daEnChestnut_c::onDelete() {
	aPhysics.removeFromList();
	return true;
}

int daEnChestnut_c::onExecute() {
	acState.execute();

	matrix.translation(pos.x, pos.y, pos.z);

	model.setDrawMatrix(matrix);
	model.setScale(&scale);
	model.calcWorld(false);

	model._vf1C();

	return true;
}

int daEnChestnut_c::onDraw() {
	model.scheduleForDrawing();

	return true;
}

float daEnChestnut_c::nearestPlayerDistance() {
	float bestSoFar = 10000.0f;

	for (int i = 0; i < 4; i++) {
		if (dAcPy_c *player = dAcPy_c::findByID(i)) {
			if (strcmp(player->states2.getCurrentState()->getName(), "dAcPy_c::StateID_Balloon")) {
				float thisDist = abs(player->pos.x - pos.x);
				if (thisDist < bestSoFar)
					bestSoFar = thisDist;
			}
		}
	}

	return bestSoFar;
}



void daEnChestnut_c::beginState_Idle() {
	playLoopedAnimation("wait");
}
void daEnChestnut_c::endState_Idle() { }


void daEnChestnut_c::executeState_Idle() {
	if (ignorePlayers)
		return;

	float dist = nearestPlayerDistance();

	if (dist < fallWindow)
		doStateChange(&StateID_Fall);
	else if (dist < shakeWindow)
		doStateChange(&StateID_Shake);
}



void daEnChestnut_c::beginState_Shake() {
	playLoopedAnimation("shake");
	animation.setUpdateRate(2.0f);

	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_PLY_CLIMB_KUSARI, 1);
}
void daEnChestnut_c::endState_Shake() { }

void daEnChestnut_c::executeState_Shake() {
	float dist = nearestPlayerDistance();

	if (dist >= shakeWindow)
		doStateChange(&StateID_Idle);
	else if (dist < fallWindow)
		doStateChange(&StateID_Fall);
}



void daEnChestnut_c::beginState_Fall() {
	animation.setUpdateRate(0.0f); // stop animation

	int size = 12*scale.x;

	belowSensor.flags = SENSOR_LINE;
	if (breaksBlocks)
		belowSensor.flags |= SENSOR_10000000 | SENSOR_BREAK_BLOCK | SENSOR_BREAK_BRICK;
	// 10000000 makes it pass through bricks

	belowSensor.lineA = -size << 12;
	belowSensor.lineB = size << 12;
	belowSensor.distanceFromCenter = 0;

	collMgr.init(this, &belowSensor, 0, 0);

	speed.y = 0.0f;
	y_speed_inc = -0.1875f;
	max_speed.y = -4.0f;

	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_DEMO_OP_PRESENT_THROW_2308f, 1);
}

void daEnChestnut_c::endState_Fall() { }

void daEnChestnut_c::executeState_Fall() {
	HandleYSpeed();
	doSpriteMovement();
	UpdateObjectPosBasedOnSpeedValuesReal();

	if (collMgr.calculateBelowCollision() & (~0x400000)) {
		doStateChange(&StateID_Explode);
	}
}



void daEnChestnut_c::beginState_Explode() {
	OSReport("Entering Explode\n");
	playAnimation("break");
	animation.setUpdateRate(2.0f);

	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_DEMO_OP_LAND_JR_0983f, 1);

	timeSpentExploding = 0;
}
void daEnChestnut_c::endState_Explode() { }

void daEnChestnut_c::executeState_Explode() {
	timeSpentExploding++;

	if (timeSpentExploding == 10) {
		S16Vec efRot = {0,0,0};
		SpawnEffect("Wm_en_burst_ss", 0, &pos, &efRot, &scale);
		spawnObject();
	}

	if (animation.isAnimationDone()) {
		Delete(1);
	}
}



bool daEnChestnut_c::CreateIceActors() {
	animation.setUpdateRate(0.0f);
	
	IceActorSpawnInfo info;
	info.flags = 0;
	info.pos = pos;
	info.pos.y -= (6.0f * info.scale.y);
	info.scale.x = info.scale.y = info.scale.z = scale.x * 1.35f;
	for (int i = 0; i < 8; i++)
		info.what[0] = 0.0f;

	return frzMgr.Create_ICEACTORs(&info, 1);
}

u32 daEnChestnut_c::canBePowed() {
	return true;
}
void daEnChestnut_c::powBlockActivated(bool isNotMPGP) {
	if (!isNotMPGP)
		return;

	dStateBase_c *state = acState.getCurrentState();
	if (state == &StateID_Idle || state == &StateID_Shake)
		doStateChange(&StateID_Fall);
}

bool daEnChestnut_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	SpawnEffect("Wm_en_igafirehit", 0, &pos, &rot, &scale);

	if (acState.getCurrentState() != &StateID_Explode)
		doStateChange(&StateID_Explode);

	return true;
}

bool daEnChestnut_c::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->_vf220(apOther->owner);
	return true;
}


void daEnChestnut_c::spawnObject() {
	VEC3 acPos = pos;

	static const u32 things[] = {
		EN_KURIBO, 0,
		EN_TOGEZO, 0,
		EN_COIN_JUMP, 0,
		EN_ITEM, 0x05000009,
		EN_STAR_COIN, 0x10000000,
	};

	u32 acSettings = things[objNumber*2+1];

	if (objNumber == 4) {
		acSettings |= (starCoinNumber << 8);
		acPos.x -= 12.0f;
		acPos.y += 32.0f;
	}

	aPhysics.removeFromList();

	OSReport("Crap %d, %d, %08x\n", objNumber, things[objNumber*2], acSettings);
	dStageActor_c *ac =
		dStageActor_c::create((Actors)things[objNumber*2], acSettings, &acPos, 0, currentLayerID);

	S16Vec efRot = {0,0,0};
	SpawnEffect("Wm_ob_itemsndlandsmk", 0, &pos, &efRot, &scale);

	if (objNumber == 0) {
		dEn_c *en = (dEn_c*)ac;
		en->direction = 1;
		en->rot.y = -8192;
	}
}

//
// processed\../src/flipblock.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

const char *FlipBlockFileList[] = {"block_rotate", 0};

class daEnFlipBlock_c : public daEnBlockMain_c {
public:
	Physics::Info physicsInfo;

	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	void calledWhenUpMoveExecutes();
	void calledWhenDownMoveExecutes();

	void blockWasHit(bool isDown);

	bool playerOverlaps();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c model;

	int flipsRemaining;

	USING_STATES(daEnFlipBlock_c);
	DECLARE_STATE(Wait);
	DECLARE_STATE(Flipping);

	static dActor_c *build();
};

const SpriteData flipBlockSpriteData = { ProfileId::FlipBlock, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
 // Using WM_GRID as the execute order profile ID fixes bugs; original FlipBlock uses it as well
Profile flipBlockProfile(&daEnFlipBlock_c::build, SpriteId::FlipBlock, flipBlockSpriteData, ProfileId::WM_GRID, ProfileId::FlipBlock, "FlipBlock", FlipBlockFileList);


CREATE_STATE(daEnFlipBlock_c, Wait);
CREATE_STATE(daEnFlipBlock_c, Flipping);


int daEnFlipBlock_c::onCreate() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	resFile.data = getResource("block_rotate", "g3d/block_rotate.brres");
	model.setup(resFile.GetResMdl("block_rotate"), &allocator, 0, 1, 0);
	SetupTextures_MapObj(&model, 0);

	allocator.unlink();



	blockInit(pos.y);

	physicsInfo.x1 = -8;
	physicsInfo.y1 = 8;
	physicsInfo.x2 = 8;
	physicsInfo.y2 = -8;

	physicsInfo.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.flagsMaybe = 0x260;
	physics.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics.addToList();

	doStateChange(&daEnFlipBlock_c::StateID_Wait);

	return true;
}


int daEnFlipBlock_c::onDelete() {
	physics.removeFromList();

	return true;
}


int daEnFlipBlock_c::onExecute() {
	acState.execute();
	physics.update();
	blockUpdate();

	// now check zone bounds based on state
	if (acState.getCurrentState()->isEqual(&StateID_Wait)) {
		checkZoneBoundaries(0);
	}

	return true;
}


int daEnFlipBlock_c::onDraw() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	model.setDrawMatrix(matrix);
	model.setScale(&scale);
	model.calcWorld(false);
	model.scheduleForDrawing();

	return true;
}


dActor_c *daEnFlipBlock_c::build() {

	void *buffer = AllocFromGameHeap1(sizeof(daEnFlipBlock_c));
	daEnFlipBlock_c *c = new(buffer) daEnFlipBlock_c;


	return c;
}


extern void beginState_Shoot(int param_1);

void daEnFlipBlock_c::blockWasHit(bool isDown) {
	pos.y = initialY;

	daPlBase_c  *player = 0;

	Vec myBL = {pos.x - 8.0f, pos.y - 8.0f, 0.0f};
	Vec myTR = {pos.x + 8.0f, pos.y + 8.0f, 0.0f};

	while ((player = (daPlBase_c *)fBase_c::search(PLAYER, player)) != 0) {
		float centerX = player->pos.x + player->aPhysics.info.xDistToCenter;
		float centerY = player->pos.y + player->aPhysics.info.yDistToCenter;

		float left = centerX - player->aPhysics.info.xDistToEdge;
		float right = centerX + player->aPhysics.info.xDistToEdge;

		float top = centerY + player->aPhysics.info.yDistToEdge;
		float bottom = centerY - player->aPhysics.info.yDistToEdge;

		Vec playerBL = {left, bottom + 0.1f, 0.0f};
		Vec playerTR = {right, top - 0.1f, 0.0f};


		if (RectanglesOverlap(&playerBL, &playerTR, &myBL, &myTR))
			bouncePlayer(player, 5.0f);
			beginState_Shoot(0);
	}

	doStateChange(&StateID_Flipping);
}



void daEnFlipBlock_c::calledWhenUpMoveExecutes() {
	if (initialY >= pos.y)
		blockWasHit(false);
}

void daEnFlipBlock_c::calledWhenDownMoveExecutes() {
	if (initialY <= pos.y)
		blockWasHit(true);
}



void daEnFlipBlock_c::beginState_Wait() {
}

void daEnFlipBlock_c::endState_Wait() {
}

void daEnFlipBlock_c::executeState_Wait() {
	int result = blockResult();

	if (result == 0)
		return;

	if (result == 1) {
		doStateChange(&daEnBlockMain_c::StateID_UpMove);
		anotherFlag = 2;
		isGroundPound = false;
	} else {
		doStateChange(&daEnBlockMain_c::StateID_DownMove);
		anotherFlag = 1;
		isGroundPound = true;
	}
}


void daEnFlipBlock_c::beginState_Flipping() {
	flipsRemaining = 7;
	physics.removeFromList();
}
void daEnFlipBlock_c::executeState_Flipping() {
	if (isGroundPound)
		rot.x += 0x800;
	else
		rot.x -= 0x800;

	if (rot.x == 0) {
		flipsRemaining--;
		if (flipsRemaining <= 0) {
			if (!playerOverlaps())
				doStateChange(&StateID_Wait);
		}
	}
}
void daEnFlipBlock_c::endState_Flipping() {
	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.addToList();
}



bool daEnFlipBlock_c::playerOverlaps() {
	dStageActor_c *player = 0;

	Vec myBL = {pos.x - 8.0f, pos.y - 8.0f, 0.0f};
	Vec myTR = {pos.x + 8.0f, pos.y + 8.0f, 0.0f};

	while ((player = (dStageActor_c*)fBase_c::search(PLAYER, player)) != 0) {
		float centerX = player->pos.x + player->aPhysics.info.xDistToCenter;
		float centerY = player->pos.y + player->aPhysics.info.yDistToCenter;

		float left = centerX - player->aPhysics.info.xDistToEdge;
		float right = centerX + player->aPhysics.info.xDistToEdge;

		float top = centerY + player->aPhysics.info.yDistToEdge;
		float bottom = centerY - player->aPhysics.info.yDistToEdge;

		Vec playerBL = {left, bottom + 0.1f, 0.0f};
		Vec playerTR = {right, top - 0.1f, 0.0f};

		if (RectanglesOverlap(&playerBL, &playerTR, &myBL, &myTR))
			return true;
	}

	return false;
}


//
// processed\../src/launchStar.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "baddy.h"

const char* LaunchStarFileList[] = { "launchStar", 0 };

void initStarArraysMidway() {
	for (int i = 0; i < 32; i++) {
		for (int j = 0; j < 5; j++) {
			launchStarChipCollectedAfterFlag[i][j] = false;
		}
		OSReport("Inner Array: %p\n", launchStarChipCollectedBeforeFlag[i]);
	}
}
void initStarArrays() {
	for (int i = 0; i < 32; i++) {
		for (int j = 0; j < 5; j++) {
			launchStarChipCollectedBeforeFlag[i][j] = false;
			launchStarChipCollectedAfterFlag[i][j] = false;
		}
		OSReport("Inner Array: %p\n", launchStarChipCollectedBeforeFlag[i]);
	}
}

class daEnLaunchStar_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile resFileAnim;
	m3d::mdl_c bodyModel;

	m3d::anmChr_c chrAnimation;
	 

	bool isSuperLaunchStar;
	bool active;
	bool isActivatedByEvent;

	int id;
	int starRotation;
	int distance;

	int destinationWorld;
	int destinationSubWorld;
	
	int speed;

	float timePlayer[4];

	int collected;

	/*int id;
	int collected;
	bool active;

	int destinationX;
	int destinationY;
	int multiplicator;*/

	dStageActor_c* actorsCurrentlyShooting[4];

	static dActor_c* build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);

	int type;
};

const SpriteData LaunchStarSpriteData = { ProfileId::LaunchStar, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile LaunchStarProfile(&daEnLaunchStar_c::build, SpriteId::LaunchStar, LaunchStarSpriteData, ProfileId::LaunchStar, ProfileId::LaunchStar, "LaunchStar", LaunchStarFileList);

u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnLaunchStar_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	OSReport("Collided LaunchStar\n");
	if (this->active)
	{
		OSReport("Is Active Launch Star\n");

		//OSReport("getsMoved: %d\n", apOther->owner->getsMoved)

		if (playerStatus[apOther->owner->which_player] != 0)
		{
			return;
		}

		for (int i = 0; i < 4; i++)
		{
			if (this->actorsCurrentlyShooting[i] == 0)
			{
				OSReport("Yes\n");
				this->actorsCurrentlyShooting[i] = apOther->owner;
				playerStatus[apOther->owner->which_player] = 1;

				//OSReport("getsMoved: %d\n", this->actorsCurrentlyShooting[i]->getsMoved);

				return;
			}
		}
	}
}
void daEnLaunchStar_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	//this->playerCollision(apThis, apOther);
}
bool daEnLaunchStar_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnLaunchStar_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnLaunchStar_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnLaunchStar_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnLaunchStar_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnLaunchStar_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnLaunchStar_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnLaunchStar_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnLaunchStar_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnLaunchStar_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daEnLaunchStar_c::build() 
{
	void* buffer = AllocFromGameHeap1(sizeof(daEnLaunchStar_c));
	daEnLaunchStar_c* c = new(buffer) daEnLaunchStar_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

void daEnLaunchStar_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) 
{
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daEnLaunchStar_c::onCreate() 
{
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("launchStar", "g3d/launchStar.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("LaunchStar");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);


	this->resFileAnim.data = getResource("launchStar", "g3d/launchStarAnim.brres");
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr("idle");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 15.0;
	HitMeBaby.yDistToEdge = 15.0;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0x8028E;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	this->disableEatIn();

	// Stuff I do understand
	this->scale = (Vec){ 0.2, 0.2, 0.2 };

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;

	this->pos.z = 4000;

	daEnLaunchStar_c::bindAnimChr_and_setUpdateRate("idle", 1, 0.0, 1.0);


	this->isSuperLaunchStar = this->settings >> 31 & 1;						//Bit 17 (0=false, 1=true)
	this->active = this->settings >> 30 & 1;								//Bit 18 (0=false, 1=true)
	this->isActivatedByEvent = this->settings >> 29 & 1;					//Bit 19 (0=false, 1=true)

	this->id = this->settings >> 24 & 0b11111;								//Bit 20-24 (2^5=32 possible launchstars)

	this->starRotation = this->settings >> 16 & 0xFF;						//Bit 25-32 (2^8=256 values)
	
	this->distance = this->settings >> 12 & 0xF;							//Bit 33-36 (2^4=16 values)

	if (this->isSuperLaunchStar) {
		this->destinationWorld = this->settings >> 8 & 0xF;					//Bit 37-40 (2^4=16 main worlds)
		this->destinationSubWorld = this->settings >> 4 & 0xF;				//Bit 41-44 (2^4=16 sub worlds)
	}
	else {
		this->speed = this->settings >> 4 & 0xFF;							//Bit 37-44 (2^8=256 different speed values)
	}

	this->speed *= 2;

	this->collected = 0;

	OSReport("ID: %d\n", this->id);

	OSReport("Eight Launch One: %d\n", GameMgrP->eight.checkpointEntranceID);
	
	


	/*this->id = this->settings >> 3 & 0b111111;
	this->collected = 0;
	this->multiplicator = 1;

	this->destinationX = this->settings >> 9 & 0b111111;
	this->destinationY = this->settings >> 15 & 0b111111;
	this->multiplicator += this->settings >> 21 & 0b11;
	this->active = this->settings >> 1 & 0b1;

	OSReport("Settings: %x\n", this->settings);
	OSReport("Active: %d\n", this->active);
	OSReport("ID: %d\n", this->id);
	OSReport("Destination x: %d\n", this->destinationX);
	OSReport("Destination y: %d\n", this->destinationY);
	OSReport("Multi: %d\n", this->multiplicator);

	this->destinationX *= this->multiplicator;
	this->destinationY *= this->multiplicator;

	OSReport("Destination x: %d\n", this->destinationX);
	OSReport("Destination y: %d\n", this->destinationY);
	
	/*OSReport("\n");
	OSReport("1: %d\n", this->settings >> 0 & 0b1);
	OSReport("2: %d\n", this->settings >> 1 & 0b1);
	OSReport("3: %d\n", this->settings >> 2 & 0b1);
	OSReport("4: %d\n", this->settings >> 3 & 0b1);
	OSReport("5: %d\n", this->settings >> 4 & 0b1);
	OSReport("6: %d\n", this->settings >> 5 & 0b1);
	OSReport("7: %d\n", this->settings >> 6 & 0b1);
	OSReport("8: %d\n", this->settings >> 7 & 0b1);
	OSReport("9: %d\n", this->settings >> 8 & 0b1);
	OSReport("10: %d\n", this->settings >> 9 & 0b1);
	OSReport("11: %d\n", this->settings >> 10 & 0b1);
	OSReport("12: %d\n", this->settings >> 11 & 0b1);
	OSReport("13: %d\n", this->settings >> 12 & 0b1);
	OSReport("14: %d\n", this->settings >> 13 & 0b1);
	OSReport("15: %d\n", this->settings >> 14 & 0b1);
	OSReport("16: %d\n", this->settings >> 15 & 0b1);
	OSReport("1: %d\n", this->settings >> 16 & 0b1);
	OSReport("2: %d\n", this->settings >> 17 & 0b1);
	OSReport("3: %d\n", this->settings >> 18 & 0b1);
	OSReport("4: %d\n", this->settings >> 19 & 0b1);
	OSReport("5: %d\n", this->settings >> 20 & 0b1);
	OSReport("6: %d\n", this->settings >> 21 & 0b1);
	OSReport("7: %d\n", this->settings >> 22 & 0b1);
	OSReport("8: %d\n", this->settings >> 23 & 0b1);
	OSReport("9: %d\n", this->settings >> 24 & 0b1);
	OSReport("10: %d\n", this->settings >> 25 & 0b1);
	OSReport("11: %d\n", this->settings >> 26 & 0b1);
	OSReport("12: %d\n", this->settings >> 27 & 0b1);
	OSReport("13: %d\n", this->settings >> 28 & 0b1);
	OSReport("14: %d\n", this->settings >> 29 & 0b1);
	OSReport("15: %d\n", this->settings >> 30 & 0b1);
	OSReport("16: %d\n", this->settings >> 31 & 0b1);
	OSReport("\n");

	OSReport("0-3: %d\n", this->settings >> 0 & 0b1111);
	OSReport("4-7: %d\n", this->settings >> 4 & 0b1111);*/

	//allLaunchStars[id] = this;

	//OSReport("%d\n", GetActivePlayerCount());

	this->onExecute();
	return true;
}


int daEnLaunchStar_c::onDelete() 
{
	return true;
}

int daEnLaunchStar_c::onDraw() 
{
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnLaunchStar_c::updateModelMatrices() 
{
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnLaunchStar_c::onExecute() 
{
	if (this->active){
		for (int i = 0; i < 4; i++){
			if (this->actorsCurrentlyShooting[i] != 0){
				//OSReport("getsMoved 3: %d\n", this->actorsCurrentlyShooting[i]->getsMoved);

				if ((this->actorsCurrentlyShooting[i]->collMgr.outputMaybe & (0x15 << 0)) || (this->actorsCurrentlyShooting[i]->collMgr.outputMaybe & (0x15 << 1)) || this->actorsCurrentlyShooting[i]->collMgr.isOnTopOfTile()) {     //if hit a wall
					this->actorsCurrentlyShooting[i]->speed.x = 0;
					this->actorsCurrentlyShooting[i]->speed.y = 0;
					this->actorsCurrentlyShooting[i]->rot.x = 0;
					playerStatus[this->actorsCurrentlyShooting[i]->which_player] = 0;
					this->actorsCurrentlyShooting[i] = 0;
					this->timePlayer[i] = 0;
				}
				else
				{
					if (this->starRotation <= 180)
					{
						//OSReport("X: %f\n", this->pos.x + (this->speed * this->t[i] * cos(((this->starRotation * 2) * M_PI) / 180)));
						//OSReport("Y: %f\n", this->pos.y + (this->speed * this->t[i] * sin(((this->starRotation * 2) * M_PI)) - (this->t[i] * this->t[i])));
						this->actorsCurrentlyShooting[i]->pos.x = this->pos.x + (this->speed * (this->timePlayer[i]/16) * cos(((this->starRotation * 2) * M_PI) / 180));
						//this->cannonBalls[i]->pos.x = this->pos.x;
						//this->cannonBalls[i]->pos.y = this->pos.y;
						//this->cannonBalls[i]->pos.y = this->pos.y + (this->cannonBalls[i]->pos.x * tan(((this->starRotation * 2) * M_PI) / 180)) - (2 / (2 * (this->speed * this->speed) * (cos(((this->starRotation * 2) * M_PI) / 180) * cos(((this->starRotation * 2) * M_PI) / 180))) * (this->cannonBalls[i]->pos.x * this->cannonBalls[i]->pos.x));

						this->actorsCurrentlyShooting[i]->pos.y = (this->pos.y + (this->speed * (this->timePlayer[i] / 16) * sin(((this->starRotation * 2) * M_PI) / 180) - ((this->timePlayer[i] / 16) * (this->timePlayer[i] / 16)))) - (this->actorsCurrentlyShooting[i]->speed.y + this->actorsCurrentlyShooting[i]->y_speed_inc);
						this->timePlayer[i] += 4;
					}
					else
					{
						//this->cannonBalls[i]->pos.x = this->pos.x - (this->speed * this->t[i] * cos(((this->starRotation * 2) * M_PI) / 180));
						//this->actorsCurrentlyShooting[i]->pos.x = this->pos.x;
						//this->cannonBalls[i]->pos.y = this->pos.y;
						//this->actorsCurrentlyShooting[i]->pos.y = this->pos.y + (this->speed * this->timePlayer[i] * sin(((this->starRotation * 2) * M_PI) / 180) - (this->timePlayer[i] * this->timePlayer[i]));
						//this->timePlayer[i] += 1;

						this->actorsCurrentlyShooting[i]->pos.x = -(this->pos.x + (this->speed * (this->timePlayer[i] / 8) * cos(((this->starRotation * 2) * M_PI) / 180)));
						this->actorsCurrentlyShooting[i]->pos.y = (this->pos.y + (this->speed * (this->timePlayer[i] / 8) * sin(((this->starRotation * 2) * M_PI) / 180) - ((this->timePlayer[i] / 8) * (this->timePlayer[i] / 8)))) - (this->actorsCurrentlyShooting[i]->speed.y + this->actorsCurrentlyShooting[i]->y_speed_inc);
						this->timePlayer[i] += 4;
					}

					/*daPlBase_c* player = (daPlBase_c*)this->actorsCurrentlyShooting[i];
					player->setFlag(0x7f);
					player->setFlag(0x11);
					player->setFlag(0xbd);
					player->setFlag(0x88);
					//player->setFlag(0x8e);
					//player->setFlag(0x7a);
					daPlBase_c::setPipeCannonCollisionCategory(player);
					*/
					//OSReport("%f | %f\n", this->cannonBalls[i]->pos.x, this->cannonBalls[i]->pos.y);
				}



				/*this->cannonBalls[i]->pos.x = this->cannonBalls[i]->last_pos.x + this->destinationX / 100 - this->cannonBalls[i]->speed.x; //(this->cannonBalls[i]->speed.x + this->cannonBalls[i]->x_speed_inc);
				this->cannonBalls[i]->pos.y = this->cannonBalls[i]->last_pos.y + this->destinationY / 100 - this->cannonBalls[i]->speed.y; //(this->cannonBalls[i]->speed.y + this->cannonBalls[i]->y_speed_inc);

				this->cannonBalls[i]->rot.x += 0x300;

				this->cannonBallsDone[i] += 1;

				if (this->cannonBallsDone[i] >= 100) {
					this->cannonBalls[i]->rot.x -= 768 * 100;
					this->cannonBalls[i] = 0;
					this->cannonBallsDone[i] = 0;
					playerInWork[this->cannonBalls[i]->which_player] = false;
				}*/
			}
		}

		this->scale = (Vec){ 0.2, 0.2, 0.2 };
		this->rot.y += 0.2;
		this->rot.x -= 0.3;
		this->rot.z += 0.4;
		bodyModel._vf1C();
		updateModelMatrices();

		/*if (this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}*/
		return true;
	}
	else
	{
		this->scale = (Vec){ 0, 0, 0 };

		OSReport("Collected %d\n", this->collected);
		OSReport("Eight Launch two: %d\n", GameMgrP->eight.checkpointEntranceID);
		OSReport("Collected After 1: %d\n", launchStarChipCollectedAfterFlag[this->id][0]);
		OSReport("Collected After 2: %d\n", launchStarChipCollectedAfterFlag[this->id][1]);
		OSReport("Collected After 3: %d\n", launchStarChipCollectedAfterFlag[this->id][2]);
		OSReport("Collected After 4: %d\n", launchStarChipCollectedAfterFlag[this->id][3]);
		OSReport("Collected After 5: %d\n", launchStarChipCollectedAfterFlag[this->id][4]);
		OSReport(" \n");
		OSReport("Collected Before 1: %d\n", launchStarChipCollectedBeforeFlag[this->id][0]);
		OSReport("Collected Before 2: %d\n", launchStarChipCollectedBeforeFlag[this->id][1]);
		OSReport("Collected Before 3: %d\n", launchStarChipCollectedBeforeFlag[this->id][2]);
		OSReport("Collected Before 4: %d\n", launchStarChipCollectedBeforeFlag[this->id][3]);
		OSReport("Collected Before 5: %d\n", launchStarChipCollectedBeforeFlag[this->id][4]);


		for (int i = 0; i < 5; i++) {
			if (launchStarChipCollectedAfterFlag[this->id][i] != true && launchStarChipCollectedBeforeFlag[this->id][i] != true) {
				return true;
			}
		}

		this->active = true;
		return true;
	}
}
//
// processed\../src/starChip.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include <actors.h>
#include "baddy.h"

const char* StarChipFileList[] = { "starChip", 0 };


class daEnStarChip_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;


	int id;
	int star_chip_id;

	bool type8fastJump;
	int type8timer;
	int type8timer2;

	bool collected;

	daEnLaunchStar_c* star;


	static dActor_c* build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);
};

const SpriteData StarChipSpriteData = { ProfileId::StarChip, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile StarChipProfile(&daEnStarChip_c::build, SpriteId::StarChip, StarChipSpriteData, ProfileId::StarChip, ProfileId::StarChip, "StarChip", StarChipFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnStarChip_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->type8fastJump = true;
}
void daEnStarChip_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	playerCollision(apThis, apOther);
}
bool daEnStarChip_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->type8fastJump = true;
	return false;
}
bool daEnStarChip_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->type8fastJump = true;
	return false;
}
bool daEnStarChip_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnStarChip_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnStarChip_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnStarChip_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnStarChip_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnStarChip_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnStarChip_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnStarChip_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daEnStarChip_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnStarChip_c));
	daEnStarChip_c* c = new(buffer) daEnStarChip_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

int daEnStarChip_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("starChip", "g3d/starChip.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("StarChip");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	// Stuff I do understand
	this->scale = (Vec){ 0.2, 0.2, 0.2 };

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;

	this->pos.z = 4000;

	this->star_chip_id = this->settings >> 29 & 0b111;
	this->id = this->settings >> 0 & 0b111111;

	OSReport("Star Chip ID: %d\n", this->id);

	star = (daEnLaunchStar_c*)FindActorByType(LaunchStar, 0);

	while (star != 0)
	{
		if (star->id == this->id)
		{
			break;
		}
		star = (daEnLaunchStar_c*)FindActorByType(LaunchStar, (Actor*)star);
	}

	/*for (int i = 0; i < 5; i++)
	{
		OSReport("launchstarchip: %d\n", launchStarChipCollected[this->id][i]);
		if (launchStarChipCollected[this->id][i] == 0);
		{
			this->star_chip_id = i;
			launchStarChipCollected[this->id][i] = 1;
			break;
		}
	}*/

	OSReport("StarCHIP ID: %d\n", this->star_chip_id);

	this->collected = false;

	OSReport("Eight Star Chip One: %d\n", GameMgrP->eight.checkpointEntranceID);

	if (GameMgrP->eight.checkpointEntranceID != 255) {
		if (launchStarChipCollectedBeforeFlag[this->id][this->star_chip_id]) {
			this->type8fastJump = true;
		}
	}

	if (this->star_chip_id == 0) {
		if (GameMgrP->eight.checkpointEntranceID != 255) {
			for (int j = 0; j < 5; j++) {
				launchStarChipCollectedAfterFlag[this->id][j] = false;
			}
		}
		else {
			for (int j = 0; j < 5; j++) {
				launchStarChipCollectedBeforeFlag[this->id][j] = false;
				launchStarChipCollectedAfterFlag[this->id][j] = false;
			}
		}
	}

	this->onExecute();
	return true;
}


int daEnStarChip_c::onDelete() {
	return true;
}

int daEnStarChip_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnStarChip_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnStarChip_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();
	if (this->star == 0) {
		star = (daEnLaunchStar_c*)FindActorByType(LaunchStar, 0);

		while (star != 0)
		{
			if (star->id == this->id)
			{
				break;
			}
			star = (daEnLaunchStar_c*)FindActorByType(LaunchStar, (Actor*)star);
		}
	}

	if (!this->type8fastJump) {
		this->rot.y += 0x300;
		if (this->collected)
		{
			this->Delete(1);
		}
	}
	else {
		this->rot.y += 0x2000;
		this->type8timer++;
		if (this->type8timer == 1) {
			this->removeMyActivePhysics();
		}
		if (this->type8timer < 6) {
			this->pos.y += 4;
			this->scale.x -= 0.05;
			this->scale.y -= 0.05;
			this->scale.z -= 0.05;
		}
		if (this->type8timer > 5 && this->type8timer < 11) {
			this->pos.y -= 4;
			this->scale.x -= 0.1;
			this->scale.y -= 0.1;
			this->scale.z -= 0.1;
		}
		if (this->type8timer == 11) {
			if (this->star != 0) {
				this->star->collected += 1;
			}

			OSReport("Eight Star Chip Two: %d\n", GameMgrP->eight.checkpointEntranceID);
			if (GameMgrP->eight.checkpointEntranceID == 255) {
				launchStarChipCollectedBeforeFlag[this->id][this->star_chip_id] = true;
			}
			else {
				if (launchStarChipCollectedBeforeFlag[this->id][this->star_chip_id] != true) {
					launchStarChipCollectedAfterFlag[this->id][this->star_chip_id] = true;
				}
			}

			this->collected = true;

			this->Delete(1);
		}
	}

	return true;
}
//
// processed\../src/leafPile.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

const char* LeafPileFileList[] = {"leafPile", 0};

class daEnLeafPile_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;
	m3d::anmClr_c clrAnimation;
	nw4r::g3d::ResAnmClr anmClr;
	
	int counter;

	int destroyType;

	static dActor_c* build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);

	int type;
};

const SpriteData LeafPileSpriteData = { ProfileId::LeafPile, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile LeafPileProfile(&daEnLeafPile_c::build, SpriteId::LeafPile, LeafPileSpriteData, ProfileId::LeafPile, ProfileId::LeafPile, "LeafPile", LeafPileFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnLeafPile_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 0;
	this->Delete(1);
}

void daEnLeafPile_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->playerCollision(apThis, apOther);
}

bool daEnLeafPile_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 0;
	this->Delete(1);
	return true;
}

bool daEnLeafPile_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 0;
	this->Delete(1);
	return true;
}

bool daEnLeafPile_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 0;
	this->Delete(1);
	return true;
}

bool daEnLeafPile_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 0;
	this->Delete(1);
	return true;
}

bool daEnLeafPile_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 1;
	this->Delete(1);
	return true;
}

bool daEnLeafPile_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 0;
	this->Delete(1);
	return true;
}

bool daEnLeafPile_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 0;
	this->Delete(1);
	return true;
}

bool daEnLeafPile_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 0;
	this->Delete(1);
	return true;
}

bool daEnLeafPile_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 1;
	this->Delete(1);
	return true;
}

bool daEnLeafPile_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->destroyType = 0;
	this->Delete(1);
	return true;
}


dActor_c* daEnLeafPile_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnLeafPile_c));
	daEnLeafPile_c* c = new(buffer) daEnLeafPile_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

int daEnLeafPile_c::onCreate() {
	this->type = this->settings >> 28 & 0xF;

	this->deleteForever = false;
	this->destroyType = 2;


	this->counter = 0;


	// Model creation
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("leafPile", "g3d/leafPile.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("karehayama");
	bodyModel.setup(mdl, &allocator, 0x128, 1, 0);
	//SetupTextures_Player(&bodyModel, 0);
	
	/*OSReport("1\n");
	anmClr = this->resFile.GetResAnmClr("karehayama");
	OSReport("2\n");
	this->clrAnimation.setup(mdl, anmClr, &this->allocator, 0, 1);
	OSReport("3\n");
	this->clrAnimation.bind(&this->bodyModel, &anmClr, 0, 1);
	OSReport("4\n");
	this->clrAnimation.setFrameForEntry(0.0f, 0);
	OSReport("5\n");
	this->clrAnimation.setUpdateRateForEntry(1.0f, 0);
	OSReport("6\n");
	this->bodyModel.bindAnim(&this->clrAnimation);
	OSReport("7\n");*/

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0x8028E;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	this->disableEatIn();

	// Stuff I do understand
	this->scale = (Vec){0.05f, 0.05f, 0.05f};

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;

	//this->pos.y -= 4;
	this->pos.z = 0;

	this->onExecute();
	return true;
}


int daEnLeafPile_c::onDelete() {
	S16Vec nullRot = {0,0,0};
	Vec efScale = {0.05f, 0.05f, 0.05f};
	Vec oneVec = {1.0f, 1.0f, 1.0f};
	nw4r::snd::SoundHandle handle;

	switch (this->destroyType) {
		case 0:
			SpawnEffect("rk_karehayama0", 0, &this->pos, &nullRot, &efScale);
			PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_PLY_FOOTNOTE_LEAF, 1);
			break;
		case 1:
			SpawnEffect("Wm_en_explosion", 0, &this->pos, &nullRot, &oneVec);
			PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_OBJ_PNGN_ICE_THAW, 1);
			break;
		default:
			break;
	}

	//dStageActorMgr_c::instance->_BCA = true;
	//WLClass::instance->demoControlAllPlayers();
	//BalloonRelatedClass::instance->_20 = 1;
	
	/*for (int i = 0; i < 4; i++) {
		daPlBase_c *player = GetPlayerOrYoshi(i);
		if (player) {
			//player->setFlag(0x71);
			player->setFlag(0x3);
			
			OSReport("\nSetFlag\n");
		}
	}*/

	Actors content = EN_ITEM;
	u32 set;
	switch(this->settings & 0b1111) {
		case 0:
			return true;
		case 1:
			break;
		case 2:
			set = 0x0B000000;
			break;
		case 3:
			set = 0x0B000009;
			break;
		case 4:
			set = 0x0B000015;
			break;
		case 5:
			set = 0x0B00000E;
			break;
		case 6:
			set = 0x0B000011;
			break;
		case 7:
			set = 0x0B000019;
			break;
		case 8:
			set = 0x0B000001;
			break;
		case 9:
			set = 0x0B000007;
			break;
		case 10:
			set = 0x0B000006;
			break;
		case 11:
			set = 0x0B000014;
			break;
		case 12:
			set = 0x0B000010;
			break;
		case 13:
			set = 0x0B00000F;
			break;
		case 14:
			set = 0x0B000013;
			break;
		case 15:
			set = 0x0B000016;
			break;
		case 16:
			set = 0x0B000012;
			break;
		case 17:
			content = PoisonShroom;
			//set = 0x008003cc04060000;
			break;
		/*case 148:
			set = 0x008003cc04060000;
			break;*/
		default:
			break;
	}

    //u32 set = 0x008003cc04060000;
	CreateActor(content, set, &pos, 0, this->currentLayerID);
	return true;
}
/*Flags:
0x3: disable jumping
0x71: sth. about demo mode
0x72: kill what the player holds (?)



*/




int daEnLeafPile_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnLeafPile_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y - 4, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnLeafPile_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();

	/*counter++;
	OSReport("counter: %d\n", counter);
	if(counter == 180) {
		this->clrAnimation.setUpdateRateForEntry(1.0f, 0);
		this->clrAnimation.setFrameForEntry(counter % 80, 0);
	}*/

	/*if(counter%15==0) {
		for (int i = 0; i < 4; i++) {
			daPlBase_c *player = GetPlayerOrYoshi(i);
			if (player) {
				//player->setFlag(0x71);
				player->clearFlag((counter/15)-1);
				player->setFlag(counter/15);
				
				OSReport("SetFlag%d\n", counter/15);
			}
		}
	}
	counter++;*/

	return true;
}
//
// processed\../src/magicplatform.cpp
//

#include <game.h>
#include <dCourse.h>

class daEnMagicPlatform_c : public dEn_c {
	public:
		static daEnMagicPlatform_c *build();

		int onCreate();
		int onExecute();
		int onDelete();

		enum CollisionType {
			Solid = 0,
			SolidOnTop = 1,
			None = 2,
			ThinLineRight = 3,
			ThinLineLeft = 4,
			ThinLineTop = 5,
			ThinLineBottom = 6,
			NoneWithZ500 = 7
		};

		// Settings
		CollisionType collisionType;
		u8 rectID, moveSpeed, moveDirection, moveLength;

		u8 moveDelay, currentMoveDelay;

		bool doesMoveInfinitely;

		float moveMin, moveMax, moveDelta, moveBaseDelta;
		float *moveTarget;

		bool isMoving;
		void setupMovement();
		void handleMovement();

		Physics physics;
		StandOnTopCollider sotCollider;

		TileRenderer *renderers;
		int rendererCount;

		void findSourceArea();
		void createTiles();
		void deleteTiles();
		void updateTilePositions();

		void checkVisibility();
		void setVisible(bool shown);

		bool isVisible;

		int srcX, srcY;
		int width, height;
};

/*****************************************************************************/
// Glue Code
daEnMagicPlatform_c *daEnMagicPlatform_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daEnMagicPlatform_c));
	daEnMagicPlatform_c *c = new(buffer) daEnMagicPlatform_c;
	return c;
}

extern "C" void HurtMarioBecauseOfBeingSquashed(void *mario, dStageActor_c *squasher, int type);

static void PhysCB1(daEnMagicPlatform_c *one, dStageActor_c *two) {
	if (two->stageActorType != 1)
		return;

	// if left/right
	if (one->moveDirection <= 1)
		return;

	if (one->pos_delta.y > 0.0f)
		HurtMarioBecauseOfBeingSquashed(two, one, 1);
	else
		HurtMarioBecauseOfBeingSquashed(two, one, 9);
}

static void PhysCB2(daEnMagicPlatform_c *one, dStageActor_c *two) {
	if (two->stageActorType != 1)
		return;

	// if left/right
	if (one->moveDirection <= 1)
		return;

	if (one->pos_delta.y < 0.0f)
		HurtMarioBecauseOfBeingSquashed(two, one, 2);
	else
		HurtMarioBecauseOfBeingSquashed(two, one, 10);
}

static void PhysCB3(daEnMagicPlatform_c *one, dStageActor_c *two, bool unkMaybeNotBool) {
	if (two->stageActorType != 1)
		return;

	// if up/down
	if (one->moveDirection > 1)
		return;

	if (unkMaybeNotBool) {
		if (one->pos_delta.x > 0.0f)
			HurtMarioBecauseOfBeingSquashed(two, one, 6);
		else
			HurtMarioBecauseOfBeingSquashed(two, one, 12);
	} else {
		if (one->pos_delta.x < 0.0f)
			HurtMarioBecauseOfBeingSquashed(two, one, 5);
		else
			HurtMarioBecauseOfBeingSquashed(two, one, 11);
	}
}

static bool PhysCB4(daEnMagicPlatform_c *one, dStageActor_c *two) {
	return (one->pos_delta.y > 0.0f);
}

static bool PhysCB5(daEnMagicPlatform_c *one, dStageActor_c *two) {
	return (one->pos_delta.y < 0.0f);
}

static bool PhysCB6(daEnMagicPlatform_c *one, dStageActor_c *two, bool unkMaybeNotBool) {
	if (unkMaybeNotBool) {
		if (one->pos_delta.x > 0.0f)
			return true;
	} else {
		if (one->pos_delta.x < 0.0f)
			return true;
	}
	return false;
}

int daEnMagicPlatform_c::onCreate() {
	rectID = settings & 0xFF;

	moveSpeed = (settings & 0xF00) >> 8;
	moveDirection = (settings & 0x3000) >> 12;
	moveLength = ((settings & 0xF0000) >> 16) + 1;

	moveDelay = ((settings & 0xF00000) >> 20) * 6;

	collisionType = (CollisionType)((settings & 0xF000000) >> 24);

	doesMoveInfinitely = (settings & 0x10000000);

	if (settings & 0xE0000000) {
		int putItBehind = settings >> 29;
		pos.z = -3600.0f - (putItBehind * 16);
	}
	if (collisionType == NoneWithZ500)
		pos.z = 500.0f;

	setupMovement();

	findSourceArea();
	createTiles();

	float fWidth = width * 16.0f;
	float fHeight = height * 16.0f;

	switch (collisionType) {
		case Solid:
			physics.setup(this,
					0.0f, 0.0f, fWidth, -fHeight,
					(void*)&PhysCB1, (void*)&PhysCB2, (void*)&PhysCB3, 1, 0, 0);

			physics.callback1 = (void*)&PhysCB4;
			physics.callback2 = (void*)&PhysCB5;
			physics.callback3 = (void*)&PhysCB6;

			physics.addToList();
			break;
		case SolidOnTop:
			sotCollider.init(this,
					/*xOffset=*/0.0f, /*yOffset=*/0.0f,
					/*topYOffset=*/0,
					/*rightSize=*/fWidth, /*leftSize=*/0,
					/*rotation=*/0, /*_45=*/1
					);

			// What is this for. I dunno
			sotCollider._47 = 0xA;
			sotCollider.flags = 0x80180 | 0xC00;

			sotCollider.addToList();

			break;
		case ThinLineLeft: case ThinLineRight:
		case ThinLineTop: case ThinLineBottom:
			physics.setup(this,
				fWidth * (collisionType == ThinLineRight ? 0.875f : 0.0f),
				fHeight * (collisionType == ThinLineBottom ? -0.75f : 0.0f),
				fWidth * (collisionType == ThinLineLeft ? 0.125f : 1.0f),
				fHeight * (collisionType == ThinLineTop ? -0.25f : -1.0f),
				(void*)&PhysCB1, (void*)&PhysCB2, (void*)&PhysCB3, 1, 0, 0);

			physics.callback1 = (void*)&PhysCB4;
			physics.callback2 = (void*)&PhysCB5;
			physics.callback3 = (void*)&PhysCB6;

			physics.addToList();
			break;
	}

	return 1;
}

int daEnMagicPlatform_c::onDelete() {
	deleteTiles();

	switch (collisionType) {
		case ThinLineLeft: case ThinLineRight:
		case ThinLineTop: case ThinLineBottom:
		case Solid: physics.removeFromList(); break;
	}

	return 1;
}

int daEnMagicPlatform_c::onExecute() {
	handleMovement();

	checkVisibility();

	updateTilePositions();

	switch (collisionType) {
		case ThinLineLeft: case ThinLineRight:
		case ThinLineTop: case ThinLineBottom:
		case Solid: physics.update(); break;
		case SolidOnTop: sotCollider.update(); break;
	}

	return 1;
}

/*****************************************************************************/
// Movement
void daEnMagicPlatform_c::setupMovement() {
	float fMoveLength = 16.0f * moveLength;
	float fMoveSpeed = 0.2f * moveSpeed;

	switch (moveDirection) {
		case 0: // RIGHT
			moveTarget = &pos.x;
			moveMin = pos.x;
			moveMax = pos.x + fMoveLength;
			moveBaseDelta = fMoveSpeed;
			break;
		case 1: // LEFT
			moveTarget = &pos.x;
			moveMin = pos.x - fMoveLength;
			moveMax = pos.x;
			moveBaseDelta = -fMoveSpeed;
			break;
		case 2: // UP
			moveTarget = &pos.y;
			moveMin = pos.y;
			moveMax = pos.y + fMoveLength;
			moveBaseDelta = fMoveSpeed;
			break;
		case 3: // DOWN
			moveTarget = &pos.y;
			moveMin = pos.y - fMoveLength;
			moveMax = pos.y;
			moveBaseDelta = -fMoveSpeed;
			break;
	}

	if (spriteFlagNum == 0) {
		isMoving = (moveSpeed > 0);
		moveDelta = moveBaseDelta;
	} else {
		isMoving = false;
	}

	currentMoveDelay = 0;
}

void daEnMagicPlatform_c::handleMovement() {
	if (spriteFlagNum > 0) {
		// Do event checks
		bool flagOn = ((dFlagMgr_c::instance->flags & spriteFlagMask) != 0);

		if (isMoving) {
			if (!flagOn) {
				// Flag was turned off while moving, so go back
				moveDelta = -moveBaseDelta;
			} else {
				moveDelta = moveBaseDelta;
			}
		} else {
			if (flagOn) {
				// Flag was turned on, so start moving
				moveDelta = moveBaseDelta;
				isMoving = true;
			}
		}
	}

	if (!isMoving)
		return;

	if (currentMoveDelay > 0) {
		currentMoveDelay--;
		return;
	}

	// Do it
	bool goesForward = (moveDelta > 0.0f);
	bool reachedEnd = false;

	*moveTarget += moveDelta;

	// if we're set to move infinitely, never stop
	if (doesMoveInfinitely)
		return;

	if (goesForward) {
		if (*moveTarget >= moveMax) {
			*moveTarget = moveMax;
			reachedEnd = true;
		}
	} else {
		if (*moveTarget <= moveMin) {
			*moveTarget = moveMin;
			reachedEnd = true;
		}
	}

	if (reachedEnd) {
		if (spriteFlagNum > 0) {
			// If event, just do nothing.. depending on what side we are on
			if ((moveDelta > 0.0f && moveBaseDelta > 0.0f) || (moveDelta < 0.0f && moveBaseDelta < 0.0f)) {
				// We reached the end, so keep isMoving on for when we need to reverse
			} else {
				// We're back at the start, so turn it off
				isMoving = false;
			}
		} else {
			// Otherwise, reverse
			moveDelta = -moveDelta;
			currentMoveDelay = moveDelay;
		}
	}
}

/*****************************************************************************/
// Tile Renderers

void daEnMagicPlatform_c::findSourceArea() {
	mRect rect;
	dCourseFull_c::instance->get(GetAreaNum())->getRectByID(rectID, &rect);

	// Round the positions down/up to get the rectangle
	int left = rect.x;
	int right = left + rect.width;
	int top = -rect.y;
	int bottom = top + rect.height;

	left &= 0xFFF0;
	right = (right + 15) & 0xFFF0;

	top &= 0xFFF0;
	bottom = (bottom + 15) & 0xFFF0;

	// Calculate the actual stuff
	srcX = left >> 4;
	srcY = top >> 4;
	width = (right - left) >> 4;
	height = (bottom - top) >> 4;

	//OSReport("Area: %f, %f ; %f x %f\n", rect.x, rect.y, rect.width, rect.height);
	//OSReport("Source: %d, %d ; Size: %d x %d\n", srcX, srcY, width, height);
}


void daEnMagicPlatform_c::createTiles() {
	rendererCount = width * height;
	renderers = new TileRenderer[rendererCount];

	// copy all the fuckers over
	int baseWorldX = srcX << 4, worldY = srcY << 4, rendererID = 0;

	for (int y = 0; y < height; y++) {
		int worldX = baseWorldX;

		for (int x = 0; x < width; x++) {
			u16 *pExistingTile = dBgGm_c::instance->getPointerToTile(worldX, worldY, 0);

			if (*pExistingTile > 0) {
				TileRenderer *r = &renderers[rendererID];
				r->tileNumber = *pExistingTile;
				r->z = pos.z;
			}

			worldX += 16;
			rendererID++;
		}

		worldY += 16;
	}

}

void daEnMagicPlatform_c::deleteTiles() {
	if (renderers != 0) {
		setVisible(false);

		delete[] renderers;
		renderers = 0;
	}
}

void daEnMagicPlatform_c::updateTilePositions() {
	float baseX = pos.x;

	float y = -pos.y;

	int rendererID = 0;

	for (int yIdx = 0; yIdx < height; yIdx++) {
		float x = baseX;

		for (int xIdx = 0; xIdx < width; xIdx++) {
			TileRenderer *r = &renderers[rendererID];
			r->x = x;
			r->y = y;

			x += 16.0f;
			rendererID++;
		}

		y += 16.0f;
	}
}



void daEnMagicPlatform_c::checkVisibility() {
	float effectiveLeft = pos.x, effectiveRight = pos.x + (width * 16.0f);
	float effectiveBottom = pos.y - (height * 16.0f), effectiveTop = pos.y;

	ClassWithCameraInfo *cwci = ClassWithCameraInfo::instance;

	float screenRight = cwci->screenLeft + cwci->screenWidth;
	float screenBottom = cwci->screenTop - cwci->screenHeight;

	bool isOut = (effectiveLeft > screenRight) ||
		(effectiveRight < cwci->screenLeft) ||
		(effectiveTop < screenBottom) ||
		(effectiveBottom > cwci->screenTop);

	setVisible(!isOut);
}

void daEnMagicPlatform_c::setVisible(bool shown) {
	if (isVisible == shown)
		return;
	isVisible = shown;

	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);

	for (int i = 0; i < rendererCount; i++) {
		if (renderers[i].tileNumber > 0) {
			if (shown) {
				list->add(&renderers[i]);
			} else {
				list->remove(&renderers[i]);
			}
		}
	}
}


//
// processed\../src/bonepiece.cpp
//

#include <game.h>
#include <profile.h>

const char* BonePieceNameList [] = {
	"lift_torokko",
	NULL
};

class daBonePiece_c : public dStageActor_c {
	public:
		static dActor_c  *build();

		int onCreate();
		int onExecute();
		int onDraw();
		int onDelete();

		StandOnTopCollider collider;

		nw4r::g3d::ResFile resFile;
		mHeapAllocator_c allocator;
		m3d::mdl_c model;
};

//0289 0000  00000000 00000000  00000000 00000000 00000100 00000100  0000 0000 0000 0000  0002 0000
const SpriteData BonePieceSpriteData = { ProfileId::BonePiece, 0, 0 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 2};
Profile BonePieceProfile(&daBonePiece_c::build, SpriteId::BonePiece, BonePieceSpriteData, ProfileId::WM_BOSS_IGGY, ProfileId::BonePiece, "BonePiece", BonePieceNameList);

// Glue Code
dActor_c  *daBonePiece_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daBonePiece_c));
	daBonePiece_c *c = new(buffer) daBonePiece_c;
	return c;
}

int daBonePiece_c::onCreate() {
	// Load the model
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	resFile.data = getResource(BonePieceNameList[0], "g3d/t00.brres");

	static char thing[] = "lift_torokko?";
	thing[0xC] = 'A' + (settings & 3);

	nw4r::g3d::ResMdl resmdl = resFile.GetResMdl(thing);
	model.setup(resmdl, &allocator, 0, 1, 0);
	SetupTextures_MapObj(&model, 0);

	allocator.unlink();

	// If rotation is off, do nothing else
	if ((settings >> 28) & 1) {
		// OK, figure out the rotation
		u8 sourceRotation = (settings >> 24) & 0xF;

		// 0 is up. -0x4000 is right, 0x4000 is left ...
		s16 rotation;

		// We'll flip it later.
		// Thus: 0..7 rotates left (in increments of 0x800),
		// 8..15 rotates right (in increments of 0x800 too).
		// To specify facing up, well.. just use 0.

		if (sourceRotation < 8)
			rotation = (sourceRotation * 0x800) - 0x4000;
		else
			rotation = (sourceRotation * 0x800) - 0x3800;

		rot.z = -rotation;
	}

	if ((settings >> 20) & 1)
		rot.y = 0x8000;
	
	float xOffs, yOffs;

	if (-0x2000 <= rot.z && rot.z <= 0x2000)
		xOffs = 8.0f * sin(rot.z) * cos(rot.z);
	else
		xOffs = 5.0f * sin(rot.z);

	if (rot.z < 0)
		yOffs = -xOffs;
	else
		yOffs = xOffs;

	collider.init(this, xOffs, yOffs, 0, 16.0f, -16.0f, rot.z, 1); // X Offset, Y Offset, Top Y Offset, Right Size, Left Size, Rotation, _45
	collider._47 = 0;
	collider.flags = 0x80180 | 0xC00;
	collider.addToList();

	return true;
}

int daBonePiece_c::onDelete() {
	return true;
}

int daBonePiece_c::onExecute() {
	matrix.translation(pos.x, pos.y - 8.0f, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	model.setDrawMatrix(matrix);
	model.setScale(&scale);
	model.calcWorld(false);

	collider.update();

	return true;
}

int daBonePiece_c::onDraw() {
	model.scheduleForDrawing();
	return true;
}

//
// processed\../src/music.cpp
//

#include <game.h>
#include <sfx.h>
#include "music.h"

struct HijackedStream {
	//const char *original;
	//const char *originalFast;
	u32 stringOffset;
	u32 stringOffsetFast;
	u32 infoOffset;
	u8 originalID;
	int streamID;
};

struct Hijacker {
	HijackedStream stream[2];
	u8 currentStream;
	u8 currentCustomTheme;
};



const char* SongNameList [] = {
	"new/AIRSHIP",
	"new/BOSS_TOWER",
	"new/MENU",
	"new/UNDERWATER",
	"new/ATHLETIC",
	"new/CASTLE",
	"new/MAIN",
	"new/MOUNTAIN",
	"new/TOWER",
	"new/UNDERGROUND",
	"new/DESERT",
	"new/FIRE",
	"new/FOREST",
	"new/FREEZEFLAME",
	"new/JAPAN",
	"new/PUMPKIN",
	"new/SEWER",
	"new/SPACE",
	"new/BOWSER",
	"new/BONUS",	
	"new/AMBUSH",	
	"new/BRIDGE_DRUMS",	
	"new/SNOW2",	
	"new/MINIMEGA",	
	"new/CLIFFS",
	"new/AUTUMN",
	"new/CRYSTALCAVES",
	"new/GHOST_HOUSE",
	"new/GRAVEYARD",
	"new/JUNGLE",
	"new/TROPICAL",
	"new/SKY_CITY",
	"new/SNOW",
	"new/STAR_HAVEN",
	"new/SINGALONG",
	"new/FACTORY",
	"new/TANK",
	"new/TRAIN",
	"new/YOSHIHOUSE",
	"new/FACTORYB",
	"new/CAVERN",
	"new/SAND",
	"new/SHYGUY",
	"new/MINIGAME",
	"new/BONUS_AREA",
	"new/CHALLENGE",
	"new/BOWSER_CASTLE",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"new/BOSS_CASTLE",
	"new/BOSS_AIRSHIP",
	NULL	
};



// Offsets are from the start of the INFO block, not the start of the brsar.
// INFO begins at 0x212C0, so that has to be subtracted from absolute offsets
// within the brsar.

#define _I(offs) ((offs)-0x212C0)

Hijacker Hijackers[2] = {
	{
		{
			{/*"athletic_lr.n.32.brstm", "athletic_fast_lr.n.32.brstm",*/ _I(0x4A8F8), _I(0x4A938), _I(0x476C4), 4, STRM_BGM_ATHLETIC},
			{/*"BGM_SIRO.32.brstm", "BGM_SIRO_fast.32.brstm",*/ _I(0x4B2E8), _I(0x4B320), _I(0x48164), 10, STRM_BGM_SHIRO}
		},
		0, 0
	},

	{
		{
			{/*"STRM_BGM_CHIJOU.brstm", "STRM_BGM_CHIJOU_FAST.brstm",*/ _I(0x4A83C), _I(0x4A8B4), 0, 1, STRM_BGM_CHIJOU},
			{/*"STRM_BGM_CHIKA.brstm", "STRM_BGM_CHIKA_FAST.brstm",*/ _I(0x4A878), _I(0x4A780), 0, 2, STRM_BGM_CHIKA},
		},
		0, 0
	}
};

extern void *SoundRelatedClass;
inline char *BrsarInfoOffset(u32 offset) {
	return (char*)(*(u32*)(((u32)SoundRelatedClass) + 0x5CC)) + offset;
}

void FixFilesize(u32 streamNameOffset);

u8 hijackMusicWithSongName(const char *songName, int themeID, bool hasFast, int channelCount, int trackCount, int *wantRealStreamID) {
	hijackMusicWithSongName(songName, themeID, hasFast, channelCount, trackCount, wantRealStreamID, false);
}

u8 hijackMusicWithSongName(const char *songName, int themeID, bool hasFast, int channelCount, int trackCount, int *wantRealStreamID, bool doTheResetThing) {
	Hijacker *hj = &Hijackers[channelCount==4?1:0];

	// do we already have this theme in this slot?
	// if so, don't switch streams
	// if we do, NSMBW will think it's a different song, and restart it ...
	// but if it's just an area transition where both areas are using the same
	// song, we don't want that
	if(!doTheResetThing) {
		if ((themeID >= 0) && hj->currentCustomTheme == themeID) {
			return hj->stream[hj->currentStream].originalID;
		}
	}

	// which one do we use this time...?
	int toUse = 0;//(hj->currentStream + 1) & 1;

	hj->currentStream = toUse;
	hj->currentCustomTheme = themeID;

	// write the stream's info
	HijackedStream *stream = &hj->stream[hj->currentStream];

	if (stream->infoOffset) {
		u16 *thing = (u16*)(BrsarInfoOffset(stream->infoOffset) + 4);
		OSReport("Modifying stream info, at offset %x which is at pointer %x\n", stream->infoOffset, thing);
		OSReport("It currently has: channel count %d, track bitfield 0x%x\n", thing[0], thing[1]);
		thing[0] = channelCount;
		thing[1] = (1 << trackCount) - 1;
		OSReport("It has been set to: channel count %d, track bitfield 0x%x\n", thing[0], thing[1]);
	}

	sprintf(BrsarInfoOffset(stream->stringOffset), "stream/%s.brstm", songName);
	sprintf(BrsarInfoOffset(stream->stringOffsetFast), hasFast?"stream/%s_F.brstm":"stream/%s.brstm", songName);

	// update filesizes
	FixFilesize(stream->stringOffset);
	FixFilesize(stream->stringOffsetFast);

	// done!
	if (wantRealStreamID)
		*wantRealStreamID = stream->streamID;

	return stream->originalID;
}


//oh for fuck's sake
#include "fileload.h"
//#include <rvl/dvd.h>

void FixFilesize(u32 streamNameOffset) {
	char *streamName = BrsarInfoOffset(streamNameOffset);

	char nameWithSound[80];
	snprintf(nameWithSound, 79, "/Sound/%s", streamName);

	s32 entryNum;
	DVDHandle info;
	
	if ((entryNum = DVDConvertPathToEntrynum(nameWithSound)) >= 0) {
		if (DVDFastOpen(entryNum, &info)) {
			u32 *lengthPtr = (u32*)(streamName - 0x1C);
			*lengthPtr = info.length;
		}
	} else
		OSReport("What, I couldn't find \"%s\" :(\n", nameWithSound);
}



extern "C" u8 after_course_getMusicForZone(u8 realThemeID) {
	if (realThemeID < 100)
		return realThemeID;

	bool usesDrums = (realThemeID >= 200);
	const char *name = SongNameList[realThemeID - (usesDrums ? 200 : 100)];
	return hijackMusicWithSongName(name, realThemeID, true, usesDrums?4:2, usesDrums?2:1, 0);
}



//
// processed\../src/animtiles.cpp
//

#include <common.h>
#include <game.h>
#include "fileload.h"

struct AnimDef_Header {
	u32 magic;
	u32 entryCount;
};

struct AnimDef_Entry {
	u16 texNameOffset;
	u16 frameDelayOffset;
	u16 tileNum;
	u8 tilesetNum;
	u8 reverse;
};

FileHandle fh;

void DoTiles(void* self) {
	AnimDef_Header *header;
	
	header = (AnimDef_Header*)LoadFile(&fh, "/NewerRes/AnimTiles.bin");
	
	if (!header) {
		OSReport("anim load fail\n");
		return;
	}
	
	if (header->magic != 'NWRa') {
		OSReport("anim info incorrect\n");
		FreeFile(&fh);
		return;
	}
	
	AnimDef_Entry *entries = (AnimDef_Entry*)(header+1);
	
	for (int i = 0; i < header->entryCount; i++) {
		AnimDef_Entry *entry = &entries[i];
		char *name = (char*)fh.filePtr+entry->texNameOffset;
		char *frameDelays = (char*)fh.filePtr+entry->frameDelayOffset;
		
		char realName[0x40];
		snprintf(realName, 0x40, "BG_tex/%s", name);
		
		void *blah = BgTexMng__LoadAnimTile(self, entry->tilesetNum, entry->tileNum, realName, frameDelays, entry->reverse);
	}
}


void DestroyTiles(void *self) {
	FreeFile(&fh);
}


extern "C" void CopyAnimTile(u8 *target, int tileNum, u8 *source, int frameNum) {
	int tileRow = tileNum >> 5; // divided by 32
	int tileColumn = tileNum & 31; // modulus by 32

	u8 *baseRow = target + (tileRow * 2 * 32 * 1024);
	u8 *baseTile = baseRow + (tileColumn * 32 * 4 * 2);

	u8 *sourceRow = source + (frameNum * 2 * 32 * 32);

	for (int i = 0; i < 8; i++) {
		memcpy(baseTile, sourceRow, 32*4*2);
		baseTile += (2 * 4 * 1024);
		sourceRow += (2 * 32 * 4);
	}
}

//
// processed\../src/fileload.cpp
//

#include "fileload.h"

extern "C" void UncompressBackward(void *bottom);


void *LoadFile(FileHandle *handle, const char *name) {

	int entryNum = DVDConvertPathToEntrynum(name);

	DVDHandle dvdhandle;
	if (!DVDFastOpen(entryNum, &dvdhandle)) {
		return 0;
	}

	handle->length = dvdhandle.length;
	handle->filePtr = EGG__Heap__alloc((handle->length+0x1F) & ~0x1F, 0x20, GetArchiveHeap());

	int ret = DVDReadPrio(&dvdhandle, handle->filePtr, (handle->length+0x1F) & ~0x1F, 0, 2);

	DVDClose(&dvdhandle);


	return handle->filePtr;
}

bool FreeFile(FileHandle *handle) {
	if (!handle) return false;

	if (handle->filePtr) {
		EGG__Heap__free(handle->filePtr, GetArchiveHeap());
	}

	handle->filePtr = 0;
	handle->length = 0;

	return true;
}




File::File() {
	m_loaded = false;
}

File::~File() {
	close();
}

bool File::open(const char *filename) {
	if (m_loaded)
		close();

	void *ret = LoadFile(&m_handle, filename);
	if (ret != 0)
		m_loaded = true;

	return (ret != 0);
}

/*bool File::openCompressed(const char *filename) {
	if (m_loaded)
		close();

	void *ret = LoadCompressedFile(&m_handle, filename);
	if (ret != 0)
		m_loaded = true;

	return (ret != 0);
}*/

void File::close() {
	if (!m_loaded)
		return;

	m_loaded = false;
	FreeFile(&m_handle);
}

bool File::isOpen() {
	return m_loaded;
}

void *File::ptr() {
	if (m_loaded)
		return m_handle.filePtr;
	else
		return 0;
}

u32 File::length() {
	if (m_loaded)
		return m_handle.length;
	else
		return 0xFFFFFFFF;
}


//
// processed\../src/levelspecial.cpp
//

#include <common.h>
#include <game.h>
#include <dCourse.h>

struct LevelSpecial {
	u32 id;			// 0x00
	u32 settings;	// 0x04
	u16 name;		// 0x08
	u8 _0A[6];		// 0x0A
	u8 _10[0x9C];	// 0x10
	float x;		// 0xAC
	float y;		// 0xB0
	float z;		// 0xB4
	u8 _B8[0x318];	// 0xB8
	// Any variables you add to the class go here; starting at offset 0x3D0
	u64 eventFlag;	// 0x3D0
	u8 type;		// 0x3D4
	u8 effect;		// 0x3D5
	u8 lastEvState;	// 0x3D6
	u8 func;		// 0x3D7
	u32 keepTime;
	u32 setTime;
};


extern u16 TimeStopFlag;
extern u32 AlwaysDrawFlag;
extern u32 AlwaysDrawBranch;

extern float MarioDescentRate;
extern float MarioJumpMax;
extern float MarioJumpArc;
extern float MiniMarioJumpArc;
// extern float MarioSize;

extern float GlobalSpriteSize;
extern float GlobalSpriteSpeed;
extern float GlobalRiderSize;
extern char SizerOn;
extern char ZOrderOn;
extern int GlobalStarsCollected;

extern VEC2 BGScaleFront;
extern VEC2 BGScaleBack;
extern char BGScaleEnabled;

extern u32 GameTimer;

#define time *(u32*)((GameTimer) + 0x4)


static const float GlobalSizeFloatModifications [] = {1, 0.25, 0.5, 0.75, 1.25, 1.5, 1.75, 2, 2.5, 3, 4, 5, 6, 7, 8, 10 };
static const float GlobalRiderFloatModifications [] = {1, 0.6, 0.7, 0.9, 1, 1, 1, 1.1, 1.25, 1.5, 2, 2.5, 3, 3.5, 4, 5};
static const float BGScaleChoices[] = {0.1f, 0.15f, 0.25f, 0.375f, 0.5f, 0.625f, 0.75f, 0.9f, 1.0f, 1.125f, 1.25f, 1.5f, 1.75f, 2.0f, 2.25f, 2.5f};

bool NoMichaelBuble = false;

void LevelSpecial_Update(LevelSpecial *self);
bool ResetAfterLevel();

#define ACTIVATE	1
#define DEACTIVATE	0

fBase_c *FindActorByID(u32 id);


extern "C" void dAcPy_vf294(void *Mario, dStateBase_c *state, u32 unk);
void MarioStateChanger(void *Mario, dStateBase_c *state, u32 unk) {
	//OSReport("State: %p, %s", state, state->getName());

	if ((strcmp(state->getName(), "dAcPy_c::StateID_Balloon") == 0) && (NoMichaelBuble)) { return; }

	dAcPy_vf294(Mario, state, unk);
}

bool ResetAfterLevel(bool didItWork) {
	// TimeStopFlag = 0;
	MarioDescentRate = MarioDescentRate < 0 ? -4 : 4;
	MarioJumpMax = 3.628;
	MarioJumpArc = 2.5;
	MiniMarioJumpArc = 2.5;
	// MarioSize = 1.0;
	GlobalSpriteSize = 1.0;
	GlobalSpriteSpeed = 1.0;
	GlobalRiderSize = 1.0;
	SizerOn = 0;
	AlwaysDrawFlag = 0x9421FFF0;
	AlwaysDrawBranch = 0x7C0802A6;
	ZOrderOn = 0;
	GlobalStarsCollected = 0;
	NoMichaelBuble = false;
	BGScaleEnabled = 0;
	return didItWork;
}

void FuckinBubbles() {
	dCourse_c *course = dCourseFull_c::instance->get(GetAreaNum());
	bool thing = false;

	int zone = GetZoneNum();
	for (int i = 0; i < course->zoneSpriteCount[zone]; i++) {
		dCourse_c::sprite_s *spr = &course->zoneFirstSprite[zone][i];
		if (spr->type == 246 && (spr->settings & 0xF) == 8)
			thing = true;
	}

	if (thing) {
		OSReport("DISABLING EXISTING BUBBLES.\n");
		for (int i = 0; i < 4; i++)
			Player_Flags[i] &= ~4;
	}
}

bool LevelSpecial_Create(LevelSpecial *self) {
	char eventNum	= (self->settings >> 24)	& 0xFF;
	self->eventFlag = (u64)1 << (eventNum - 1);
	
	self->keepTime  = 0;
	
	self->type		= (self->settings)			& 15;
	self->effect	= (self->settings >> 4)		& 15;
	self->setTime	= (self->settings >> 8)     & 0xFFFF;

	self->lastEvState = 0xFF;
	
	LevelSpecial_Update(self);
	
	return true;
}

bool LevelSpecial_Execute(LevelSpecial *self) {
	if (self->keepTime > 0) {
		time = self->keepTime; }

	LevelSpecial_Update(self);
	return true;
}


void LevelSpecial_Update(LevelSpecial *self) {
	
	u8 newEvState = 0;
	if (dFlagMgr_c::instance->flags & self->eventFlag)
		newEvState = 1;
	
	if (newEvState == self->lastEvState)
		return;
		
	
	u8 offState;
	if (newEvState == ACTIVATE)
	{
		offState = (newEvState == 1) ? 1 : 0;

		switch (self->type) {
			// case 1:											// Time Freeze
			// 	TimeStopFlag = self->effect * 0x100;
			// 	break;
				
			case 2:											// Stop Timer
				self->keepTime  = time;
				break;
		
	
			case 3:											// Mario Gravity
				MarioDescentRate = MarioDescentRate < 0 ? -2 : 2;
				MarioJumpArc = 0.5;
				MiniMarioJumpArc = 0.5;
				MarioJumpMax = 4.5;
				
				break;
	
			case 4:											// Set Time
				time = (self->setTime << 0xC) - 1; // Possibly - 0xFFF?
				break;


			case 5:											// Global Enemy Size
				SizerOn = 3;

				GlobalSpriteSize = GlobalSizeFloatModifications[self->effect];
				GlobalRiderSize = GlobalRiderFloatModifications[self->effect];
				GlobalSpriteSpeed = GlobalRiderFloatModifications[self->effect];

				AlwaysDrawFlag = 0x38600001;
				AlwaysDrawBranch = 0x4E800020;
				break;
	
			case 6:											// Individual Enemy Size
				AlwaysDrawFlag = 0x38600001;
				AlwaysDrawBranch = 0x4E800020;

				if (self->effect == 0)
				{	
					SizerOn = 1;							// Nyb 5
				}
				else
				{											
					SizerOn = 2;							// Nyb 7
				}
				break;
		
			case 7:											// Z Order Hack
				ZOrderOn = 1;
				break;

			case 8:
				NoMichaelBuble = true;
				break;

			case 9:
				BGScaleEnabled = true;
				BGScaleFront.x = BGScaleChoices[(self->settings >> 20) & 15];
				BGScaleFront.y = BGScaleChoices[(self->settings >> 16) & 15];
				BGScaleBack.x = BGScaleChoices[(self->settings >> 12) & 15];
				BGScaleBack.y = BGScaleChoices[(self->settings >> 8) & 15];
				break;

			default:
				break;
		}
	}
	
	else
	{
		offState = (newEvState == 1) ? 0 : 1;

		switch (self->type) {
			// case 1:											// Time Freeze
			// 	TimeStopFlag = 0;
			// 	break;
				
			case 2:											// Stop Timer
				self->keepTime  = 0;
				break;
		
	
			case 3:											// Mario Gravity
				MarioDescentRate = MarioDescentRate < 0 ? -4 : 4;
				MarioJumpArc = 2.5;
				MiniMarioJumpArc = 2.5;
				MarioJumpMax = 3.628;
				break;
	
			case 4:											// Mario Size
				break;
		
			case 5:											// Global Enemy Size
				SizerOn = 0;

				GlobalSpriteSize = 1.0;
				GlobalRiderSize = 1.0;
				GlobalSpriteSpeed = 1.0;

				AlwaysDrawFlag = 0x9421FFF0;
				AlwaysDrawBranch = 0x7C0802A6;
				break;

			case 6:											// Individual Enemy Size
				SizerOn = 0;

				AlwaysDrawFlag = 0x9421FFF0;
				AlwaysDrawBranch = 0x7C0802A6;
				break;
		
			case 7:											// Z Order Hack
				ZOrderOn = 0;
				break;
				
			case 8:
				NoMichaelBuble = false;
				break;

			case 9:
				BGScaleEnabled = false;
				break;
	
			default:
				break;
		}
	}




	
	
	self->lastEvState = newEvState;
}

#undef time
//
// processed\../src/mrsun.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>

#include "boss.h"

const char* MSarcNameList [] = {
	"mrsun",
	NULL	
};

class daMrSun_c : public dEn_c {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	m3d::mdl_c glowModel;

	bool hasGlow;

	float Baseline;
	float SwoopSlope;
	float SpiralLoop;
	float yThreshold;
	float yAccel;
	Vec	swoopTarget;
	u32 timer;
	float xSpiralOffset;
	float ySpiralOffset;
	float swoopA;
	float swoopB;
	float swoopC;
	float swoopSpeed;
	float glowPos;
	short spinReduceZ;
	short spinReduceY;
	float spinStateOn;
	int dying;
	char sunDying;
	char killFlag;

	u64 eventFlag;


	void dieFall_Execute();
	static daMrSun_c *build();

	void updateModelMatrices();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);

	USING_STATES(daMrSun_c);
	DECLARE_STATE(Follow);
	DECLARE_STATE(Swoop);
	DECLARE_STATE(Spiral);
	DECLARE_STATE(Spit);
	DECLARE_STATE(Spin);
	DECLARE_STATE(Wait);
};

daMrSun_c *daMrSun_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daMrSun_c));
	return new(buffer) daMrSun_c;
}


CREATE_STATE(daMrSun_c, Follow);
CREATE_STATE(daMrSun_c, Swoop);
CREATE_STATE(daMrSun_c, Spiral);
CREATE_STATE(daMrSun_c, Spit);
CREATE_STATE(daMrSun_c, Spin);
CREATE_STATE(daMrSun_c, Wait);

#define ACTIVATE	1
#define DEACTIVATE	0




void daMrSun_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {  DamagePlayer(this, apThis, apOther); }

bool daMrSun_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true;
}
bool daMrSun_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) { 
	
	if (this->settings == 1) {  // It's a moon
		if (apOther->owner->name == 0x76) { // BROS_ICEBALL
			return true; 
			}
	}
	return false;
}
bool daMrSun_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) { 
	this->timer = 0; 
	PlaySound(this, SE_EMY_DOWN);
	doStateChange(&StateID_DieFall);
	return true;
}
bool daMrSun_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) { 
	this->timer = 0;
	PlaySound(this, SE_EMY_DOWN);
	doStateChange(&StateID_DieFall);
	return true;
}
bool daMrSun_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther) { 
	this->timer = 0; 
	PlaySound(this, SE_EMY_DOWN);
	doStateChange(&StateID_DieFall);
	return true;
}
bool daMrSun_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}
bool daMrSun_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}
bool daMrSun_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}
bool daMrSun_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}
bool daMrSun_c::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}


void daMrSun_c::dieFall_Execute() {
	
	if (this->killFlag == 1) { return; }

	this->timer = this->timer + 1;
	 
	this->dying = this->dying + 0.15;
	
	this->pos.x = this->pos.x + 0.15;
	this->pos.y = this->pos.y - ((-0.2 * (this->dying*this->dying)) + 5);
	
	this->dEn_c::dieFall_Execute();
		
	if (this->timer > 450) {
		
		if ((this->settings >> 28) > 0) { 		
			this->kill();
			this->pos.y = this->pos.y + 800.0; 
			this->killFlag = 1;
			return;
		}
		
		dStageActor_c *Player = GetSpecificPlayerActor(0);
		if (Player == 0) { Player = GetSpecificPlayerActor(1); }
		if (Player == 0) { Player = GetSpecificPlayerActor(2); }
		if (Player == 0) { Player = GetSpecificPlayerActor(3); }
		
	
		if (Player == 0) { 
			this->pos.x = 0;
			doStateChange(&StateID_Follow); }
		else {
			Player->pos;
			this->pos.x = Player->pos.x - 300;
		}
				
		this->pos.y = this->Baseline; 
		
		this->aPhysics.addToList();
		doStateChange(&StateID_Follow);
	}
}


int daMrSun_c::onCreate() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	if ((this->settings & 0xF) == 0) { // It's a sun
		hasGlow = true;

		nw4r::g3d::ResFile rf(getResource("mrsun", "g3d/sun.brres"));
		bodyModel.setup(rf.GetResMdl("Sun"), &allocator, 0x224, 1, 0);
		SetupTextures_Map(&bodyModel, 0);

		glowModel.setup(rf.GetResMdl("SunGlow"), &allocator, 0x224, 1, 0);
		SetupTextures_Boss(&glowModel, 0);
	}
	
	else { // It's a moon
		hasGlow = false;

		nw4r::g3d::ResFile rf(getResource("mrsun", "g3d/moon.brres"));
		bodyModel.setup(rf.GetResMdl("Moon"), &allocator, 0x224, 1, 0);
		SetupTextures_Map(&bodyModel, 0);
	}
	
	allocator.unlink();

	this->scale = (Vec){0.5, 0.5, 0.5};


	ActivePhysics::Info HitMeBaby;
	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;
	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;

	if ((this->settings & 0xF) == 0) { // It's a sun
		HitMeBaby.bitfield2 = 0xffbafffc; 
		HitMeBaby.xDistToEdge = 24.0;
		HitMeBaby.yDistToEdge = 24.0;
	}	
	else { // It's a moon
		HitMeBaby.bitfield2 = 0xffbafffe; 
		HitMeBaby.xDistToEdge = 12.0;
		HitMeBaby.yDistToEdge = 12.0;
	}

	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;


	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	this->Baseline = this->pos.y;
	this->SwoopSlope = 0.0;
	this->SpiralLoop = 0;
	this->yThreshold = 15.0;
	this->yAccel = 0.2;
	this->timer = 0;
	this->xSpiralOffset = 0.0;
	this->ySpiralOffset = 0.0;
	this->dying = -5;
	this->sunDying = 0;
	this->killFlag = 0;
	
	if (this->settings == 1)
		this->pos.z = 6000.0f; // moon
	else
		this->pos.z = 5750.0f; // sun


	char eventNum	= (this->settings >> 16) & 0xFF;

	this->eventFlag = (u64)1 << (eventNum - 1);


	
	doStateChange(&StateID_Follow);

	// this->onExecute();
	return true;
}

int daMrSun_c::onDelete() {
	return true;
}

int daMrSun_c::onExecute() {
	acState.execute();
	updateModelMatrices();
		
	if (dFlagMgr_c::instance->flags & this->eventFlag) {
		if (this->killFlag == 0 && acState.getCurrentState()->isNotEqual(&StateID_DieFall)) {
			this->kill();
			this->pos.y = this->pos.y + 800.0; 
			this->killFlag = 1;
			doStateChange(&StateID_DieFall);
		}
	}
		
	return true;
}

int daMrSun_c::onDraw() {
	bodyModel.scheduleForDrawing();
	if (hasGlow)
		glowModel.scheduleForDrawing();

	return true;
}


void daMrSun_c::updateModelMatrices() {
	// This won't work with wrap because I'm lazy.
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);

	if (hasGlow) {
		mMtx glowMatrix;
		short rotY;
		
		glowPos += 0.01666666666666;
		if (glowPos > 1) { glowPos = 0; }
		
		rotY = (1000 * sin(glowPos * 3.14)) + 500;


		glowMatrix.translation(pos.x, pos.y, pos.z);
		glowMatrix.applyRotationX(&rot.x);
		glowMatrix.applyRotationY(&rotY);

		glowModel.setDrawMatrix(glowMatrix);
		glowModel.setScale(&scale);
		glowModel.calcWorld(false);
	}
}


// Follow State

void daMrSun_c::beginState_Follow() { 
	this->timer = 0;
	this->rot.x = 18000;
	this->rot.y = 0;
	this->rot.z = 0;
}
void daMrSun_c::executeState_Follow() { 

	if (this->timer > 200) { this->doStateChange(&StateID_Wait); }

	this->direction = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
	
	float speedDelta;
	if ((this->settings & 0xF) == 0) { speedDelta = 0.1; } // It's a sun
	else { speedDelta = 0.15; } // It's a moon


	if (this->direction == 0) {
		this->speed.x = this->speed.x + speedDelta;
		
		if (this->speed.x < 0) { this->speed.x = this->speed.x + (speedDelta / 2); }
		if (this->speed.x < 6.0) { this->speed.x = this->speed.x + (speedDelta); }
	}
	else {
		this->speed.x = this->speed.x - speedDelta;

		if (this->speed.x > 0) { this->speed.x = this->speed.x - (speedDelta / 2); }
		if (this->speed.x > 6.0) { this->speed.x = this->speed.x - (speedDelta); }
	}
	
	this->HandleXSpeed();
	
	
	float yDiff;
	yDiff = (this->Baseline - this->pos.y) / 8;
	this->speed.y = yDiff;
		
	this->HandleYSpeed();

	this->UpdateObjectPosBasedOnSpeedValuesReal();

	this->timer = this->timer + 1;
}
void daMrSun_c::endState_Follow() { 
	this->speed.y = 0;
}


// Swoop State

void daMrSun_c::beginState_Swoop() { 
	
	// Not enough space to swoop, spit instead.
	if (this->swoopTarget.y < (this->pos.y - 50)) { doStateChange(&StateID_Spit); }
	if (((this->pos.x - 96) < this->swoopTarget.x) && (this->swoopTarget.x < (this->pos.x + 96))) { doStateChange(&StateID_Spit); }

	if ((this->settings & 0xF) == 0) { 
		this->swoopTarget.y = this->swoopTarget.y - 16;
	} // It's a sun
	
	else { 
		this->swoopTarget.y = this->swoopTarget.y - 4;
	} // It's a moon	
	
	
	float x1, x2, x3, y1, y2, y3;

	x1 = this->pos.x - this->swoopTarget.x;
	x2 = 0;
	x3 = -x1;

	y1 = this->pos.y - this->swoopTarget.y;
	y2 = 0;
	y3 = y1;
	
	float denominator = (x1 - x2) * (x1 - x3) * (x2 - x3);
	this->swoopA      = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denominator;
	this->swoopB      = (x3*x3 * (y1 - y2) + x2*x2 * (y3 - y1) + x1*x1 * (y2 - y3)) / denominator;
	this->swoopC      = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / denominator;

	this->swoopSpeed = x3 * 2 / 75;
	
	
	PlaySound(this, 284);
	
}
void daMrSun_c::executeState_Swoop() { 

	// Everything is calculated up top, just need to modify it.

	this->pos.x = this->pos.x + this->swoopSpeed;

	this->pos.y = ( this->swoopA*(this->pos.x - this->swoopTarget.x)*(this->pos.x - this->swoopTarget.x) + this->swoopB*(this->pos.x - this->swoopTarget.x) + this->swoopC ) + this->swoopTarget.y;

	if (this->pos.y > this->Baseline) { doStateChange(&StateID_Follow); }

}
void daMrSun_c::endState_Swoop() { 
	this->speed.y = 0;
}



// Spiral State

void daMrSun_c::beginState_Spiral() { 

	this->SpiralLoop = 0;
	this->xSpiralOffset = this->pos.x;
	this->ySpiralOffset = this->pos.y;

	PlaySound(this, 284);
}
void daMrSun_c::executeState_Spiral() { 

	float Loops;
	float Magnitude;
	float Period;

	Loops = 6.0;
	Magnitude = 11.0;

	// Use a period of 0.1 for the moon
	if ((this->settings & 0xF) == 0) { Period = 0.1; } // It's a sun
	else { Period = 0.125; } // It's a moon	

	this->pos.x = this->xSpiralOffset + Magnitude*((this->SpiralLoop * cos(this->SpiralLoop)));
	this->pos.y = this->ySpiralOffset + Magnitude*((this->SpiralLoop * sin(this->SpiralLoop)));

	this->SpiralLoop = this->SpiralLoop + Period;

	if (this->SpiralLoop > (3.14 * Loops)) { doStateChange(&StateID_Follow); }

}
void daMrSun_c::endState_Spiral() { }



// Spit State

void daMrSun_c::beginState_Spit() { 

	this->timer = 0;
	this->spinStateOn = 1;

}
void daMrSun_c::executeState_Spit() { 
	
	if (this->timer == 10) {

		PlaySound(this, 431);
	
		this->direction = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
		
		float neg = -1.0;
		if (this->direction == 0) { neg = 1.0; }
		

		if ((this->settings & 0xF) == 0) { 
			dStageActor_c *spawner = CreateActor(106, 0, this->pos, 0, 0);
			spawner->speed.x = 6.0 * neg;
			spawner->speed.y = -2.5;
			spawner->pos.z = 5550.0;
			
			spawner = CreateActor(106, 0, this->pos, 0, 0);
			spawner->speed.x = 0.0 * neg;
			spawner->speed.y = -6.0;
			spawner->pos.z = 5550.0;
		
			spawner = CreateActor(106, 0, this->pos, 0, 0);
			spawner->speed.x = 3.5 * neg;
			spawner->speed.y = -6.0;
			spawner->pos.z = 5550.0;
		} // It's a sun
		
		
		else { 
			dStageActor_c *spawner = CreateActor(118, 0, this->pos, 0, 0);
			spawner->speed.x = 6.0 * neg;
			spawner->speed.y = -2.5;
			spawner->pos.z = 5550.0;
			*((u32 *) (((char *) spawner) + 0x3DC)) = this->id;
			
			spawner = CreateActor(118, 0, this->pos, 0, 0);
			spawner->speed.x = 0.0 * neg;
			spawner->speed.y = -6.0;
			spawner->pos.z = 5550.0;
			*((u32 *) (((char *) spawner) + 0x3DC)) = this->id;
		
			spawner = CreateActor(118, 0, this->pos, 0, 0);
			spawner->speed.x = 3.5 * neg;
			spawner->speed.y = -6.0;
			spawner->pos.z = 5550.0;
			*((u32 *) (((char *) spawner) + 0x3DC)) = this->id;
		} // It's a moon	

	}
	
	this->timer = this->timer + 1;

	if (this->timer > 30) { doStateChange(&StateID_Follow); }

}
void daMrSun_c::endState_Spit() { 
	this->spinStateOn = 0;
}



// Spin State

void daMrSun_c::beginState_Spin() { 
	this->spinReduceZ = 0;
	this->spinReduceY = 0;
}
void daMrSun_c::executeState_Spin() { 
	
	PlaySound(this, 282);

	this->direction = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
	
	if (this->direction == 0) {
		this->speed.x = this->speed.x + 0.2;

		if (this->speed.x < 0) { this->speed.x = this->speed.x + (0.2 / 2); }
		if (this->speed.x < 80.0) { this->speed.x = this->speed.x + (0.2 * 2); }
	}
	else {
		this->speed.x = this->speed.x - 0.2;

		if (this->speed.x > 0) { this->speed.x = this->speed.x - (0.2 / 2); }
		if (this->speed.x > 80.0) { this->speed.x = this->speed.x - (0.2 * 2); }
	}
	
	this->HandleXSpeed();
	this->UpdateObjectPosBasedOnSpeedValuesReal();

	this->timer = this->timer + 1;

	short rotBonus;
	if (this->timer < 60) { rotBonus = this->timer; }
	else { rotBonus = 120 - this->timer; }

	// 1-59 + 60-1 = 3542
		
//	if (this->timer > 100) { 
//		if (this->spinReduceZ = 0) { 
//			this->spinReduceZ = this->rot.z / 20; }
//		if (this->spinReduceY = 0) { 
//			this->spinReduceY = this->rot.y / 20; }
//			
//		this->rot.z = this->rot.z - this->spinReduceZ;
//		this->rot.y = this->rot.y - this->spinReduceY; }
//		
//	else {
		this->rot.z = this->rot.z + (55.1 * rotBonus);
		this->rot.y = this->rot.y + (18.4 * rotBonus); //}


	float spitspeed;
	if ((this->settings & 0xF) == 0) { spitspeed = 3.0; } // It's a sun
	else { spitspeed = 4.0;  } // It's a moon	

	int randomBall;
	randomBall = GenerateRandomNumber(8);
	if (randomBall == 1) {
		int direction;
		direction = GenerateRandomNumber(8);
		
		float xlaunch;
		float ylaunch;
		
		if (direction == 0) { 
			xlaunch = spitspeed;
			ylaunch = 0.0; }
		else if (direction == 1) { // SE
			xlaunch = spitspeed;
			ylaunch = spitspeed; }
		else if (direction == 2) { // S
			xlaunch = 0.0;
			ylaunch = spitspeed; }
		else if (direction == 3) { // SW
			xlaunch = -spitspeed;
			ylaunch = spitspeed; }
		else if (direction == 4) {	// W
			xlaunch = -spitspeed;
			ylaunch = 0.0; }
		else if (direction == 5) {	// NW
			xlaunch = -spitspeed;
			ylaunch = -spitspeed; }
		else if (direction == 6) {	// N
			xlaunch = 0.0;
			ylaunch = -spitspeed; }
		else if (direction == 7) {	// NE
			xlaunch = spitspeed;
			ylaunch = -spitspeed; }
		
		PlaySound(this, 431);

		if ((this->settings & 0xF) == 0) { 
			dStageActor_c *spawner = CreateActor(106, 0, this->pos, 0, 0);
			spawner->speed.x = xlaunch;
			spawner->speed.y = ylaunch;
			spawner->pos.z = 5550.0;
		} // It's a sun

		else { 
			dStageActor_c *spawner = CreateActor(118, 0, this->pos, 0, 0);
			spawner->speed.x = xlaunch;
			spawner->speed.y = ylaunch;
			spawner->pos.z = 5550.0;
			
			*((u32 *) (((char *) spawner) + 0x3DC)) = this->id;			
		} // It's a moon	
	}

	if (this->timer > 120) { this->doStateChange(&StateID_Follow); }
	
}
void daMrSun_c::endState_Spin() { 

	this->rot.x = 18000;
	this->rot.y = 0;
	this->rot.z = 0;

	this->speed.x = 0;
}



// Wait State

void daMrSun_c::beginState_Wait() {


	this->timer = 0;
	this->speed.x = 0.0;

	dStageActor_c *Player = GetSpecificPlayerActor(0);
	if (Player == 0) { Player = GetSpecificPlayerActor(1); }
	if (Player == 0) { Player = GetSpecificPlayerActor(2); }
	if (Player == 0) { Player = GetSpecificPlayerActor(3); }
	if (Player == 0) { doStateChange(&StateID_Follow); }
	
	this->swoopTarget = Player->pos;
}
void daMrSun_c::executeState_Wait() { 
	int Choice;
	int TimerMax;
	
	if ((this->settings & 0xF) == 0) { TimerMax = 60; } // It's a sun
	else { TimerMax = 30; } // It's a moon	
	
	if (this->timer > TimerMax) {

		Choice = GenerateRandomNumber(9);


		if (Choice == 0) { doStateChange(&StateID_Spit); }
		else if (Choice == 1) { doStateChange(&StateID_Spit); }
		else if (Choice == 2) { doStateChange(&StateID_Spin); }
		else if (Choice == 3) { doStateChange(&StateID_Spiral); }
		else { doStateChange(&StateID_Swoop); }
		
	}

	this->timer = this->timer + 1;
}
void daMrSun_c::endState_Wait() {
	this->timer = 0;
}



//
// processed\../src/boss.cpp
//

#include "boss.h"



void DamagePlayer(dEn_c *actor, ActivePhysics *apThis, ActivePhysics *apOther) {

	actor->dEn_c::playerCollision(apThis, apOther);
	actor->_vf220(apOther->owner);

	// fix multiple player collisions via megazig
	actor->deathInfo.isDead = 0;
	actor->flags_4FC |= (1<<(31-7));
	if (apOther->owner->which_player == 255 ) {
		actor->counter_504[0] = 0;
		actor->counter_504[1] = 0;
		actor->counter_504[2] = 0;
		actor->counter_504[3] = 0;
	}
	else {
		actor->counter_504[apOther->owner->which_player] = 0;
	}
}


void SetupKameck(daBoss *actor, daKameckDemo *Kameck) {

	// Stop the BGM Music
	StopBGMMusic();

	// Set the necessary Flags and make Mario enter Demo Mode
	dStage32C_c::instance->freezeMarioBossFlag = 1;
	WLClass::instance->_4 = 4;
	WLClass::instance->_8 = 0;

	MakeMarioEnterDemoMode();

	// Make sure to use the correct position
	Vec pos = (Vec){actor->pos.x - 124.0, actor->pos.y + 104.0, 3564.0};
	S16Vec rot = (S16Vec){0, 0, 0};

	// Create And use Kameck
	actor->Kameck = (daKameckDemo*)actor->createChild(KAMECK_FOR_CASTLE_DEMO, (dStageActor_c*)actor, 0, &pos, &rot, 0);
	actor->Kameck->doStateChange(&daKameckDemo::StateID_DemoWait);	

}


void CleanupKameck(daBoss *actor, daKameckDemo *Kameck) {
	// Clean up the flags and Kameck
	dStage32C_c::instance->freezeMarioBossFlag = 0;
	WLClass::instance->_8 = 1;

	MakeMarioExitDemoMode();
	StartBGMMusic();

	actor->Kameck->Delete(1);
}


bool GrowBoss(daBoss *actor, daKameckDemo *Kameck, float initialScale, float endScale, float yPosModifier, int timer) {
	if (timer == 130) { actor->Kameck->doStateChange(&daKameckDemo::StateID_DemoSt); }
	if (timer == 400) { actor->Kameck->doStateChange(&daKameckDemo::StateID_DemoSt2); }

	float scaleSpeed, yPosScaling;

	if (timer == 150) { PlaySound(actor, SE_BOSS_IGGY_WANWAN_TO_L);  }
	
	if ((timer > 150) && (timer < 230)) {
		scaleSpeed = (endScale -initialScale) / 80.0;
	
		float modifier;

		modifier = initialScale + ((timer - 150) * scaleSpeed);
		
		actor->scale = (Vec){modifier, modifier, modifier};
		actor->pos.y = actor->pos.y + (yPosModifier/80.0);
	}

	if (timer == 360) { 
		Vec tempPos = (Vec){actor->pos.x - 40.0, actor->pos.y + 120.0, 3564.0};
		SpawnEffect("Wm_ob_greencoinkira", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_mr_yoshiicehit_a", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_mr_yoshiicehit_b", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_ob_redringget", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_ob_keyget01", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_ob_greencoinkira_a", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_ob_keyget01_c", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
	}

	if (timer > 420) { return true; }
	return false;
}


void OutroSetup(daBoss *actor) {
	actor->removeMyActivePhysics();

	StopBGMMusic();

	WLClass::instance->_4 = 5;
	WLClass::instance->_8 = 0;
	dStage32C_c::instance->freezeMarioBossFlag = 1;

	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_BOSS_CMN_DAMAGE_LAST, 1);
}


bool ShrinkBoss(daBoss *actor, Vec *pos, float scale, int timer) {
	// Adjust actor to equal the scale of your boss / 80.
	actor->scale.x -= scale / 80.0;
	actor->scale.y -= scale / 80.0;
	actor->scale.z -= scale / 80.0;

	// actor->pos.y += 2.0;
	
	if (timer == 30) {  
		SpawnEffect("Wm_ob_starcoinget_gl", 0, pos, &(S16Vec){0,0,0}, &(Vec){2.0, 2.0, 2.0});
		SpawnEffect("Wm_mr_vshipattack_hosi", 0, pos, &(S16Vec){0,0,0}, &(Vec){2.0, 2.0, 2.0});
		SpawnEffect("Wm_ob_keyget01_b", 0, pos, &(S16Vec){0,0,0}, &(Vec){2.0, 2.0, 2.0});
	}

	if (actor->scale.x < 0) { return true; }
	else { return false; }
}


void BossExplode(daBoss *actor, Vec *pos) {
	actor->scale.x = 0.0;
	actor->scale.y = 0.0;
	actor->scale.z = 0.0;
	
	SpawnEffect("Wm_ob_keyget02", 0, pos, &(S16Vec){0,0,0}, &(Vec){2.0, 2.0, 2.0});
	actor->dying = 1;
	actor->timer = 0;

	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, STRM_BGM_SHIRO_BOSS_CLEAR, 1);

	//MakeMarioEnterDemoMode();
	BossGoalForAllPlayers();
}

void BossGoalForAllPlayers() {
	for (int i = 0; i < 4; i++) {
		daPlBase_c *player = GetPlayerOrYoshi(i);
		if (player)
			player->setAnimePlayStandardType(2);
	}
}


void PlayerVictoryCries(daBoss *actor) {
	UpdateGameMgr();
	/*nw4r::snd::SoundHandle handle1, handle2, handle3, handle4;

	dAcPy_c *players[4];
	for (int i = 0; i < 4; i++)
		players[i] = (dAcPy_c *)GetSpecificPlayerActor(i);

	if (players[0] && strcmp(players[0]->states2.getCurrentState()->getName(), "dAcPy_c::StateID_Balloon"))
		PlaySoundWithFunctionB4(SoundRelatedClass, &handle1, SE_VOC_MA_CLEAR_BOSS, 1);
	if (players[1] && strcmp(players[1]->states2.getCurrentState()->getName(), "dAcPy_c::StateID_Balloon"))
		PlaySoundWithFunctionB4(SoundRelatedClass, &handle2, SE_VOC_LU_CLEAR_BOSS, 1);
	if (players[2] && strcmp(players[2]->states2.getCurrentState()->getName(), "dAcPy_c::StateID_Balloon"))
		PlaySoundWithFunctionB4(SoundRelatedClass, &handle3, SE_VOC_KO_CLEAR_BOSS, 1);
	if (players[3] && strcmp(players[3]->states2.getCurrentState()->getName(), "dAcPy_c::StateID_Balloon"))
		PlaySoundWithFunctionB4(SoundRelatedClass, &handle4, SE_VOC_KO2_CLEAR_BOSS, 1);*/
}


void SetupBoss() {
    // Stop the BGM Music
    StopBGMMusic();

    // Set the necessary Flags and make Mario enter Demo Mode
    dStage32C_c::instance->freezeMarioBossFlag = 1;
    WLClass::instance->_4 = 4;
    WLClass::instance->_8 = 0;

    MakeMarioEnterDemoMode();
}


void CleanupBoss() {
    // Clean up the flags
    dStage32C_c::instance->freezeMarioBossFlag = 0;
    WLClass::instance->_8 = 1;

    MakeMarioExitDemoMode();
    StartBGMMusic();
}


bool GrowBossNoKameck(daBoss *actor, float initialScale, float endScale, float yPosModifier, int timer) {
	//if (timer == 130) { actor->Kameck->doStateChange(&daKameckDemo::StateID_DemoSt); }
	//if (timer == 400) { actor->Kameck->doStateChange(&daKameckDemo::StateID_DemoSt2); }

	float scaleSpeed, yPosScaling;

	if (timer == 30) { PlaySound(actor, SE_BOSS_IGGY_WANWAN_TO_L);  }
	
	if ((timer > 30) && (timer < 110)) {
		scaleSpeed = (endScale -initialScale) / 80.0;
	
		float modifier;

		modifier = initialScale + ((timer - 30) * scaleSpeed);
		
		actor->scale = (Vec){modifier, modifier, modifier};
		actor->pos.y = actor->pos.y + (yPosModifier/80.0);
	}
	/*
	if (timer == 360) { 
		Vec tempPos = (Vec){actor->pos.x - 40.0, actor->pos.y + 120.0, 3564.0};
		SpawnEffect("Wm_ob_greencoinkira", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_mr_yoshiicehit_a", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_mr_yoshiicehit_b", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_ob_redringget", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_ob_keyget01", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_ob_greencoinkira_a", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_ob_keyget01_c", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
	}
	*/
	if (timer > 200) { return true; }
	return false;
}


//
// processed\../src/firelaser.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>

class daFireLaser_c : public dEn_c {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	static daFireLaser_c *build();

	int timer;
	float spitspeed;
	char direction;
	u64 eventFlag;

	USING_STATES(daFireLaser_c);
	DECLARE_STATE(pewpewpew);
};

daFireLaser_c *daFireLaser_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daFireLaser_c));
	return new(buffer) daFireLaser_c;
}


CREATE_STATE(daFireLaser_c, pewpewpew);




int daFireLaser_c::onCreate() {

	this->timer = 0;
	this->direction = this->settings & 0xF;
	this->spitspeed = 8.0;
	
	char eventNum	= (this->settings >> 16) & 0xFF;
	this->eventFlag = (u64)1 << (eventNum - 1);

	
	doStateChange(&StateID_pewpewpew);
	this->onExecute();
	return true;
}

int daFireLaser_c::onDelete() {
	return true;
}

int daFireLaser_c::onExecute() {
	acState.execute();
	return true;
}

int daFireLaser_c::onDraw() {
	return true;
}



// Pew Pew State

void daFireLaser_c::beginState_pewpewpew() { 
	this->timer = 0;
}
void daFireLaser_c::executeState_pewpewpew() { 
	
	
	if (dFlagMgr_c::instance->flags & this->eventFlag) {
		
		this->timer = this->timer + 1;
	
		if (this->timer < 20) {
			float xlaunch;
			float ylaunch;
			
			if (this->direction == 0) { 
				xlaunch = this->spitspeed;
				ylaunch = 0.0; }
			else if (this->direction == 1) { // SE
				xlaunch = this->spitspeed;
				ylaunch = this->spitspeed; }
			else if (this->direction == 2) { // S
				xlaunch = 0.0;
				ylaunch = this->spitspeed; }
			else if (this->direction == 3) { // SW
				xlaunch = -this->spitspeed;
				ylaunch = this->spitspeed; }
			else if (this->direction == 4) {	// W
				xlaunch = -this->spitspeed;
				ylaunch = 0.0; }
			else if (this->direction == 5) {	// NW
				xlaunch = -this->spitspeed;
				ylaunch = -this->spitspeed; }
			else if (this->direction == 6) {	// N
				xlaunch = 0.0;
				ylaunch = -this->spitspeed; }
			else if (this->direction == 7) {	// NE
				xlaunch = this->spitspeed;
				ylaunch = -this->spitspeed; }
			
			
			dStageActor_c *spawner = CreateActor(106, 0, this->pos, 0, 0);
			spawner->speed.x = xlaunch;
			spawner->speed.y = ylaunch;
		}
		
		if (this->timer > 60) {
			this->timer = 0;
		}

	}
	
	else { this->timer = 0; }
	
}
void daFireLaser_c::endState_pewpewpew() { 

}














//
// processed\../src/boomeranghax.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include "boomeranghax.h"
#include "fileload.h"

int doWait = 0;
bool imDoneDoingVisibility;
u8 cloudSpawned[4];
int amIinCloud;
bool istherelightning = false;
int justspawnedit = 0;
bool isTargetSpawned = false;
int globalCoins;
int globalIceShoot;
int globalPropeller;

extern "C" float pow(float num, float power);
extern "C" int CheckExistingPowerup(void * Player);

int getNybbleValue(u32 settings, int fromNybble, int toNybble) {	 //Made that function because i wanted to, even if it's kinda useless. So shut up Meatball/CLF78
	int numberOfNybble = (toNybble  - fromNybble) + 1;               //gets how many nybbles are used for the process (example: nybbles 4-6 -> there's nybbles 4, 5 and 6 used -> numberOfNybble = 3) 
	int valueToUse = 48 - (4 * toNybble);                            //gets the value to use with the bitshift at the end 
	int fShit = pow(16, numberOfNybble) - 1;                         //gets the value to use with the "&" operator at the end 
	return ((settings >> valueToUse) & fShit);                       //uses everything to make the nybble value 
}


class daBoomerangHax_c : public dEn_c {
public:
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	/********/
	/*Global*/
	/********/
	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;

	m3d::mdl_c bodyModel;

	int alreadyOnTop;

	float XSpeed;
	bool canI;
	u32 cmgr_returnValue;
	bool isOnTopOfTile;
	int timer;
	int variation;

	/***********/
	/*Boomerang*/
	/***********/
	void playBoomerangSound();

	/******/
	/*Frog*/
	/******/
	m3d::anmChr_c animationChr;
	m3d::mdl_c coinModel;
	m3d::anmChr_c animationCoinChr;
	mMtx coinmatrix;
	VEC3 coinscale;
	S16Vec coinrot;
	S16Vec spikerot;
	bool doIhaveCoin;
	bool isCoinSpawned;

	/*******/
	/*Cloud*/
	/*******/
	StandOnTopCollider sotCollider;

	const char *brresName;
	daPlBase_c *player;
	pointSensor_s below;
	void dieFall_Begin();
	void dieFall_Execute();
	void dieFall_End();

	static daBoomerangHax_c *build();

	void updateModelMatrices();
	bool calculateTileCollisions();
	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate, bool isCoin);

	void spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	USING_STATES(daBoomerangHax_c);
	DECLARE_STATE(Boomerang_Thrown);
	DECLARE_STATE(Boomerang_GotBack);
	DECLARE_STATE(Spike_Walk);
	DECLARE_STATE(Spike_Die);
	DECLARE_STATE(Frog_Thrown);
	DECLARE_STATE(Cloud_Thrown);
};

daBoomerangHax_c *daBoomerangHax_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daBoomerangHax_c));
	return new(buffer) daBoomerangHax_c;
}

void daBoomerangHax_c::dieFall_Begin() {
}
void daBoomerangHax_c::dieFall_Execute() {
}
void daBoomerangHax_c::dieFall_End() {
}

///////////////////////
// States
///////////////////////


	CREATE_STATE(daBoomerangHax_c, Boomerang_Thrown);
	CREATE_STATE(daBoomerangHax_c, Boomerang_GotBack);
	CREATE_STATE(daBoomerangHax_c, Spike_Walk);
	CREATE_STATE(daBoomerangHax_c, Spike_Die);
	CREATE_STATE(daBoomerangHax_c, Frog_Thrown);
	CREATE_STATE(daBoomerangHax_c, Cloud_Thrown);


////////////////////////
// Collision Functions
////////////////////////


	void daBoomerangHax_c::spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		if(this->variation == 0) {
			u16 name = ((dEn_c*)apOther->owner)->name;
	
			if (name == EN_COIN || name == EN_EATCOIN || name == AC_BLOCK_COIN || name == EN_COIN_JUGEM || name == EN_COIN_ANGLE
				|| name == EN_COIN_JUMP || name == EN_COIN_FLOOR || name == EN_COIN_VOLT || name == EN_COIN_WIND
				|| name == EN_BLUE_COIN || name == EN_COIN_WATER || name == EN_REDCOIN || name == EN_GREENCOIN
				|| name == EN_JUMPDAI || name == EN_ITEM || name == EN_STAR_COIN || name == AC_WATER_BUBBLE_CANNON || name == AC_BLOCK_GROUP) //this list will probably be updated in the future if I find other sprites that unfortunatly don't have to die
				{ return; }
	
			dAcPy_c *player = dAcPy_c::findByID((this->settings >> 4) & 0xF);
			this->addScoreWhenHit(player);
	
			if(name == EN_KANITAMA) {
				((dEn_c*)apOther->owner)->collisionCat7_GroundPound(apThis, apOther);
				return;
			}
	
			dEn_c::spriteCollision(apThis, apOther);
			((dEn_c*)apOther->owner)->collisionCat13_Hammer(apThis, apOther);
		}
		if(this->variation == 1) {
			u16 name = ((dEn_c*)apOther->owner)->name;                                                                           //get the name of the actor the spikeball collided with

			if (name == EN_COIN || name == EN_EATCOIN || name == AC_BLOCK_COIN || name == EN_COIN_JUGEM || name == EN_COIN_ANGLE //list of actors ignored by the spikeball
				|| name == EN_COIN_JUMP || name == EN_COIN_FLOOR || name == EN_COIN_VOLT || name == EN_COIN_WIND
				|| name == EN_BLUE_COIN || name == EN_COIN_WATER || name == EN_REDCOIN || name == EN_GREENCOIN
				|| name == EN_JUMPDAI || name == EN_ITEM || name == EN_STAR_COIN)
				{ return; }


			dEn_c::spriteCollision(apThis, apOther);                                                                             //do as if it hit a sprite
			((dEn_c*)apOther->owner)->collisionCat13_Hammer(apThis, apOther);                                                    //do as if it was touched by a hammer
		}
		if(this->variation == 3) {
			if(!this->isCoinSpawned) {
				u16 name = ((dEn_c*)apOther->owner)->name;
			
				if (   name == EN_COIN			|| name == EN_EATCOIN		|| name == AC_BLOCK_COIN	|| name == EN_COIN_JUGEM		|| name == EN_COIN_ANGLE
					|| name == EN_COIN_JUMP		|| name == EN_COIN_FLOOR	|| name == EN_COIN_VOLT		|| name == EN_COIN_WIND			|| name == EN_UNIRA
					|| name == EN_BLUE_COIN		|| name == EN_COIN_WATER	|| name == EN_REDCOIN		|| name == EN_GREENCOIN			|| name == AC_BLOCK_GROUP
					|| name == EN_JUMPDAI		|| name == EN_ITEM			|| name == EN_STAR_COIN		|| name == AC_WATER_BUBBLE_CANNON
					|| name == EN_BOSS_LARRY	|| name == EN_BOSS_WENDY	|| name == EN_BOSS_IGGY		|| name == EN_BOSS_LEMMY
					|| name == EN_BOSS_MORTON	|| name == EN_BOSS_ROY		|| name == EN_BOSS_LUDWIG	|| name == EN_BOSS_KOOPA
					|| name == EN_IGAPUKU		|| name == EN_BAKUBAKU		|| name == EN_IBARAMUSHI	|| name == EN_BIG_TOGETEKKYU
					|| name == WM_PUKU			|| name == EN_RAIL_POLY_ICE) //this list will probably be updated in the future if I find other sprites that unfortunatly don't have to die
					{ return; }
			
				this->doIhaveCoin = true;
				((dEn_c*)apOther->owner)->Delete(1);
			}
		}
		if(this->variation == 4) {
			u16 ownername = ((dEn_c*)apOther->owner)->name;
			u32 ownersets = ((dEn_c*)apOther->owner)->settings;
			u8 ownerdir = ((dEn_c*)apOther->owner)->direction;
			float ownerspeed = getNybbleValue(ownersets, 9, 10) * 0.1f;
			// OSReport("ownername = %d\n", ownername);
			// OSReport("ownersets = %d\n", ownersets);
			// OSReport("ownerdir = %d\n", ownerdir);
			// OSReport("ownerspeed1 = %d\n", ownerspeed1);
			// OSReport("ownerspeed = %f\n", ownerspeed);
			if(ownername == BIGHANA_MGR) { //SMG2 Object
				if(((ownersets >> 28) & 0xF) == 0) { //Windmill
					if(ownerdir == 0) { //Faces right
						this->pos.x += ownerspeed;
					}
					if(ownerdir == 1) { //Faces left
						this->pos.x -= ownerspeed;
					}
				}
			}

			//Added by LiQ for CloudPropeller
			else if (ownername == CloudPropeller) { return; }

			else
			{
				this->Delete(1);
			}
		}
	}

	void daBoomerangHax_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		if(this->variation == 0) {
			if(apOther->owner == dAcPy_c::findByID((this->settings >> 4) & 0xF)) {
				if(canI) {
					doStateChange(&StateID_Boomerang_GotBack);
				}
			}
		}
		if(this->variation == 3) {
			if(this->doIhaveCoin) {
				int pid = getNybbleValue(apOther->owner->which_player, 6, 6);
				int coinsettings = 0 | (0x2 << 0) | (2 << 18) | (4 << 9) | (2 << 10) | ((pid + 8) << 16);
				VEC3 newPos = {this->pos.x, this->pos.y - 16, this->pos.z};
				dStageActor_c *coin = dStageActor_c::create(EN_ITEM, coinsettings, &newPos, 0, 0);
				PlaySound(this, SE_OBJ_GET_COIN);
				PlaySound(this, SE_OBJ_CMN_BALLOON_BREAK);
				Vec efPos = {this->pos.x, this->pos.y, this->pos.z};
				S16Vec nullRot = {0,0,0};
				Vec oneVec = {1.0f, 1.0f, 1.0f};
				SpawnEffect("Wm_mr_balloonburst", 0, &efPos, &nullRot, &oneVec);
				this->Delete(1);
			}
		}
		if (this->variation == 4)
		{
			daPlBase_c* player = (daPlBase_c*)apOther->owner;

			if (CheckExistingPowerup(player) != 12 && CheckExistingPowerup(player) != 3)
			{
				this->Delete(1);
			}
		}
	}

	void daBoomerangHax_c::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		if(this->variation == 0) {
			if(apOther->owner == dAcPy_c::findByID((this->settings >> 4) & 0xF)) {
				if(canI) {
					doStateChange(&StateID_Boomerang_GotBack);
				}
			}
		}
		if(this->variation == 3) {
			this->playerCollision(apThis, apOther);
		}
		if (this->variation == 4)
		{
			daPlBase_c* player = (daPlBase_c*)apOther->owner;

			if (CheckExistingPowerup(player) != 12 && CheckExistingPowerup(player) != 3)
			{
				this->Delete(1);
			}
		}
	}

	bool daBoomerangHax_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
		if(this->variation == 0) {
			return false;
		}
		if(this->variation == 1) {
			doStateChange(&StateID_Spike_Die);
			return true;
		}
		if(this->variation == 3 || this->variation == 4) {
			return false;
		}
		return true;
	}

	bool daBoomerangHax_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
		if(this->variation == 0) {
			if(apOther->owner == dAcPy_c::findByID((this->settings >> 4) & 0xF)) {
				if(canI) {
					doStateChange(&StateID_Boomerang_GotBack);
				}
			}
			return false;
		}
		if(this->variation == 1 || this->variation == 3) {
			return false;
		}
		if(this->variation == 4) {
			this->Delete(1);
			return false;
		}
		return true;
	}

	bool daBoomerangHax_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
		if(this->variation == 0) {
			if(apOther->owner == dAcPy_c::findByID((this->settings >> 4) & 0xF)) {
				if(canI) {
					doStateChange(&StateID_Boomerang_GotBack);
				}
			}
			return false;
		}
		if(this->variation == 1 || this->variation == 3) {
			return false;
		}
		if(this->variation == 4) {
			this->Delete(1);
			return false;
		}
		return true;
	}

	bool daBoomerangHax_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
		if(this->variation == 0) {
			return false;
		}
		if(this->variation == 1) {
			doStateChange(&StateID_Spike_Die);
			return true;
		}
		if(this->variation == 3 || this->variation == 4) {
			return false;
		}
		return true;
	}

	bool daBoomerangHax_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){
		if(this->variation == 0) {
			if(apOther->owner == dAcPy_c::findByID((this->settings >> 4) & 0xF)) {
				if(canI) {
					doStateChange(&StateID_Boomerang_GotBack);
				}
			}
			return false;
		}
		if(this->variation == 1 || this->variation == 3 || this->variation == 4) {
			return false;
		}
		return true;
	}

	bool daBoomerangHax_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
		return false;
	}

	bool daBoomerangHax_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){
		if(this->variation == 0) {
			if(apOther->owner == dAcPy_c::findByID((this->settings >> 4) & 0xF)) {
				if(canI) {
					doStateChange(&StateID_Boomerang_GotBack);
				}
			}
			return false;
		}
		if(this->variation == 1 || this->variation == 3 || this->variation == 4) {
			return false;
		}
		return true;
	}

	bool daBoomerangHax_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){
		return false;
	}

	bool daBoomerangHax_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
		return false;
	}
	
	bool daBoomerangHax_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) { 
		return false;
	}

void daBoomerangHax_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate, bool isCoin) {
	if(!isCoin) {
		nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
		this->animationChr.bind(&this->bodyModel, anmChr, unk);
		this->bodyModel.bindAnim(&this->animationChr, unk2);
		this->animationChr.setUpdateRate(rate);
	}
	else {
		nw4r::g3d::ResAnmChr anmCoinChr = this->resFile.GetResAnmChr(name);
		this->animationCoinChr.bind(&this->coinModel, anmCoinChr, unk);
		this->coinModel.bindAnim(&this->animationCoinChr, unk2);
		this->animationCoinChr.setUpdateRate(rate);
	}
}

int daBoomerangHax_c::onCreate() {
	this->alreadyOnTop = 0;
	this->canI = false;
	this->variation = (this->settings >> 12) & 0xF;
	OSReport("daBoomerangHax_c::onCreate()!!!\n");
	if(this->variation == 0) { //Boomerang
		this->deleteForever = true;

		// Model creation	
		allocator.link(-1, GameHeaps[0], 0, 0x20);

		this->resFile.data = getResource("boomerangM", "g3d/boomerang.brres");
		nw4r::g3d::ResMdl mdl;
		int pid = (this->settings >> 4) & 0xF;
		if(pid == 0) {
			mdl = this->resFile.GetResMdl("bros_boomerang_m");
		}
		if(pid == 1) {
			mdl = this->resFile.GetResMdl("bros_boomerang_l");
		}
		if(pid == 2) {
			mdl = this->resFile.GetResMdl("bros_boomerang_ky");
		}
		if(pid == 3) {
			mdl = this->resFile.GetResMdl("bros_boomerang_kb");
		}
		bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
		SetupTextures_Enemy(&bodyModel, 0);

		allocator.unlink();

		// Stuff I do understand
		this->scale = (Vec){0.85, 0.85, 0.85};

		this->rot.x = 0;
		this->rot.y = 0;
		this->rot.z = 0;
		this->direction = (this->settings >> 8) & 0xF; // Heading where the player look.

		ActivePhysics::Info HitMeBaby;

		HitMeBaby.xDistToCenter = 0.0;
		HitMeBaby.yDistToCenter = 0.0;

		HitMeBaby.xDistToEdge = 6.375;
		HitMeBaby.yDistToEdge = 6.375;		

		HitMeBaby.category1 = 0x3;
		HitMeBaby.category2 = 0x0;
		HitMeBaby.bitfield1 = 0x6F;
		HitMeBaby.bitfield2 = 0xffbafffe;
		HitMeBaby.unkShort1C = 0;
		HitMeBaby.callback = &dEn_c::collisionCallback;

		this->aPhysics.initWithStruct(this, &HitMeBaby);
		this->aPhysics.addToList();


		this->pos.y += 16;
		this->pos.z = 4000;


		doStateChange(&StateID_Boomerang_Thrown); 

		this->onExecute();
		return true;
	}
	if(this->variation == 1) { //Spikeball
		this->deleteForever = true;                                         //FOREVAAAAAAAAH

		/****************/
		/*Model Creation*/
		/****************/

		allocator.link(-1, GameHeaps[0], 0, 0x20);                          //allocator linking

		this->resFile.data = getResource("spikeM", "g3d/iron_ball.brres");  //get the brres in the arc file
		nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("iron_ball");       //get the mdl0
		bodyModel.setup(mdl, &allocator, 0x224, 1, 0);                      //setup it
		SetupTextures_MapObj(&bodyModel, 0);                                //setup shaders
		OSReport("IRON BALL!!!");


		allocator.unlink();                                                 //allocator unlinking

		/****************/
		/*Values Setting*/
		/****************/

		this->scale = (Vec){0.7, 0.7, 0.7};                                 //scale setting

		this->rot.x = 0;                                                    //X rotation setting
		this->rot.y = 0;                                                    //Y rotation setting
		this->rot.z = 0;                                                    //Z rotation setting
		this->direction = (this->settings >> 8) & 0xF;                      //heading where the player look.
		
		this->speed.x = 0.0;                                                //X speed setting
		this->speed.y = 3.0;                                                //Y speed setting
		this->max_speed.x = 0.0;                                            //X maximum speed setting
		this->x_speed_inc = 0.0;                                            //X speed incrementation setting
		this->XSpeed = 3.0;                                                 //XSpeed value (used later) setting

		/********************/
		/*Collision Creating*/
		/********************/

		ActivePhysics::Info HitMeBaby;                                      //ActivePhysics::Info creating

		HitMeBaby.xDistToCenter = 0.0;                                      //no X distance to center duh
		HitMeBaby.yDistToCenter = 0.0;                                      //no Y distance to center duh

		HitMeBaby.xDistToEdge = 7.5;                                        //1 block wide
		HitMeBaby.yDistToEdge = 7.5;                                        //1 block high		

		HitMeBaby.category1 = 0x3;                                          //idk what is this, ask treeki
		HitMeBaby.category2 = 0x0;                                          //^
		HitMeBaby.bitfield1 = 0x6F;                                         //^
		HitMeBaby.bitfield2 = 0xffbafffe;                                   //^
		HitMeBaby.unkShort1C = 0;                                           //^
		HitMeBaby.callback = &dEn_c::collisionCallback;                     //collision callback

		this->aPhysics.initWithStruct(this, &HitMeBaby);                    //initating the collision
		this->aPhysics.addToList();                                         //add to the collision list

		/********************/
		/*Colliders Creating*/
		/********************/

		// These fucking rects do something for the tile rect
		spriteSomeRectX = 28.0f;
		spriteSomeRectY = 32.0f;
		_320 = 0.0f;
		_324 = 16.0f;

		static const lineSensor_s below(-5<<12, 5<<12, -9<<12);            //Below collider:    unk, unk, y pos 
		static const pointSensor_s above(0<<12, 12<<12);                   //Above collider:    unk, unk, unk
		static const lineSensor_s adjacent(3<<12, 6<<12, 6<<12);           //Adjacent collider: unk, unk, unk

		collMgr.init(this, &below, &above, &adjacent);                     //initating colliders
		collMgr.calculateBelowCollisionWithSmokeEffect();                  //dude, the description of this line IS in the line, so what are you reading ?

		cmgr_returnValue = collMgr.isOnTopOfTile();                        //get if the sprite is in top of a tile (GOD DAMMIT IT IS WROTE)

		if (collMgr.isOnTopOfTile())                                       //just... read !
			isOnTopOfTile = false;
		else
			isOnTopOfTile = true;

		this->pos.y += 16;                                                 //because the game


		doStateChange(&StateID_Spike_Walk);                                //switch to the walk state (even if it's not really walking but shut up)

		this->onExecute();
		return true;
	}
	if(this->variation == 3) { //Bubble
		this->deleteForever = true;

		// Model creation	
		allocator.link(-1, GameHeaps[0], 0, 0x20);

		this->resFile.data = getResource("frogM", "g3d/balloon.brres");
		nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("balloon");
		bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
		SetupTextures_Enemy(&bodyModel, 0);

		nw4r::g3d::ResMdl coinmdl = this->resFile.GetResMdl("obj_coin");
		coinModel.setup(coinmdl, &allocator, 0x224, 1, 0);
		SetupTextures_MapObj(&coinModel, 0);

		bool ret;
		nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("float");
		ret = this->animationChr.setup(mdl, anmChr, &this->allocator, 0);

		bool rett;
		nw4r::g3d::ResAnmChr anmCoinChr = this->resFile.GetResAnmChr("no");
		rett = this->animationCoinChr.setup(coinmdl, anmCoinChr, &this->allocator, 0);

		allocator.unlink();

		// Stuff I do understand
		this->scale = (Vec){0.6, 0.6, 0.6};
		this->coinscale = (Vec){1.0, 1.0, 1.0};

		this->rot.x = 0;
		this->rot.y = 0;
		this->rot.z = 0;
		this->direction = (this->settings >> 8) & 0xF; // Heading where the player look.
		this->speed.x = (this->direction == 1) ? -5 : 5;
		this->x_speed_inc = 0.1;

		ActivePhysics::Info HitMeBaby;

		HitMeBaby.xDistToCenter = 0.0;
		HitMeBaby.yDistToCenter = 0.0;

		HitMeBaby.xDistToEdge = 7.5;
		HitMeBaby.yDistToEdge = 7.5;		

		HitMeBaby.category1 = 0x3;
		HitMeBaby.category2 = 0x0;
		HitMeBaby.bitfield1 = 0x4F;
		HitMeBaby.bitfield2 = 0x8028E;
		HitMeBaby.unkShort1C = 0;
		HitMeBaby.callback = &dEn_c::collisionCallback;

		this->aPhysics.initWithStruct(this, &HitMeBaby);
		this->aPhysics.addToList();


		// this->pos.y += 16;
		// this->pos.z = 9000;

		bindAnimChr_and_setUpdateRate("float", 1, 0.0, 1.0, false);
		bindAnimChr_and_setUpdateRate("no", 1, 0.0, 1.0, true);

		doStateChange(&StateID_Frog_Thrown); 

		this->onExecute();
		return true;
	}
	if(this->variation == 4) { //Cloud
		this->deleteForever = true;

		// Model creation	
		allocator.link(-1, GameHeaps[0], 0, 0x20);

		this->resFile.data = getResource("cloudM", "g3d/power_cloud.brres");
		nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("spincloud");
		bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
		SetupTextures_MapObj(&bodyModel, 0);

		allocator.unlink();

		// Stuff I do understand
		// this->scale = (Vec){1.2, 1.2, 1.2};
		this->scale = (Vec){0.0, 0.0, 0.0};

		this->rot.x = 0;
		this->rot.y = 0;
		this->rot.z = 0;
		this->direction = (this->settings >> 8) & 0xF; // Heading where the player look.


		float fWidth = 3 * 16.0f;
		sotCollider.init(this,
				/*xOffset=*/-23.0f, /*yOffset=*/7.0f,
				/*topYOffset=*/0,
				/*rightSize=*/fWidth, /*leftSize=*/0,
				/*rotation=*/0, /*_45=*/1
				);

		// What is this for. I dunno
		sotCollider._47 = 0xA;
		sotCollider.flags = 0x80180 | 0xC00;

		sotCollider.addToList();


		ActivePhysics::Info HitMeBaby;

		HitMeBaby.xDistToCenter = 0.0;
		HitMeBaby.yDistToCenter = 8.0;

		HitMeBaby.xDistToEdge = 24;
		HitMeBaby.yDistToEdge = 1;

		HitMeBaby.category1 = 0x3;
		HitMeBaby.category2 = 0x0;
		HitMeBaby.bitfield1 = 0x6F;
		HitMeBaby.bitfield2 = 0xffbafffe;
		HitMeBaby.unkShort1C = 0;
		HitMeBaby.callback = &dEn_c::collisionCallback;

		this->aPhysics.initWithStruct(this, &HitMeBaby);
		this->aPhysics.addToList();

		this->pos.y += 16;
		this->pos.z = 4000;

		//Added by LiQ for cloud x-pos fix
		if (this->direction == 1)
			this->pos.x += 24;
		else
			this->pos.x -= 24;


		doStateChange(&StateID_Cloud_Thrown); 

		this->onExecute();
		return true;
	}
	return true;
}

int daBoomerangHax_c::onDelete() {
	if(this->variation != 5) {
		this->Delete(1);
	}
	else {
		isTargetSpawned = false;
	}
	return true;
}

int daBoomerangHax_c::onExecute() {
	acState.execute();
	updateModelMatrices();

	bodyModel._vf1C();

	if(this->variation == 0) {
		this->playBoomerangSound();
		this->rot.z += (this->direction == 1) ? 2000 : -2000;
	}
	if(this->variation == 1) {
		this->spikerot.z += (this->direction == 1) ? 2000 : -2000; //Rotating it depending of its spawning direction
		//OSReport("Rotating spikeball: %d, %d / 0x%X\n", this->direction, this->rot.z, this->rot.z);
		PlaySound(this, SE_PLY_WALK_METAL);                  //Play SFX
	}
	if(this->variation == 3) {
		coinModel._vf1C();
		this->timer++;

		if(this->doIhaveCoin && !this->isCoinSpawned) {
			bindAnimChr_and_setUpdateRate("yes", 1, 0.0, 1.0, true);
			this->isCoinSpawned = true;
		}

		if(this->animationChr.isAnimationDone()) {
			this->animationChr.setCurrentFrame(0.0);
		}
		if(this->animationCoinChr.isAnimationDone()) {
			this->animationCoinChr.setCurrentFrame(0.0);
		}

		if(this->timer > 300) {
			PlaySound(this, SE_OBJ_CMN_BALLOON_BREAK);
			Vec efPos = {this->pos.x, this->pos.y, this->pos.z};
			S16Vec nullRot = {0,0,0};
			Vec oneVec = {1.0f, 1.0f, 1.0f};
			SpawnEffect("Wm_mr_balloonburst", 0, &efPos, &nullRot, &oneVec);
			this->Delete(1);
		}

		this->pos.y += 0.1;
		this->coinrot.y += 0x400;
	}
	if(this->variation == 4) {
		sotCollider.update();
	}

	return true;
}

int daBoomerangHax_c::onDraw() {
	bodyModel.scheduleForDrawing();
	if(this->variation == 3) {
		coinModel.scheduleForDrawing();
	}

	return true;
}

void daBoomerangHax_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y - ((this->variation != 3) ? 2.0 : 0.0), pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);
	if(this->variation == 3) {
		coinmatrix.translation(pos.x, pos.y, pos.z);
		coinmatrix.applyRotationYXZ(&coinrot.x, &coinrot.y, &coinrot.z);
	}
	if(this->variation == 1) {
		matrix.applyRotationYXZ(&spikerot.x, &spikerot.y, &spikerot.z);
	}

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
	if(this->variation == 3) {
		coinModel.setDrawMatrix(coinmatrix);
		coinModel.setScale(&coinscale);
		coinModel.calcWorld(false);
	}
}

bool daBoomerangHax_c::calculateTileCollisions() {

	/****************************/
	/***Tile collision detector**/
	/*Returns true if hit a wall*/
	/****************************/


	HandleXSpeed();                                      //consider the X speed
	HandleYSpeed();                                      //consider the Y speed
	doSpriteMovement();                                  //execute the speed movements

	cmgr_returnValue = collMgr.isOnTopOfTile();          //check if the sprite is on top of a tile
	collMgr.calculateBelowCollisionWithSmokeEffect();    //duh

	stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);      //literally stuff related to collisions

	float xDelta = pos.x - last_pos.x;                   //just read dude

	if (xDelta >= 0.0f) {                                //change of direction if needed
		direction = 0;
	}
	else {
		direction = 1;
	}

	if (collMgr.isOnTopOfTile()) {                       //if the sprite is on top of a tile
		if(alreadyOnTop == 0) {                          //if it just landed
			PlaySound(this, SE_OBJ_ROCK_LAND);           //play SFX
			alreadyOnTop = 1;                            //now it's already on the to^p
		}

		if (cmgr_returnValue == 0)                       //just read ?
			isOnTopOfTile = true;

		speed.y = 0.0f;                                  //no Y speed anymore cuz it's on the ground
		max_speed.x = (direction == 1) ? -1.5f : 1.5f;   //maximum X speed re-setting
		this->x_speed_inc = 0.0f;                        //no X speed incrementation
		this->speed.x = (direction == 1) ? -1.5f : 1.5f; //X speed re-setting
	}
	else {                                               //if the sprite in in mid-air
		alreadyOnTop = 0;                                //it's no loner on the top of a tile
	}

	collMgr.calculateAdjacentCollision(0);               //literally calculate the adjacent collision

	if (collMgr.outputMaybe & (0x15 << direction)) {     //if hit a wall
		if (collMgr.isOnTopOfTile()) {                   //if on the top of a tile
			isOnTopOfTile = true;
		}
		return true;                                     //returns true duh
	}
	return false;                                        //if didn't hit a wall
}

///////////////
// Boomerang_Thrown State
///////////////
	void daBoomerangHax_c::beginState_Boomerang_Thrown() {

	}
	void daBoomerangHax_c::executeState_Boomerang_Thrown() { 
		HandleXSpeed();
		doSpriteMovement();
		float speedx = (this->direction == 1) ? -2.7 : 2.7;
		this->timer++;
		if(this-> timer > 0 && this->timer <= 20) {
			this->max_speed.x = speedx;
			this->x_speed_inc = 0;
			this->speed.x = speedx;
			this->pos.y += 1.5;
		}
		if(this->timer > 20 && this->timer <= 55) {
			this->speed.x = speedx;
		}
		if(this-> timer > 55 && this->timer <= 70) {
			canI = true;
			this->max_speed.x = -speedx;
			this->x_speed_inc = 0.2;
			this->pos.y -= 2;
		}
		if(this->timer > 70) {
			this->x_speed_inc = 0;
			this->max_speed.x = -speedx;
			this->speed.x = -speedx;
		}
		if(this->timer == 600) {
			this->direction = (this->direction == 1) ? 0 : 1;
			doStateChange(&StateID_Boomerang_GotBack);
		}
	}
	void daBoomerangHax_c::endState_Boomerang_Thrown() { 

	}


///////////////
// Boomerang_GotBack State
///////////////
	void daBoomerangHax_c::beginState_Boomerang_GotBack() {
		this->x_speed_inc = 0;
	}
	void daBoomerangHax_c::executeState_Boomerang_GotBack() { 
		HandleXSpeed();
		doSpriteMovement();
		float speedx = (this->direction == 1) ? -2.7 : 2.7;
		this->max_speed.x = -speedx;
		this->speed.x = -speedx;
		this->scale.x -= 0.1;
		this->scale.y -= 0.1;
		this->scale.z -= 0.1;
		if(this->scale.x <= 0) {
			this->Delete(1);
		}
	}
	void daBoomerangHax_c::endState_Boomerang_GotBack() { 

	}


///////////////
// Spike_Walk State
///////////////
	void daBoomerangHax_c::beginState_Spike_Walk() {
		this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed; //set the maximum X speed depending of the spawning direction
		this->speed.x = (this->direction) ? -3.0 : 3.0;                       //set the current X speed depending of the spawning direction
		this->x_speed_inc = (this->direction) ? 0.6 : -0.6;                   //set the X speed increment depending of the spawning direction

		this->max_speed.y = -4;                                               //set the maximum Y speed
		this->speed.y = 6.0;                                                  //set the current Y speed
		this->y_speed_inc = -0.5;                                             //set the Y speed increment
	}
	void daBoomerangHax_c::executeState_Spike_Walk() {
		bool ret = calculateTileCollisions();                                 //calculate the tiles collision
		if (ret) {
			doStateChange(&StateID_Spike_Die);                                      //if hit a wall, die
		}
	}
	void daBoomerangHax_c::endState_Spike_Walk() { }


///////////////
// Spike_Die State
///////////////
	void daBoomerangHax_c::beginState_Spike_Die() {
		this->removeMyActivePhysics();           //Remove the collision
	}
	void daBoomerangHax_c::executeState_Spike_Die() { 
		PlaySound(this, SE_OBJ_WOOD_BOX_BREAK);  //Play SFX
		Vec2 nyeh = {this->pos.x, this->pos.y};  //Get the current position as a Vec2
		this->spawnHitEffectAtPosition(nyeh);    //Spawn Hit Effect at this position (duh)
		doWait = 0;                              //doWait is now 0
		this->Delete(this->deleteForever);       //DELETE FOREVAAAAAAAH
	}
	void daBoomerangHax_c::endState_Spike_Die() { }


///////////////
// Frog_Thrown State
///////////////
void daBoomerangHax_c::beginState_Frog_Thrown() {

}
void daBoomerangHax_c::executeState_Frog_Thrown() { 
	HandleXSpeed();
	doSpriteMovement();
	if(this->direction == 1) {
		if(this->speed.x > 0) {
			this->speed.x = 0;
			this->x_speed_inc = 0;
		}
	}
	if(this->direction == 0) {
		if(this->speed.x < 0) {
			this->speed.x = 0;
			this->x_speed_inc = 0;
		}
	}
}
void daBoomerangHax_c::endState_Frog_Thrown() { 

}


///////////////
// Cloud_Thrown State
///////////////
void daBoomerangHax_c::beginState_Cloud_Thrown() {
	this->timer = 0;
}
void daBoomerangHax_c::executeState_Cloud_Thrown() { 
	this->timer++;
	if(this->timer > 0 && this->timer < 13) {
		this->scale.x += 0.1;
		this->scale.y += 0.1;
		this->scale.z += 0.1;
		this->rot.y += 68264;
	}
	if(this->timer == 13) {
		this->scale.x = 1.2;
		this->scale.y = 1.2;
		this->scale.z = 1.2;
		this->rot.y = 0;
	}
	if(this->timer > 425) {
		this->scale.x -= 0.05;
		this->scale.y -= 0.05;
		this->scale.z -= 0.05;
	}
	if(this->timer == 438) {
		float fWidth = 1.5 * 16.0f;
		sotCollider.init(this,
				/*xOffset=*/-11.5f, /*yOffset=*/0.0f,
				/*topYOffset=*/0,
				/*rightSize=*/fWidth, /*leftSize=*/0,
				/*rotation=*/0, /*_45=*/1
				);

		// What is this for. I dunno
		sotCollider._47 = 0xA;
		sotCollider.flags = 0x80180 | 0xC00;

		sotCollider.addToList();
	}
	if(this->timer == 450) {
		this->Delete(1);
	}
}
void daBoomerangHax_c::endState_Cloud_Thrown() { 

}




/*****************************************************/
/**************Gabon Rock replacing shit**************/
/*Don't ask me how does it work, because i don't know*/
/*****************************************************/

int daGabonRock_c::getsettings() {									 //I know bleh bleh bleh that's not optimised, but lemme ask you something: Do I care ? The answer is no.
	int orig_val = this->onCreate_orig();
	if(getNybbleValue(this->settings, 12, 12) > 1) {
		int playerID = getNybbleValue(this->settings, 6, 6);
		dAcPy_c *player = dAcPy_c::findByID(playerID);
		int variation = getNybbleValue(this->settings, 11, 11);
		if(variation < 2) {
			if(variation == 1) { //Spike
				nw4r::snd::SoundHandle spikyHandle;
				PlaySoundWithFunctionB4(SoundRelatedClass, &spikyHandle, SE_EMY_GABON_ROCK_THROW, 1);
			}
			int settings = 0 | (playerID << 4) | (player->direction << 8) | (variation << 12);
			CreateActor(555, settings, player->pos, 0, 0);
			doWait = 60;
		}
		if(variation == 2) { //Wand

			doWait = 60;
		}
		if(variation == 3) { //Frog
			nw4r::snd::SoundHandle froggyHandle;
			PlaySoundWithFunctionB4(SoundRelatedClass, &froggyHandle, SE_EMY_KANIBO_THROW, 1);
			VEC3 actorpos = {player->pos.x + ((player->direction == 1) ? -10 : 10), player->pos.y + 16, player->pos.z};
			int bubbleSettings = 0 | (playerID << 4) | (player->direction << 8) | (variation << 12);
			CreateActor(555, bubbleSettings, actorpos, 0, 0);
			doWait = 30;
		}
		if(variation == 5) { //Gold

			doWait = 180;
		}
	}
	return orig_val;
}

void daEnBomhei_c::doThrowing() {
	this->isBurning = 180;
	this->speed.x = 3 * ((this->direction == 1) ? -1 : 1);
	this->speed.y = 3;
	this->amIthrown = 1;
	doStateChange(&daEnBomhei_c::StateID_Sleep);
}

void daEnBomhei_c::newPlayerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	if(this->amIthrown != 1) {
		this->playerCollision_orig(apThis, apOther);
		OSReport("i'm not thrown, go ahead\n");
	}
	else {
		OSReport("i'm thrown, go away\n");
	}
}

void daEnBomhei_c::newSpriteCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	if(amIthrown == 1) {
		u16 name = ((dEn_c*)apOther->owner)->name;
		if (name == EN_COIN || name == EN_EATCOIN || name == AC_BLOCK_COIN || name == EN_COIN_JUGEM || name == EN_COIN_ANGLE
			|| name == EN_COIN_JUMP || name == EN_COIN_FLOOR || name == EN_COIN_VOLT || name == EN_COIN_WIND
			|| name == EN_BLUE_COIN || name == EN_COIN_WATER || name == EN_REDCOIN || name == EN_GREENCOIN
			|| name == EN_JUMPDAI || name == EN_ITEM || name == EN_STAR_COIN) { //this list will probably be updated in the future if I find other sprites that unfortunatly don't have to EXXXXPLOOOOODE
			this->spriteCollision_orig(apThis, apOther);
		}
		else {
			if(((daEnBomhei_c *)apOther->owner)->amIthrown == 1) {
				this->spriteCollision_orig(apThis, apOther);
			}
			else {
				this->isBurning = 0;
			}
		}
	}
	else {
		this->spriteCollision_orig(apThis, apOther);
	}
}


class placeholder {
public:
	void doCleanClouds(); //Okay so there's a very good reason of why i put that in a placeholder class. The thing is i need to use that function in poweruphax.S as an extern, but for some reason, _ZN13doCleanCloudsEv refuses to work, so i put it in that class so _ZN11placeholder13doCleanCloudsEv works !
	void increaseIceCount(); //Same as above.
	void increasePropellerCount(); //Same as above.
};

void placeholder::doCleanClouds() {
	amIinCloud = 0;
	imDoneDoingVisibility = false;
	cloudSpawned[0] = 0;
	cloudSpawned[1] = 0;
	cloudSpawned[2] = 0;
	cloudSpawned[3] = 0;
}

void placeholder::increaseIceCount() {
	globalIceShoot++;
}

void placeholder::increasePropellerCount() {
	globalPropeller++;
}

extern bool enableDebugMode;
bool doneWithGreenStars;
bool doneWithPurpleCoins;
extern u8 LastLevelPlayed[2];
extern "C" void *dAcPy_c__ChangePowerupWithAnimation(void * Player, int powerup);
int dGameDisplay_c::cleanClouds() {
	int orig_val = this->onCreate_orig();
	
	amIinCloud = 0;
	imDoneDoingVisibility = false;
	doneWithGreenStars = false;
	doneWithPurpleCoins = false;

	return orig_val;
}

int dGameDisplay_c::doWaitCheck() {
	int orig_val = this->onExecute_orig();
	if(doWait > 0) {
		doWait--;
	}
	// OSReport("globalIceShoot = %d\n", globalIceShoot);
	// OSReport("globalPropeller = %d\n", globalPropeller);

	dAcPy_c *player = dAcPy_c::findByID(0);
	int p = CheckExistingPowerup(player);
	if(player->input.nowPressed & WPAD_B) {
		enableDebugMode = !enableDebugMode;
	}
	
	/*******/
	/*Cloud*/
	/*******/
	if(p == 12 && doWait == 0) {
		if (player->input.areWeShaking() && cloudSpawned[0] < 3) {
			int isPlayerMoving = 1;
			if(!(player->input.heldButtons & WPAD_LEFT) && !(player->input.heldButtons & WPAD_RIGHT) && (player->collMgr.isOnTopOfTile())) {
				isPlayerMoving = 0;
			}
			int settings = 0 | (0 << 4) | (player->direction << 8) | (4 << 12);
			VEC3 actualPos = {player->pos.x + ((isPlayerMoving == 1) ? ((player->direction == 1) ? -24 : 24) : 0), player->pos.y - ((isPlayerMoving == 1) ? 25 : 5), player->pos.z};
			// VEC3 actualPos = {player->pos.x, player->pos.y - 20, player->pos.z};
			dStageActor_c *cloud = CreateActor(555, settings, actualPos, 0, 0);
			cloudSpawned[0]++;
			player->speed.x = 0;
			player->speed.y = 0;
			imDoneDoingVisibility = false;
			doWait = 30;
		}
	}
	
	for(int i=1; i<4; i++) {
		dAcPy_c *player = dAcPy_c::findByID(i);
		if (CheckExistingPowerup(player) == 12 && player->input.areWeShaking() && cloudSpawned[i] < 3) {
			int isPlayerMoving = 1;
			if(!(player->input.heldButtons & WPAD_LEFT) && !(player->input.heldButtons & WPAD_RIGHT) && (player->collMgr.isOnTopOfTile())) {
				isPlayerMoving = 0;
			}
			int settings = 0 | (0 << 4) | (player->direction << 8) | (4 << 12);
			VEC3 actualPos = {player->pos.x + ((isPlayerMoving == 1) ? ((player->direction == 1) ? -24 : 24) : 0), player->pos.y - ((isPlayerMoving == 1) ? 25 : 5), player->pos.z};
			// VEC3 actualPos = {player->pos.x, player->pos.y - 20, player->pos.z};
			dStageActor_c *cloud = CreateActor(555, settings, actualPos, 0, 0);
			cloudSpawned[i]++;
			player->speed.x = 0;
			player->speed.y = 0;
			imDoneDoingVisibility = false;
			doWait = 30;
		}
	}
	
	if(p == 12) {
		if(amIinCloud == 0) {
			amIinCloud = 1;
			imDoneDoingVisibility = false;
		}
	}
	if(p != 12) {
		if(amIinCloud == 1) {
			amIinCloud = 0;
			imDoneDoingVisibility = false;
		}
	}
	if(!imDoneDoingVisibility) {
		nw4r::lyt::Picture *P_cloud_00;
		nw4r::lyt::Picture *P_cloud_01;
		nw4r::lyt::Picture *P_cloud_02;
		nw4r::lyt::Picture *P_cloudOff_00;
		nw4r::lyt::Picture *P_cloudOff_01;
		nw4r::lyt::Picture *P_cloudOff_02;
		P_cloud_00 = layout.findPictureByName("P_cloud_00");
		P_cloud_01 = layout.findPictureByName("P_cloud_01");
		P_cloud_02 = layout.findPictureByName("P_cloud_02");
		P_cloudOff_00 = layout.findPictureByName("P_cloudOff_00");
		P_cloudOff_01 = layout.findPictureByName("P_cloudOff_01");
		P_cloudOff_02 = layout.findPictureByName("P_cloudOff_02");
		if(p == 12) {
			if(cloudSpawned[0] == 0) {
				P_cloud_00->SetVisible(true);
				P_cloud_01->SetVisible(true);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(false);
				P_cloudOff_01->SetVisible(false);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[0] == 1) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(true);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(false);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[0] == 2) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(false);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(true);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[0] == 3) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(false);
				P_cloud_02->SetVisible(false);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(true);
				P_cloudOff_02->SetVisible(true);
			}
		}
		else {
			P_cloud_00->SetVisible(false);
			P_cloud_01->SetVisible(false);
			P_cloud_02->SetVisible(false);
			P_cloudOff_00->SetVisible(false);
			P_cloudOff_01->SetVisible(false);
			P_cloudOff_02->SetVisible(false);
		}
		
		P_cloud_00 = layout.findPictureByName("P_cloud_03");
		P_cloud_01 = layout.findPictureByName("P_cloud_05");
		P_cloud_02 = layout.findPictureByName("P_cloud_04");
		P_cloudOff_00 = layout.findPictureByName("P_cloudOff_05");
		P_cloudOff_01 = layout.findPictureByName("P_cloudOff_04");
		P_cloudOff_02 = layout.findPictureByName("P_cloudOff_03");
		if(CheckExistingPowerup(dAcPy_c::findByID(1))) {
			if(cloudSpawned[1] == 0) {
				P_cloud_00->SetVisible(true);
				P_cloud_01->SetVisible(true);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(false);
				P_cloudOff_01->SetVisible(false);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[1] == 1) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(true);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(false);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[1] == 2) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(false);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(true);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[1] == 3) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(false);
				P_cloud_02->SetVisible(false);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(true);
				P_cloudOff_02->SetVisible(true);
			} 
		} else {
			P_cloud_00->SetVisible(false);
			P_cloud_01->SetVisible(false);
			P_cloud_02->SetVisible(false);
			P_cloudOff_00->SetVisible(false);
			P_cloudOff_01->SetVisible(false);
			P_cloudOff_02->SetVisible(false);
		}
		
		
		P_cloud_00 = layout.findPictureByName("P_cloud_06");
		P_cloud_01 = layout.findPictureByName("P_cloud_08");
		P_cloud_02 = layout.findPictureByName("P_cloud_07");
		P_cloudOff_00 = layout.findPictureByName("P_cloudOff_08");
		P_cloudOff_01 = layout.findPictureByName("P_cloudOff_07");
		P_cloudOff_02 = layout.findPictureByName("P_cloudOff_06");
		if(CheckExistingPowerup(dAcPy_c::findByID(2))) {
			if(cloudSpawned[2] == 0) {
				P_cloud_00->SetVisible(true);
				P_cloud_01->SetVisible(true);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(false);
				P_cloudOff_01->SetVisible(false);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[2] == 1) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(true);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(false);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[2] == 2) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(false);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(true);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[2] == 3) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(false);
				P_cloud_02->SetVisible(false);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(true);
				P_cloudOff_02->SetVisible(true);
			} 
		} else {
			P_cloud_00->SetVisible(false);
			P_cloud_01->SetVisible(false);
			P_cloud_02->SetVisible(false);
			P_cloudOff_00->SetVisible(false);
			P_cloudOff_01->SetVisible(false);
			P_cloudOff_02->SetVisible(false);
		}
		
		
		P_cloud_00 = layout.findPictureByName("P_cloud_09");
		P_cloud_01 = layout.findPictureByName("P_cloud_11");
		P_cloud_02 = layout.findPictureByName("P_cloud_10");
		P_cloudOff_00 = layout.findPictureByName("P_cloudOff_11");
		P_cloudOff_01 = layout.findPictureByName("P_cloudOff_10");
		P_cloudOff_02 = layout.findPictureByName("P_cloudOff_09");
		if(CheckExistingPowerup(dAcPy_c::findByID(3))) {
			if(cloudSpawned[3] == 0) {
				P_cloud_00->SetVisible(true);
				P_cloud_01->SetVisible(true);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(false);
				P_cloudOff_01->SetVisible(false);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[3] == 1) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(true);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(false);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[3] == 2) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(false);
				P_cloud_02->SetVisible(true);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(true);
				P_cloudOff_02->SetVisible(false);
			}
			if(cloudSpawned[3] == 3) {
				P_cloud_00->SetVisible(false);
				P_cloud_01->SetVisible(false);
				P_cloud_02->SetVisible(false);
				P_cloudOff_00->SetVisible(true);
				P_cloudOff_01->SetVisible(true);
				P_cloudOff_02->SetVisible(true);
			} 
		} else {
			P_cloud_00->SetVisible(false);
			P_cloud_01->SetVisible(false);
			P_cloud_02->SetVisible(false);
			P_cloudOff_00->SetVisible(false);
			P_cloudOff_01->SetVisible(false);
			P_cloudOff_02->SetVisible(false);
		}
		
		
		imDoneDoingVisibility = true;
	}

	return orig_val;
}

/***********************/
/**Global coin counter**/
/***********************/

void dGameDisplay_c::doGlobalCoin() {
	if(globalCoins != dGameDisplay_c::instance->coins) {
		globalCoins++;
	}
	nw4r::lyt::TextBox *stupidcoin = dGameDisplay_c::instance->layout.findTextBoxByName("T_coin_00");					//get the coin textbox
	char str[2];																										//make a char that will contain the text to display
	sprintf(str, "%02d", dGameDisplay_c::instance->coins);																//insert the number in the char win three characters
	wchar_t nyeh[2];																									//make a wchar_t
	nyeh[0] = str[0];																									//put the char's content in the wchar_t
	nyeh[1] = str[1];
	stupidcoin->SetString(nyeh, 0, 2);																					//write it to the textbox
}

void dGameDisplay_c::refreshPurpleCoins() {
	nw4r::lyt::TextBox *stupidpurplecoin = dGameDisplay_c::instance->layout.findTextBoxByName("T_purpleCount_00");		//get the purple coin textbox
	char str[3];																										//make a char that will contain the text to display
	sprintf(str, "%03d", dGameDisplay_c::instance->purplecoins);														//insert the number in the char win three characters
	wchar_t nyeh[3];																									//make a wchar_t
	nyeh[0] = str[0];																									//put the char's content in the wchar_t
	nyeh[1] = str[1];
	nyeh[2] = str[2];
	stupidpurplecoin->SetString(nyeh, 0, 3);																			//write it to the textbox
}
//
// processed\../src/levelDrawer.cpp
//

#include <game.h>
#include "rvl/mtx.h"
#include "rvl/GXEnum.h"
#include "rvl/GXStruct.h"
#include "rvl/GXTransform.h"
#include "rvl/GXGeometry.h"
#include "rvl/GXDispList.h"
#include "rvl/GXLighting.h"
#include "rvl/GXTev.h"
#include "rvl/GXTexture.h"
#include "rvl/GXCull.h"
#include "rvl/GXPixel.h"
#include "rvl/GXBump.h"
#include "rvl/GXVert.h"
#include "rvl/vifuncs.h"


class WandDot {
	public:
		WandDot();
	
		float x, y;
		u8 size, initialSize, colourIndex;
		int timer;
		bool drawMe, amISetUp, colourMoveRight;

		void setMeUp(float, float, bool, u8, u8);
		void sizeUpdate();
		void colourUpdate();
};

WandDot::WandDot() {
	amISetUp = false;
}

void WandDot::setMeUp(float pX, float pY, bool pDrawMe, u8 pColourIndex = 0, u8 pSize = 16) {
	this->x = pX;
	this->y = pY;
	this->drawMe = pDrawMe;
	this->size = pSize;
	this->initialSize = pSize;
	this->colourIndex = pColourIndex % 72;
	amISetUp = true;
}

inline void WandDot::sizeUpdate() {
	if(this->timer >= 60) {
		if(this->timer % 5 == 0) this->size -= 1;
		if(this->timer >= 120) {
			this->timer = 0;
			this->size = this->initialSize;
			return;
		}
	} else {
		if(this->timer % 5 == 0) this->size += 1;
	}
	this->timer++;
}

struct colour {
	union {
		u32 all;
		struct { u8 r, g, b, a; };
	};
};

colour rainbowColours[] = {
	0xFF0000FF,
	0xFF1500FF,
	0xFF2A00FF,
	
	0xFF4000FF,
	0xFF5400FF,
	0xFF6A00FF,
	
	0xFF8000FF,
	0xFF9400FF,
	0xFFAA00FF,
	
	0xFFBF00FF,
	0xFFD400FF,
	0xFFE900FF,
	
	0xFFFF00FF,
	0xE9FF00FF,
	0xD4FF00FF,
	
	0xBFFF00FF,
	0xAAFF00FF,
	0x94FF00FF,
	
	0x80FF00FF,
	0x6AFF00FF,
	0x54FF00FF,
	
	0x40FF00FF,
	0x2AFF00FF,
	0x15FF00FF,
	
	0x00FF00FF,
	0x00FF15FF,
	0x00FF2AFF,
	
	0x00FF40FF,
	0x00FF54FF,
	0x00FF6AFF,
	
	0x00FF80FF,
	0x00FF94FF,
	0x00FFAAFF,
	
	0x00FFBFFF,
	0x00FFD4FF,
	0x00FFE9FF,
	
	0x00FFFFFF,
	0x00E9FFFF,
	0x00D4FFFF,
	
	0x00BFFFFF,
	0x00AAFFFF,
	0x0094FFFF,
	
	0x0080FFFF,
	0x006AFFFF,
	0x0054FFFF,
	
	0x0040FFFF,
	0x002AFFFF,
	0x0015FFFF,
	
	0x0000FFFF,
	0x1500FFFF,
	0x2A00FFFF,
	
	0x4000FFFF,
	0x5400FFFF,
	0x6A00FFFF,
	
	0x8000FFFF,
	0x9400FFFF,
	0xAA00FFFF,
	
	0xBF00FFFF,
	0xD400FFFF,
	0xE900FFFF,
	
	0xFF00FFFF,
	0xFF00E9FF,
	0xFF00D4FF,
	
	0xFF00BFFF,
	0xFF00AAFF,
	0xFF0094FF,
	
	0xFF0080FF,
	0xFF006AFF,
	0xFF0054FF,
	
	0xFF0040FF,
	0xFF002AFF,
	0xFF0015FF


/*	0xFF0000FF,
	0xFF4000FF,
	0xFF8000FF,
	0xFFBF00FF,
	0xFFFF00FF,
	0xBFFF00FF,
	0x80FF00FF,
	0x40FF00FF,
	0x00FF00FF,
	0x00FF40FF,
	0x00FF80FF,
	0x00FFBFFF,
	0x00FFFFFF,
	0x00BFFFFF,
	0x0080FFFF,
	0x0040FFFF,
	0x0000FFFF,
	0x4000FFFF,
	0x8000FFFF,
	0xBF00FFFF,
	0xFF00FFFF,
	0xFF00BFFF,
	0xFF0080FF,
	0xFF0040FF*/
};

inline void WandDot::colourUpdate() {
	if(this->timer % 5 == 0) {
		this->colourIndex +=1;
		this->colourIndex %= 72;
	}
}

#define wandDotAmount 10
WandDot lotsOfDots[4][wandDotAmount];


class LevelDrawer : public m3d::proc_c {
	public:
		LevelDrawer();

		bool amISetUp;
		mHeapAllocator_c allocator;

		void setMeUp();
		void drawMe();
		void drawOpa();
		void drawXlu();
};




static LevelDrawer levelDrawerInstance;

int LevelDraw() {
	levelDrawerInstance.drawMe();
	
	APDebugDraw();
	
	return 1;
}


LevelDrawer::LevelDrawer() {
	amISetUp = false;
}

void LevelDrawer::setMeUp() {
	allocator.setup(GameHeaps[0], 0x20);
	setup(&allocator);
	
	for(int i = 0; i < 4; i++) {
		for(int j = 0; j < wandDotAmount; j++) {
			lotsOfDots[i][j].setMeUp(1024+4*j, -432+4*i, true, j); 
		}
	}
	
}

void LevelDrawer::drawMe() {
	if (!amISetUp) {
		setMeUp();
		amISetUp = true;
	}
	
	scheduleForDrawing();
}

void LevelDrawer::drawOpa() {
	drawXlu();
}

void LevelDrawer::drawXlu() {
	GXClearVtxDesc();
	
	GXSetVtxDesc(GX_VA_POS, GX_DIRECT);
	GXSetVtxDesc(GX_VA_CLR0, GX_DIRECT);
	
	GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_F32, 0);
	GXSetVtxAttrFmt(GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);
	
	GXSetNumIndStages(0);
	for (int i = 0; i < 0x10; i++)
		GXSetTevDirect((GXTevStageID)i);
	
	GXSetNumChans(1);
	GXSetChanCtrl(GX_COLOR0A0, GX_DISABLE, GX_SRC_REG, GX_SRC_VTX, GX_LIGHT_NULL, GX_DF_NONE, GX_AF_NONE);
	GXSetChanAmbColor(GX_COLOR0A0, (GXColor){255,255,255,255});
	GXSetChanMatColor(GX_COLOR0A0, (GXColor){255,255,255,255});
	GXSetNumTexGens(0);
	
	GXSetNumTevStages(1);
	GXSetNumIndStages(0);
	
	GXSetTevSwapModeTable(GX_TEV_SWAP0, GX_CH_RED, GX_CH_GREEN, GX_CH_BLUE, GX_CH_ALPHA);
	
	GXSetTevOrder(GX_TEVSTAGE0, GX_TEXCOORD_NULL, GX_TEXMAP_NULL, GX_COLOR0A0);
	GXSetTevOp(GX_TEVSTAGE0, GX_PASSCLR);
//	GXSetTevColorIn(GX_TEVSTAGE0, GX_CC_C1, GX_CC_C0, GX_CC_RASC, GX_CC_ZERO);
//	GXSetTevColorOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
//	GXSetTevAlphaIn(GX_TEVSTAGE0, GX_CA_ZERO, GX_CA_A0, GX_CA_RASA, GX_CA_ZERO);
//	GXSetTevAlphaOp(GX_TEVSTAGE0, GX_TEV_ADD, GX_TB_ZERO, GX_CS_SCALE_1, GX_TRUE, GX_TEVPREV);
	
	GXSetZCompLoc(GX_FALSE);
	GXSetBlendMode(GX_BM_BLEND, GX_BL_SRCALPHA, GX_BL_INVSRCALPHA, GX_LO_SET);
	GXSetZMode(GX_TRUE, GX_ALWAYS, GX_FALSE);
	GXSetAlphaCompare(GX_ALWAYS, 0, GX_AOP_OR, GX_ALWAYS, 0);
	
	GXSetFog(GX_FOG_NONE, 0, 0, 0, 0, (GXColor){0,0,0,0});
	GXSetFogRangeAdj(GX_FALSE, 0, 0);
	
	GXSetCullMode(GX_CULL_NONE);
	
	GXSetDither(GX_TRUE);
	//GXSetLineWidth(8, GX_TO_ZERO);
	
	
	GXSetTevColor(GX_TEVREG0, (GXColor){255,255,255,255});
	GXSetTevColor(GX_TEVREG1, (GXColor){0,0,0,255});
	
	nw4r::g3d::Camera cam(GetCameraByID(GetCurrentCameraID()));
	Mtx matrix;
	cam.GetCameraMtx(&matrix);
	GXLoadPosMtxImm(matrix, 0);
	GXSetCurrentMtx(0);
	
	for(int i = 0; i < 4; i++) {
		for(int j = 0; j < wandDotAmount; j++) {

			if(!lotsOfDots[i][j].amISetUp || !lotsOfDots[i][j].drawMe) continue;

			GXSetPointSize(lotsOfDots[i][j].size, GX_TO_ZERO);

			lotsOfDots[i][j].sizeUpdate();
			lotsOfDots[i][j].colourUpdate();

			GXBegin(GX_POINTS, GX_VTXFMT0, 1);
			
			GXPosition3f32(lotsOfDots[i][j].x, lotsOfDots[i][j].y, 9000.0f);
			u8 r, g, b, a;
			if(lotsOfDots[i][j].colourMoveRight) {
				r = rainbowColours[72-lotsOfDots[i][j].colourIndex].r;
				g = rainbowColours[72-lotsOfDots[i][j].colourIndex].g;
				b = rainbowColours[72-lotsOfDots[i][j].colourIndex].b;
				a = rainbowColours[72-lotsOfDots[i][j].colourIndex].a;
			} else {
				r = rainbowColours[lotsOfDots[i][j].colourIndex].r;
				g = rainbowColours[lotsOfDots[i][j].colourIndex].g;
				b = rainbowColours[lotsOfDots[i][j].colourIndex].b;
				a = rainbowColours[lotsOfDots[i][j].colourIndex].a;
			}
			
			GXColor4u8(r,g,b,a);

			GXEnd();
		}
	}
	
	GXSetPointSize(16, GX_TO_ZERO);
}
//
// processed\../src/poweruphax.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>


void ThwompHammer(dEn_c *thwomp, ActivePhysics *apThis, ActivePhysics *apOther) {
	if (thwomp->name == 0x51) {
		thwomp->dEn_c::collisionCat13_Hammer(apThis, apOther);
	}
	return;
}

void BooHammer(dEn_c *boo, ActivePhysics *apThis, ActivePhysics *apOther) {
	if (boo->name == 0xB0) {
		boo->dEn_c::collisionCat13_Hammer(apThis, apOther);
	}
	return;
}

void UrchinHammer(dEn_c *urchin, ActivePhysics *apThis, ActivePhysics *apOther) {
	return;
}


#include "poweruphax.h"

void SetCullModeForMaterial(m3d::mdl_c *model, int materialID, GXCullMode mode);


dHammerSuitRenderer_c *dHammerSuitRenderer_c::build() {
	return new dHammerSuitRenderer_c;
}

dHammerSuitRenderer_c::dHammerSuitRenderer_c() { } dHammerSuitRenderer_c::~dHammerSuitRenderer_c() {
}

void dHammerSuitRenderer_c::setup(dPlayerModelHandler_c *handler) {
	setup(handler, 0);
}

void dHammerSuitRenderer_c::setup(dPlayerModelHandler_c *handler, int sceneID) {
	victim = (dPlayerModel_c*)handler->mdlClass;

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	nw4r::g3d::ResFile hammer(getResource("hammerM", "g3d/suit.brres"));
	nw4r::g3d::ResFile boomer(getResource("boomerangM", "g3d/suit.brres"));
	nw4r::g3d::ResFile spike(getResource("spikeM", "g3d/suit.brres"));
	nw4r::g3d::ResFile cloud(getResource("cloudM", "g3d/suit.brres"));
	nw4r::g3d::ResFile frog(getResource("frogM", "g3d/suit.brres"));

	if (victim->player_id_2 <= 1) {
		/********/
		/*Hammer*/
		/********/
		nw4r::g3d::ResMdl rmhammer = hammer.GetResMdl((victim->player_id_2 == 0) ? "marioHelmet" : "luigiHelmet");
		hammerHelmet.setup(rmhammer, &allocator, 0, 1, 0);
		SetupTextures_MapObj(&hammerHelmet, sceneID);
		/***********/
		/*Boomerang*/
		/***********/
		nw4r::g3d::ResMdl rmboomer = boomer.GetResMdl((victim->player_id_2 == 0) ? "marioHelmet" : "luigiHelmet");
		boomerHelmet.setup(rmboomer, &allocator, 0, 1, 0);
		SetupTextures_MapObj(&boomerHelmet, sceneID);
		/*******/
		/*Spike*/
		/*******/
		nw4r::g3d::ResMdl rmspike = spike.GetResMdl((victim->player_id_2 == 0) ? "marioHelmet" : "luigiHelmet");
		spikeHelmet.setup(rmspike, &allocator, 0, 1, 0);
		SetupTextures_MapObj(&spikeHelmet, sceneID);
		/*******/
		/*Cloud*/
		/*******/
		nw4r::g3d::ResMdl rmcloud = cloud.GetResMdl((victim->player_id_2 == 0) ? "marioHelmet" : "luigiHelmet");
		cloudHelmet.setup(rmcloud, &allocator, 0, 1, 0);
		SetupTextures_Player(&cloudHelmet, sceneID);
		/******/
		/*Frog*/
		/******/
		nw4r::g3d::ResMdl rmfrog = frog.GetResMdl((victim->player_id_2 == 0) ? "marioHelmet" : "luigiHelmet");
		frogHead.setup(rmfrog, &allocator, 0, 1, 0);
		SetupTextures_Player(&frogHead, sceneID);
	}

	const char *shellNames[] = {
		"shell", "shell", "shell", "shell", "shell"
	};
	/********/
	/*Hammer*/
	/********/
	hammerShell.setup(hammer.GetResMdl(shellNames[victim->player_id_2]), &allocator, 0, 1, 0);
	SetupTextures_MapObj(&hammerShell, sceneID);
	/***********/
	/*Boomerang*/
	/***********/
	boomerShell.setup(boomer.GetResMdl(shellNames[victim->player_id_2]), &allocator, 0, 1, 0);
	SetupTextures_MapObj(&boomerShell, sceneID);
	/*******/
	/*Spike*/
	/*******/
	spikeShell.setup(spike.GetResMdl(shellNames[victim->player_id_2]), &allocator, 0, 1, 0);
	SetupTextures_MapObj(&spikeShell, sceneID);

	allocator.unlink();


	victimModel = &victim->models[0].body;
	nw4r::g3d::ResMdl *playerResMdl =
		(nw4r::g3d::ResMdl*)(((u32)victimModel->scnObj) + 0xE8);

	//headNodeID = playerResMdl->GetResNode("player_head").GetID();
	if (victim->player_id_2 <= 1) {
		nw4r::g3d::ResNode face_1 = playerResMdl->GetResNode("face_1");
		headNodeID = face_1.GetID();
	}

	nw4r::g3d::ResNode skl_root = playerResMdl->GetResNode("skl_root");
	rootNodeID = skl_root.GetID();
}

void dHammerSuitRenderer_c::draw() {
	if (victim->powerup_id < 7 || victim->powerup_id == 8 || victim->powerup_id == 13) {
		return;
	}

	if(victim->powerup_id == 7) {
		/*if (victim->player_id_2 <= 1) {
			// Materials: 2=hair 3=hat; Modes: BACK=visible ALL=invisible
			SetCullModeForMaterial(&victim->getCurrentModel()->head, 3, GX_CULL_ALL);
	
			Mtx headMtx;
			victimModel->getMatrixForNode(headNodeID, headMtx);
	
			hammerHelmet.setDrawMatrix(headMtx);
			hammerHelmet.setScale(1.0f, 1.0f, 1.0f);
			hammerHelmet.calcWorld(false);
	
			hammerHelmet.scheduleForDrawing();
		}*/
	
		Mtx rootMtx;
		victimModel->getMatrixForNode(rootNodeID, rootMtx);
	
		hammerShell.setDrawMatrix(rootMtx);
		hammerShell.setScale(1.0f, 1.0f, 1.0f);
		hammerShell.calcWorld(false);
	
		hammerShell.scheduleForDrawing();
	}
	if(victim->powerup_id == 9) {
		/*if (victim->player_id_2 <= 1) {
			// Materials: 2=hair 3=hat; Modes: BACK=visible ALL=invisible
			SetCullModeForMaterial(&victim->getCurrentModel()->head, 3, GX_CULL_ALL);
	
			Mtx headMtx;
			victimModel->getMatrixForNode(headNodeID, headMtx);
	
			spikeHelmet.setDrawMatrix(headMtx);
			spikeHelmet.setScale(1.0f, 1.0f, 1.0f);
			spikeHelmet.calcWorld(false);
	
			spikeHelmet.scheduleForDrawing();
		}*/
	
		Mtx rootMtx;
		victimModel->getMatrixForNode(rootNodeID, rootMtx);
	
		spikeShell.setDrawMatrix(rootMtx);
		spikeShell.setScale(1.0f, 1.0f, 1.0f);
		spikeShell.calcWorld(false);
	
		spikeShell.scheduleForDrawing();
	}
	if(victim->powerup_id == 10) {
		/*if (victim->player_id_2 <= 1) {
			// Materials: 2=hair 3=hat; Modes: BACK=visible ALL=invisible
			SetCullModeForMaterial(&victim->getCurrentModel()->head, 3, GX_CULL_ALL);
	
			Mtx headMtx;
			victimModel->getMatrixForNode(headNodeID, headMtx);
	
			boomerHelmet.setDrawMatrix(headMtx);
			boomerHelmet.setScale(1.0f, 1.0f, 1.0f);
			boomerHelmet.calcWorld(false);
	
			boomerHelmet.scheduleForDrawing();
		}*/
	
		Mtx rootMtx;
		victimModel->getMatrixForNode(rootNodeID, rootMtx);
	
		boomerShell.setDrawMatrix(rootMtx);
		boomerShell.setScale(1.0f, 1.0f, 1.0f);
		boomerShell.calcWorld(false);
	
		boomerShell.scheduleForDrawing();
	}
	/*if(victim->powerup_id == 11) {
		if (victim->player_id_2 <= 1) {
			// Materials: 2=hair 3=hat; Modes: BACK=visible ALL=invisible
			SetCullModeForMaterial(&victim->getCurrentModel()->head, 3, GX_CULL_ALL);
	
			Mtx headMtx;
			victimModel->getMatrixForNode(headNodeID, headMtx);
	
			frogHead.setDrawMatrix(headMtx);
			frogHead.setScale(1.0f, 1.0f, 1.0f);
			frogHead.calcWorld(false);
	
			frogHead.scheduleForDrawing();
		}
	
		Mtx rootMtx;
		victimModel->getMatrixForNode(rootNodeID, rootMtx);
	}*/
	if(victim->powerup_id == 12) {
		if (victim->player_id_2 <= 1) {
			// Materials: 2=hair 3=hat; Modes: BACK=visible ALL=invisible
			SetCullModeForMaterial(&victim->getCurrentModel()->head, 3, GX_CULL_ALL);
	
			Mtx headMtx;
			victimModel->getMatrixForNode(headNodeID, headMtx);
	
			cloudHelmet.setDrawMatrix(headMtx);
			cloudHelmet.setScale(1.0f, 1.0f, 1.0f);
			cloudHelmet.calcWorld(false);
	
			cloudHelmet.scheduleForDrawing();
		}
	
		Mtx rootMtx;
		victimModel->getMatrixForNode(rootNodeID, rootMtx);
	}
}








// NEW VERSION
void CrapUpPositions(Vec *out, const Vec *in);

void dStockItem_c::setScalesOfSomeThings() {
	nw4r::lyt::Pane *ppos = N_forUse_PPos[playerCount];

	int howManyPlayers = 0;
	for (int i = 0; i < 4; i++) {
		if (isPlayerActive[i]) {
			int picID = getIconPictureIDforPlayer(howManyPlayers);
			int charID = Player_ID[i];

			if (picID != 24) {
				nw4r::lyt::Picture *pic = P_icon[picID];

				Vec in, out;

				in.x = pic->effectiveMtx[0][3];
				in.y = pic->effectiveMtx[1][3];
				in.z = pic->effectiveMtx[2][3];

				CrapUpPositions(&out, &in);

				u8 *wmp = (u8*)player2d[charID];
				*((float*)(wmp+0xAC)) = out.x;
				*((float*)(wmp+0xB0)) = out.y;
				*((float*)(wmp+0xB4)) = out.z;
				*((float*)(wmp+0x220)) = 0.89999998f;
				*((float*)(wmp+0x224)) = 0.89999998f;
				*((float*)(wmp+0x228)) = 0.89999998f;
				*((float*)(wmp+0x25C)) = 26.0f;
			}
			howManyPlayers++;
		}
	}


	for (int i = 0; i < 14; i++) {
		u8 *item = (u8*)newItemPtr[i];

		nw4r::lyt::Pane *icon = newIconPanes[i];

		Vec in, out;
		in.x = icon->effectiveMtx[0][3];
		in.y = icon->effectiveMtx[1][3];
		in.z = icon->effectiveMtx[2][3];

		CrapUpPositions(&out, &in);

		nw4r::lyt::Pane *shdRoot = shadow->rootPane;
		if(i == 0) {
			out.y = shdRoot->trans.y + 345;
			out.x -= 246;
		}
		if(i == 1) {
			out.y = shdRoot->trans.y + 345;
			out.x -= 164;
		}
		if(i == 2) {
			out.y = shdRoot->trans.y + 345;
			out.x -= 82;
		}
		if(i == 3) {
			out.y = shdRoot->trans.y + 345;
			out.x -= 0;
		}
		if(i == 4) {
			out.y = shdRoot->trans.y + 345;
			out.x -= -82;
		}
		if(i == 5) {
			out.y = shdRoot->trans.y + 345;
			out.x -= -164;
		}
		if(i == 6) {
			out.y = shdRoot->trans.y + 345;
			out.x -= -246;
		}
		if(i == 7) {
			out.y = shdRoot->trans.y + 235;
			out.x -= 246;
		}
		if(i == 8) {
			out.y = shdRoot->trans.y + 235;
			out.x -= 164;
		}
		if(i == 9) {
			out.y = shdRoot->trans.y + 235;
			out.x -= 82;
		}
		if(i == 10) {
			out.y = shdRoot->trans.y + 235;
			out.x -= 0;
		}
		if(i == 11) {
			out.y = shdRoot->trans.y + 235;
			out.x -= -82;
		}
		if(i == 12) {
			out.y = shdRoot->trans.y + 235;
			out.x -= -164;
		}
		if(i == 13) {
			out.y = shdRoot->trans.y + 235;
			out.x -= -246;
		}

		*((float*)(item+0xAC)) = out.x;
		*((float*)(item+0xB0)) = out.y;
		*((float*)(item+0xB4)) = out.z;
		*((float*)(item+0x1F4)) = P_buttonBase[i]->scale.x;
		*((float*)(item+0x1F8)) = P_buttonBase[i]->scale.y;
		*((float*)(item+0x1FC)) = 1.0f;
	}


	nw4r::lyt::Pane *shdRoot = shadow->rootPane;
	shdRoot->trans.x = N_stockItem->effectiveMtx[0][3];
	shdRoot->trans.y = N_stockItem->effectiveMtx[1][3];
	shdRoot->trans.z = N_stockItem->effectiveMtx[2][3];
	shdRoot->scale.x = N_stockItem_01->effectiveMtx[0][0];
	shdRoot->scale.y = N_stockItem_01->effectiveMtx[1][1];

	for (int i = 0; i < 7; i++) {
		shadow->buttonBases[i]->scale = newButtonBase[i]->scale;
	}
	shadow->hammerButtonBase->scale = newButtonBase[7]->scale;
	shadow->boomerButtonBase->scale = newButtonBase[8]->scale;
	shadow->spikeButtonBase->scale = newButtonBase[9]->scale;
	shadow->bombButtonBase->scale = newButtonBase[10]->scale;
	shadow->frogButtonBase->scale = newButtonBase[11]->scale;
	shadow->thunderButtonBase->scale = newButtonBase[12]->scale;
	shadow->cloudButtonBase->scale = newButtonBase[13]->scale;
}

int BlkItemSpawn::doStupidOSReport() {
    OSReport("itemType = %d\n", this->itemType);
}

//
// processed\../src/statsMenu.cpp
//

#include <common.h>
#include <game.h>
#include "sfx.h"

extern int globalCoins;
extern char CurrentLevel, CurrentWorld;

class dStatsMenu_c : public dStageActor_c {
	public:
		static dActor_c *build();
		static dStatsMenu_c *instance;

		dStatsMenu_c();

		int onCreate();
		int onDelete();
		int onExecute();
		int onDraw();

		int beforeExecute() { return true; }
		int afterExecute(int) { return true; }
		int beforeDraw() { return true; }
		int afterDraw(int) { return true; }

		void goMap();
		void goAgain();
		void goReplay();
		void switchButtons(int oldButton, int newButton);
		void setStats();
		void activate(int pScene, int pSceneParams, int pPowerupStoreType, int pWipe);
		bool wasActiveAlready;

		m2d::EmbedLayout_c layout;
		bool layoutLoaded;

		bool visible;
		float scaleEase;
		int timer;

		int count;
		int autoselectCountdown;

		int* structWithWorldData;

		int selected;
		
		int coinsAtStart;
		
		int scene, sceneParams, powerupStoreType, wipe;

		nw4r::lyt::TextBox
			*coinCount;

		nw4r::lyt::TextBox
			*Countdown;

		nw4r::lyt::Picture
			*BtnLeft[3], *BtnMid[3], *BtnRight[3];

		nw4r::lyt::TexMap
			*selectedMapLeft, *selectedMapMid, *selectedMapRight,
			*notSelectedMapLeft, *notSelectedMapMid, *notSelectedMapRight;

		nw4r::lyt::Picture
			*starCoinCircle, *starCoin;

		nw4r::lyt::Pane
			*Buttons[3];

		dStateWrapper_c<dStatsMenu_c> state;

		USING_STATES(dStatsMenu_c);
		DECLARE_STATE(Hidden);
		DECLARE_STATE(WaitForWipe);
		DECLARE_STATE(CountdownWait);
		DECLARE_STATE(ShowWait);
		DECLARE_STATE(Wait);
};

CREATE_STATE(dStatsMenu_c, Hidden);
CREATE_STATE(dStatsMenu_c, WaitForWipe);
CREATE_STATE(dStatsMenu_c, CountdownWait);
CREATE_STATE(dStatsMenu_c, ShowWait);
CREATE_STATE(dStatsMenu_c, Wait);

dStatsMenu_c *dStatsMenu_c::instance = 0;
dActor_c *dStatsMenu_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dStatsMenu_c));
	dStatsMenu_c *c = new(buffer) dStatsMenu_c;

	instance = c;
	return c;
}

const char *StatsMenuFileList[] = {0};
const SpriteData StatsMenuSpriteData = { ProfileId::NumPad, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile StatsMenuProfile(&dStatsMenu_c::build, SpriteId::StatsMenu, StatsMenuSpriteData, ProfileId::StatsMenu, ProfileId::StatsMenu, "StatsMenu", StatsMenuFileList);


#define ANIM_WINDOW_IN 0
#define ANIM_WINDOW_LOOP 1
#define ANIM_WINDOW_OUT 2
#define ANIM_BUTTON_HIT 3 //3, 4, 5
#define ANIM_BUTTON_IDLE 6 //6, 7, 8
#define ANIM_BUTTON_OFF 9 //9, 10, 11
#define ANIM_BUTTON_ON 12 //12, 13, 14


dStatsMenu_c::dStatsMenu_c() : state(this, &StateID_Hidden) {
	layoutLoaded = false;
	visible = false;
}

int dStatsMenu_c::onCreate() {
	if(RESTART_CRSIN_LevelStartStruct.isReplay) this->Delete(1);
	wasActiveAlready = false;
	
	count = 180;
	autoselectCountdown = 180;

	coinsAtStart = globalCoins;
	
	if (!layoutLoaded) {
		bool gotFile = layout.loadArc("statsMenu.arc", false);
		if (!gotFile)
			return false;

		selected = 0;

		layout.build("statsMenu.brlyt");

		if (IsWideScreen()) {
			layout.layout.rootPane->scale.x = 1.0f;
		} else {
			layout.clippingEnabled = true;
			layout.clipX = 0;
			layout.clipY = 52;
			layout.clipWidth = 640;
			layout.clipHeight = 352;
			layout.layout.rootPane->scale.x = 0.731f;
			layout.layout.rootPane->scale.y = 0.7711f;
		}

		static const char *brlanNames[] = {
			"statsMenu_hitButton.brlan",
			"statsMenu_idleButton.brlan",
			"statsMenu_inWindow.brlan",
			"statsMenu_loopWindow.brlan",
			"statsMenu_offButon.brlan",
			"statsMenu_onButton.brlan",
			"statsMenu_outWindow.brlan",
		};

		static const char *groupNames[] = {
			"A00_inWindow",     "A00_inWindow",   "A00_inWindow", 
			"B00_tuzukuButton", "B02_menuButton", "Group_00",
			"B00_tuzukuButton", "B02_menuButton", "Group_00",
			"B00_tuzukuButton", "B02_menuButton", "Group_00",
			"B00_tuzukuButton", "B02_menuButton", "Group_00",
		};
		static const int brlanIDs[] = {
			2,  3,  6,  //A00_inWindow (in, loop, out)
			0,  0,  0,  //Buttons      (hit)
			1,  1,  1,  //Buttons      (idle)
			4,  4,  4,  //Buttons      (off)
			5,  5,  5,  //Buttons      (on)
		};

		layout.loadAnimations(brlanNames, 7);
		layout.loadGroups(groupNames, brlanIDs, 15);
		layout.disableAllAnimations();
		
		layout.drawOrder = 140;
		
		
		BtnLeft[0]  = layout.findPictureByName("Btn1_Left");
		BtnMid[0]   = layout.findPictureByName("Btn1_Middle");
		BtnRight[0] = layout.findPictureByName("Btn1_Right");
		BtnLeft[1]  = layout.findPictureByName("Btn2_Left");
		BtnMid[1]   = layout.findPictureByName("Btn2_Middle");
		BtnRight[1] = layout.findPictureByName("Btn2_Right");
		BtnLeft[2]  = layout.findPictureByName("Btn2_Left_00");
		BtnMid[2]   = layout.findPictureByName("Btn2_Middle_00");
		BtnRight[2] = layout.findPictureByName("Btn2_Right_00");
		
		selectedMapLeft = BtnLeft[0]->material->texMaps;
		selectedMapMid = BtnMid[0]->material->texMaps;
		selectedMapRight = BtnRight[0]->material->texMaps;
		notSelectedMapLeft = BtnLeft[1]->material->texMaps;
		notSelectedMapMid = BtnMid[1]->material->texMaps;
		notSelectedMapRight = BtnRight[1]->material->texMaps;
		
		Buttons[0] = layout.findPictureByName("P_SBBase_00");
		Buttons[1] = layout.findPictureByName("P_SBBase_02");
		Buttons[2] = layout.findPictureByName("P_SBBase_01");
		
		Countdown = layout.findTextBoxByName("Countdown");
		coinCount = layout.findTextBoxByName("coinCount");
		
		layoutLoaded = true;
	}

	visible = false;

	return true;
}

void dStatsMenu_c::switchButtons(int oldButton, int newButton) {
	BtnLeft[oldButton]->material->texMaps = notSelectedMapLeft;
	BtnMid[oldButton]->material->texMaps = notSelectedMapMid;
	BtnRight[oldButton]->material->texMaps = notSelectedMapRight;
	BtnLeft[newButton]->material->texMaps = selectedMapLeft;
	BtnMid[newButton]->material->texMaps = selectedMapMid;
	BtnRight[newButton]->material->texMaps = selectedMapRight;
	
	layout.enableNonLoopAnim(ANIM_BUTTON_OFF+oldButton);
	layout.enableNonLoopAnim(ANIM_BUTTON_ON+newButton);	
}

void dStatsMenu_c::setStats() {
	if (dGameDisplay_c::instance->layout.findPictureByName("P_collection_00")->flag == 1) {
		starCoinCircle = layout.findPictureByName("starCoinCircle1");
		starCoin = layout.findPictureByName("starCoin1");
		starCoinCircle->SetVisible(false);
		starCoin->SetVisible(true);
	}
	if (dGameDisplay_c::instance->layout.findPictureByName("P_collection_01")->flag == 1) {
		starCoinCircle = layout.findPictureByName("starCoinCircle2");
		starCoin = layout.findPictureByName("starCoin2");
		starCoinCircle->SetVisible(false);
		starCoin->SetVisible(true);
	}
	if (dGameDisplay_c::instance->layout.findPictureByName("P_collection_02")->flag == 1) {
		starCoinCircle = layout.findPictureByName("starCoinCircle3");
		starCoin = layout.findPictureByName("starCoin3");
		starCoinCircle->SetVisible(false);
		starCoin->SetVisible(true);
	}
	
	int collectedCoins = globalCoins-coinsAtStart;
	wchar_t textCount[9];
	sprintf((char*)textCount, "% 9d", collectedCoins);
	//wchar_t wchar_tCount;
	int digits = 0;
    while (collectedCoins != 0)
    {
        collectedCoins = collectedCoins / 10;
        digits++;
    }
	OSReport("digits: %d\n\n\n", digits);
	OSReport("textCount: %s\n\n\n", textCount);
	coinCount->SetString(textCount, 0, 9);
}

int dStatsMenu_c::onExecute() {
	state.execute();

	layout.execAnimations();
	layout.update();

	return true;
}

int dStatsMenu_c::onDraw() {
	if (visible) {
		layout.scheduleForDrawing();
	}
	
	return true;
}

int dStatsMenu_c::onDelete() {
	instance = 0;
	OSReport("onDeleteeeeeeeeeeeeeeeeeeeee\n");
	if (StageC4::instance)
		StageC4::instance->_1D = 0; // disable no-pause

	return layout.free();
}



// Hidden
void dStatsMenu_c::beginState_Hidden() { }
void dStatsMenu_c::executeState_Hidden() { }
void dStatsMenu_c::endState_Hidden() { }

void dStatsMenu_c::beginState_WaitForWipe() { }
void dStatsMenu_c::executeState_WaitForWipe() { 
	if (count <= 0) state.setState(&StateID_ShowWait);
	else count--;
}
void dStatsMenu_c::endState_WaitForWipe() { }

void dStatsMenu_c::activate(int pScene, int pSceneParams, int pPowerupStoreType, int pWipe) {
	this->scene = pScene;
	this->sceneParams = pSceneParams;
	this->powerupStoreType = pPowerupStoreType;
	this->wipe = pWipe;
	

	if(powerupStoreType == LOSE_LEVEL) {
		//Buttons[2]->SetVisible(false);
		switchButtons(selected++, selected);
		Buttons[0]->trans = (Vec){100.0f, -100.0f, 0.0f};
		Buttons[1]->trans = (Vec){-100.0f, -100.0f, 0.0f};
		Buttons[2]->SetVisible(false);
	}
	
	state.setState(&StateID_WaitForWipe);
	this->wasActiveAlready = true;
}

// ShowWait
void dStatsMenu_c::beginState_ShowWait() {
	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_SYS_KO_DIALOGUE_IN, 1);

	layout.disableAllAnimations();
	layout.enableNonLoopAnim(ANIM_WINDOW_IN);
	visible = true;
	scaleEase = 0.0;
	StageC4::instance->_1D = 1; // enable no-pause
}
void dStatsMenu_c::executeState_ShowWait() {
	if (!layout.isAnimOn(ANIM_WINDOW_IN)) {
		if(powerupStoreType == BEAT_LEVEL) selected = 0;
		else                               selected = 1;
		layout.enableNonLoopAnim(ANIM_BUTTON_ON);
		layout.enableNonLoopAnim(ANIM_BUTTON_ON+1);
		layout.enableNonLoopAnim(ANIM_BUTTON_ON+2);
		state.setState(&StateID_CountdownWait);
	}
}
void dStatsMenu_c::endState_ShowWait() {
	nw4r::snd::SoundHandle handle;
	// PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_OBJ_CLOUD_BLOCK_TO_JUGEM, 1);
	
	//SaveBlock *save = GetSaveFile()->GetBlock(-1);
	//structWithWorldData = (int*)&(save->completions[0][0]);
	//OSReport("structWithWorldData: %x, %p", structWithWorldData, structWithWorldData);
	//OSReport("Star Coins: %d, %d, %d\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", CheckIfWeHaveASpecificStarCoin(structWithWorldData, CurrentWorld, CurrentLevel, COND_COIN1), CheckIfWeHaveASpecificStarCoin(structWithWorldData, CurrentWorld, CurrentLevel, COND_COIN2), CheckIfWeHaveASpecificStarCoin(structWithWorldData, CurrentWorld, CurrentLevel, COND_COIN3));
	//u32 conds = save->GetLevelCondition(CurrentWorld, CurrentLevel);

	setStats();
	
	timer = 1;
}

void dStatsMenu_c::beginState_CountdownWait() { }
void dStatsMenu_c::executeState_CountdownWait() { 
	wchar_t textCount[1];
	int nowPressed = Remocon_GetPressed(GetActiveRemocon());
	if(nowPressed == WPAD_TWO) {
		if(powerupStoreType == BEAT_LEVEL) goMap();
		else                               goAgain();
	} else if(nowPressed == WPAD_RIGHT) {
		//set new selected Button and go to Wait State
		textCount[0] = ' ';
		Countdown->SetString(textCount, 0, 3);
		
		if(powerupStoreType == BEAT_LEVEL) switchButtons(selected++, selected);
		else                               switchButtons(selected--, selected);
		
		state.setState(&StateID_Wait);
	} else if(nowPressed != 0) {
		textCount[0] = ' ';
		Countdown->SetString(textCount, 0, 3);
		state.setState(&StateID_Wait);
	}

	if (autoselectCountdown % 60 == 0) {
		textCount[0] = '0'+autoselectCountdown/60;
		Countdown->SetString(textCount, 0, 3);
		if (autoselectCountdown / 60 == 0) 
			if(powerupStoreType == BEAT_LEVEL) goMap();
			else                               goAgain();
	}
	autoselectCountdown--;
}
void dStatsMenu_c::endState_CountdownWait() { }


void dStatsMenu_c::goMap() { 
	ExitStage(WORLD_MAP, 0, BEAT_LEVEL, MARIO_WIPE);
}

void dStatsMenu_c::goAgain() { 
	RESTART_CRSIN_LevelStartStruct.screenType = ST_NORMAL;
	RESTART_CRSIN_LevelStartStruct.world1 = CurrentWorld;
	RESTART_CRSIN_LevelStartStruct.world2 = CurrentWorld;
	RESTART_CRSIN_LevelStartStruct.level1 = CurrentLevel;
	RESTART_CRSIN_LevelStartStruct.level2 = CurrentLevel;
	RESTART_CRSIN_LevelStartStruct.area = 0;
	RESTART_CRSIN_LevelStartStruct.entrance = 0xFF;
	RESTART_CRSIN_LevelStartStruct.isReplay = false;
	//DoSceneChange(RESTART_CRSIN, 0, 0);
	DontShowPreGame = true;
	ExitStage(RESTART_CRSIN, 0, powerupStoreType, MARIO_WIPE);	
}

void dStatsMenu_c::goReplay() { 
	RESTART_CRSIN_LevelStartStruct.screenType = ST_HINT_MOVIE;		//Otekara folder
	RESTART_CRSIN_LevelStartStruct.replayType = RT_SUPER_SKILLS;
	RESTART_CRSIN_LevelStartStruct.world1 = CurrentWorld;
	RESTART_CRSIN_LevelStartStruct.world2 = CurrentWorld;
	RESTART_CRSIN_LevelStartStruct.level1 = CurrentLevel;
	RESTART_CRSIN_LevelStartStruct.level2 = CurrentLevel;
	RESTART_CRSIN_LevelStartStruct.area = 0;
	RESTART_CRSIN_LevelStartStruct.entrance = 0xFF;
	RESTART_CRSIN_LevelStartStruct.isReplay = true;
	//DoSceneChange(RESTART_CRSIN, 0, 0);
	DontShowPreGame = true;
	ExitStage(RESTART_CRSIN, 0, powerupStoreType, MARIO_WIPE);
}

// Wait
void dStatsMenu_c::beginState_Wait() {
}
void dStatsMenu_c::executeState_Wait() {
	/*if (timer < 90) {
		scaleEase = -((cos(timer * 3.14 /20)-0.9)/timer*10)+1;
		timer++;
		return;
	}*/

	int nowPressed = Remocon_GetPressed(GetActiveRemocon());
	
	if (nowPressed & WPAD_RIGHT) {
		if(powerupStoreType == BEAT_LEVEL) {
			if(selected < 2) switchButtons(selected++, selected); 
		} else {
			if(selected > 0) switchButtons(selected--, selected); 
		}
	} else if (nowPressed & WPAD_LEFT) {
		if(powerupStoreType == BEAT_LEVEL) {
			if(selected > 0) switchButtons(selected--, selected);
		} else {
			if(selected < 1) switchButtons(selected++, selected);	
		}
	} else if (nowPressed & WPAD_TWO) {
		switch(selected) {
			case 0:
				goMap();
				break;
			case 1:
				goAgain();
				break;
			case 2:
				goReplay();
				break;
		}
		
	}

}
void dStatsMenu_c::endState_Wait() { }


#undef ANIM_WINDOW_IN
#undef ANIM_WINDOW_LOOP
#undef ANIM_WINDOW_OUT
#undef ANIM_BUTTON_HIT
#undef ANIM_BUTTON_IDLE
#undef ANIM_BUTTON_OFF
#undef ANIM_BUTTON_ON
//
// processed\../src/sceneGlue.cpp
//

#include <game.h>
#include <stage.h>

extern char CurrentLevel, CurrentWorld;
extern u8 MaybeFinishingLevel[2];
extern "C" void ExitStageReal(int scene, int sceneParams, int powerupStoreType, int wipe);
extern bool secretGemCollected;
extern bool secretGemAfterMidwayFlag;
extern float layerZPositionForByugoHack;

extern "C" void ExitStageWrapper(int scene, int sceneParams, int powerupStoreType, int wipe) {
	layerZPositionForByugoHack = -1800.0f;	//reset value to state before Ty-Foo --> doesn't work if e.g. a player uses a pipe at the same time, since that also makes the player switch to currentLayerID 2
	
	if(dStatsMenu_c::instance) {
		if(!dStatsMenu_c::instance->wasActiveAlready) {
			ActivateWipe(wipe);								//don't know why but this doesn't work here :thinking:
			dStatsMenu_c::instance->activate(scene, sceneParams, powerupStoreType, wipe);
			return;
		}
	}
	
	// TO RE-ENABLE CUTSCENES, UNCOMMENT THIS
	// if (scene == WORLD_MAP && powerupStoreType == BEAT_LEVEL) {
	// 	if (CurrentWorld == 6 && CurrentLevel == STAGE_DOOMSHIP) {
	// 		if (MaybeFinishingLevel[0] == 6 && MaybeFinishingLevel[1] == STAGE_DOOMSHIP) {
	// 			// We're done with 7-38
	// 			ExitStage(MOVIE, 0x10000000, powerupStoreType, wipe);
	// 			return;
	// 		}
	// 	}
	// }
	
	bool noCasualties = true;
	for(int i = 0; i < 4; i++) {
		//OSReport("Lives %p: %p\n", i, Player_Lives[i]);
		if(Player_Lives[i] == 0) {
			noCasualties = false;
			break;
		}
	}
	
	
	SaveBlock* save = GetSaveFile()->GetBlock(-1);
	//if(powerupStoreType == LOSE_LEVEL)	if(!secretGemAfterMidwayFlag) secretGemCollected = false;
	//if (secretGemCollected)				
	//secretGemCollected = false;
	
	OSReport("GMgrP: %d\n", GameMgrP->eight.checkpointEntranceID);
	
	if(powerupStoreType == LOSE_LEVEL) {
		if(secretGemAfterMidwayFlag) {
			secretGemCollected = false;
		} else {
			if(GameMgrP->eight.checkpointEntranceID == 255) {
				secretGemCollected = false;
			}
		}
	} else if(powerupStoreType == BEAT_LEVEL) {
		if(secretGemCollected) {
			secretGemAfterMidwayFlag = false;
			secretGemCollected = false;
			save->secretGems++;
		}
	}
	
	
	if(!(Remocon_GetButtons(GetActiveRemocon()) & WPAD_B) && noCasualties && scene == WORLD_MAP && powerupStoreType == LOSE_LEVEL) {
		RESTART_CRSIN_LevelStartStruct.screenType = ST_NORMAL;
		RESTART_CRSIN_LevelStartStruct.world1 = CurrentWorld;
		RESTART_CRSIN_LevelStartStruct.world2 = CurrentWorld;
		RESTART_CRSIN_LevelStartStruct.level1 = getActualLevelNum(CurrentLevel); //from 0.cpp
		RESTART_CRSIN_LevelStartStruct.level2 = getActualLevelNum(CurrentLevel);
		RESTART_CRSIN_LevelStartStruct.area = 0;
		RESTART_CRSIN_LevelStartStruct.entrance = 0xFF;
		RESTART_CRSIN_LevelStartStruct.isReplay = false; // load replay
		DoSceneChange(RESTART_CRSIN, 0, 0);
	}
	
	ExitStageReal(scene, sceneParams, powerupStoreType, wipe);
}


extern "C" void EnterOpeningLevel() {
	DontShowPreGame = true;
	RESTART_CRSIN_LevelStartStruct.screenType = ST_NORMAL;
	RESTART_CRSIN_LevelStartStruct.world1 = 1;
	RESTART_CRSIN_LevelStartStruct.world2 = 1;
	RESTART_CRSIN_LevelStartStruct.level1 = 40;
	RESTART_CRSIN_LevelStartStruct.level2 = 40;
	RESTART_CRSIN_LevelStartStruct.area = 0;
	RESTART_CRSIN_LevelStartStruct.entrance = 0xFF;
	RESTART_CRSIN_LevelStartStruct.isReplay = false; // load replay
	DoSceneChange(RESTART_CRSIN, 0, 0);
}


//
// processed\../src/levelinfo.cpp
//

#include "levelinfo.h"


dLevelInfo_c dLevelInfo_c::s_info;



void dLevelInfo_c::load(void *buffer) {
	data = (header_s*)buffer;

	// decode all the level names
	for (int sect = 0; sect < sectionCount(); sect++) {
		// parse this section
		section_s *thisSect = getSectionByIndex(sect);

		for (int lev = 0; lev < thisSect->levelCount; lev++) {
			entry_s *level = &thisSect->levels[lev];

			if (level->levelSlot < 42)
				SetSomeConditionShit(level->worldSlot, level->levelSlot, level->flags);

			char *name = (char*)getNameForLevel(level);

			/*for (int i = 0; i < level->nameLength+1; i++) {
				name[i] -= 0xD0;
			}*/
		}
	}
}

dLevelInfo_c::entry_s *dLevelInfo_c::searchBySlot(int world, int level) {
	for (int i = 0; i < sectionCount(); i++) {
		section_s *sect = getSectionByIndex(i);

		for (int j = 0; j < sect->levelCount; j++) {
			entry_s *entry = &sect->levels[j];
			if (entry->worldSlot == world && entry->levelSlot == level)
				return entry;
		}
	}

	return 0;
}

dLevelInfo_c::entry_s *dLevelInfo_c::searchByDisplayNum(int world, int level) {
	for (int i = 0; i < sectionCount(); i++) {
		section_s *sect = getSectionByIndex(i);

		for (int j = 0; j < sect->levelCount; j++) {
			entry_s *entry = &sect->levels[j];
			if (entry->displayWorld == world && entry->displayLevel == level)
				return entry;
		}
	}

	return 0;
}


void UpdateFSStars() {
	dLevelInfo_c *li = &dLevelInfo_c::s_info;
	SaveBlock *save = GetSaveFile()->GetBlock(-1);

	bool coinsNormal = true, exitsNormal = true;
	bool coinsW9 = true, exitsW9 = true;

	for (int i = 0; i < li->sectionCount(); i++) {
		dLevelInfo_c::section_s *sect = li->getSectionByIndex(i);

		for (int j = 0; j < sect->levelCount; j++) {
			dLevelInfo_c::entry_s *entry = &sect->levels[j];

			// Levels only
			if (!(entry->flags & 2))
				continue;

			u32 conds = save->GetLevelCondition(entry->worldSlot, entry->levelSlot);

			if (entry->displayWorld == 9) {
				if ((conds & COND_COIN_ALL) != COND_COIN_ALL)
					coinsW9 = false;
				if (entry->flags & 0x10)
					if (!(conds & COND_NORMAL))
						exitsW9 = false;
				if (entry->flags & 0x20)
					if (!(conds & COND_SECRET))
						exitsW9 = false;
			} else {
				if ((conds & COND_COIN_ALL) != COND_COIN_ALL)
					coinsNormal = false;
				if (entry->flags & 0x10)
					if (!(conds & COND_NORMAL))
						exitsNormal = false;
				if (entry->flags & 0x20)
					if (!(conds & COND_SECRET))
						exitsNormal = false;
			}
		}
	}

	bool beatGame = (save->GetLevelCondition(7, 23) & COND_NORMAL) != 0;

//	save->bitfield &= ~0x3E;
	save->bitfield &= ~0x3C;
	save->bitfield |=
//		(beatGame ? 2 : 0) |
		(exitsNormal ? 4 : 0) |
		(coinsNormal ? 8 : 0) |
		(exitsW9 ? 0x10 : 0) |
		(coinsW9 ? 0x20 : 0);

	OSReport("FS Stars updated: Status: Game beaten: %d, Normal exits: %d, Normal coins: %d, W9 exits: %d, W9 coins: %d\n", beatGame, exitsNormal, coinsNormal, exitsW9, coinsW9);
}


//
// processed\../src/pregame.cpp
//

#include <game.h>
#include <newer.h>

class PregameLytHandler {
	public:
		m2d::EmbedLayout_c layout;

		nw4r::lyt::Pane *rootPane;

		nw4r::lyt::TextBox
			*T_minus_00, *T_world_00, *T_worldNum_00,
			*T_pictureFont_00, *T_corseNum_00,
			*T_remainder_00, *T_remainder_01, *T_remainder_02, *T_remainder_03,
			*T_remainder_10, *T_remainder_11, *T_remainder_12, *T_remainder_13,
			*T_x_00, *T_x_01, *T_x_02, *T_x_03, *T_x_10, *T_x_11, *T_x_12, *T_x_13,
			*T_x_00_o, *T_x_10_o,
			*T_otasukePlay_00, *T_otasukePlay_01,
			*T_recommend_00, *T_remainder_00_o, *T_remainder_10_o;

		nw4r::lyt::Picture
			*P_Wx_00[9], *P_coin_00, *P_free_00,
			*P_batB_0x[4], *P_bat_00,
			*P_batB_1x[4], *P_bat_01,
			*P_batB_2x[4], *P_bat_02,
			*P_batB_3x[4], *P_bat_03,
			*P_luijiIcon_00_o, *P_luijiIcon_10_o, *P_coinStage_00;

		nw4r::lyt::Pane
			*N_mario_00, *N_luiji_00, *N_kinoB_01, *N_kinoY_00,
			*N_zankiPos_x[4], *N_zanki_00,
			*Null_battPosxP[4], *N_batt_x[4],
			*N_batt, *N_otasukePlay_00;

		u8 layoutLoaded, somethingHasBeenDone, isVisible, hasShownLuigiThing_orSomething;

		u32 currentStateID;

		u32 _2E8;

		u32 countdownToEndabilityCopy, activePlayerCountMultBy4_maybe;
		u32 batteryLevels[4];
		u32 pgCountdown;

		void hijack_loadLevelNumber(); // replaces 80B6BDD0
};

// Notes:
// Deleted; P_coinStage_00, T_recommend_00, T_worldNum_00,
// T_-_00, T_pictureFont_00, T_corseNum_00, T_world_00
// P_Wx_00, P_coin_00, P_free_00

extern char CurrentLevel;
extern char CurrentWorld;

void getNewerLevelNumberString(int world, int level, wchar_t *dest) {
	static const wchar_t *numberKinds[] = {
		// 0-19 are handled by code
		// To insert a picturefont character:
		// \x0B\x01YY\xZZZZ
		// YY is the character code, ZZZZ is ignored
		L"A", // 20, alternate
		L"\x0B\x0148\xBEEF", // 21, tower
		L"\x0B\x0148\xBEEF" L"2", // 22, tower 2
		L"\x0B\x012E\xBEEF", // 23, castle
		L"\x0B\x012F\xBEEF", // 24, fortress
		L"\x0B\x013D\xBEEF", // 25, final castle
		L"\x0B\x014D\xBEEF", // 26, train
		L"\x0B\x0132\xBEEF", // 27, airship
		L"Palace", // 28, switch palace
		L"\x0B\x0147\xBEEF", // 29, yoshi's house
		L"\x0B\x014E\xBEEF" L"1", // 30, key 1
		L"\x0B\x014E\xBEEF" L"2", // 31, key 2
		L"\x0B\x014E\xBEEF" L"3", // 32, key 3
		L"\x0B\x014E\xBEEF" L"4", // 33, key 4
		L"\x0B\x014E\xBEEF" L"5", // 34, key 5
		L"\x0B\x014E\xBEEF" L"6", // 35, key 6
		L"\x0B\x0138\xBEEF", // 36, music house
		L"\x0B\x0133\xBEEF", // 37, shop
		L"\x0B\x0139\xBEEF", // 38, challenge house
		L"\x0B\x0151\xBEEF", // 39, red switch palace
		L"\x0B\x0152\xBEEF", // 40, blue switch palace
		L"\x0B\x0153\xBEEF", // 41, yellow switch palace
		L"\x0B\x0154\xBEEF", // 42, green switch palace
	};

	dest[0] = (world >= 10) ? (world-10+'A') : (world+'0');
	dest[1] = '-';
	if (level >= 20) {
		wcscpy(&dest[2], numberKinds[level-20]);
	} else if (level >= 10) {
		dest[2] = '1';
		dest[3] = ('0' - 10) + level;
		dest[4] = 0;
	} else {
		dest[2] = '0' + level;
		dest[3] = 0;
	}
}

void LoadPregameStyleNameAndNumber(m2d::EmbedLayout_c *layout) {
	nw4r::lyt::TextBox
		*LevelNumShadow, *LevelNum,
		*LevelNameShadow, *LevelName;

	LevelNumShadow = layout->findTextBoxByName("LevelNumShadow");
	LevelNum = layout->findTextBoxByName("LevelNum");
	LevelNameShadow = layout->findTextBoxByName("LevelNameShadow");
	LevelName = layout->findTextBoxByName("LevelName");

	// work out the thing now
	dLevelInfo_c::entry_s *level = dLevelInfo_c::s_info.searchBySlot(CurrentWorld, getActualLevelNum(CurrentLevel));
	if (level) {
		wchar_t convLevelName[160];
		const char *srcLevelName = dLevelInfo_c::s_info.getNameForLevel(level);
		int i = 0;
		while (i < 159 && srcLevelName[i]) {
			convLevelName[i] = srcLevelName[i];
			i++;
		}
		convLevelName[i] = 0;
		LevelNameShadow->SetString(convLevelName);
		LevelName->SetString(convLevelName);

		wchar_t levelNumber[32];
		wcscpy(levelNumber, L"World ");
		getNewerLevelNumberString(level->displayWorld, level->displayLevel, &levelNumber[6]);

		LevelNum->SetString(levelNumber);

		// make the picture shadowy
		int sidx = 0;
		while (levelNumber[sidx]) {
			if (levelNumber[sidx] == 11) {
				levelNumber[sidx+1] = 0x200 | (levelNumber[sidx+1]&0xFF);
				sidx += 2;
			}
			sidx++;
		}
		LevelNumShadow->SetString(levelNumber);

	} else {
		LevelNameShadow->SetString(L"Not found in LevelInfo!");
		LevelName->SetString(L"Not found in LevelInfo!");
	}
}

#include "fileload.h"
void PregameLytHandler::hijack_loadLevelNumber() {
	LoadPregameStyleNameAndNumber(&layout);

	nw4r::lyt::Picture *LevelSample;
	LevelSample = layout.findPictureByName("LevelSample");

	// this is not the greatest way to read a file but I suppose it works in a pinch
	char tplName[64];
	sprintf(tplName, "/LevelSamples/%02d-%02d.tpl", CurrentWorld+1, getActualLevelNum(CurrentLevel)+1);
	static File tpl;
	if (tpl.open(tplName)) {
		LevelSample->material->texMaps[0].ReplaceImage((TPLPalette*)tpl.ptr(), 0);
	}
}





//
// processed\../src/randtiles.cpp
//

#include <game.h>

class RandomTileData {
public:
	enum Type {
		CHECK_NONE = 0,
		CHECK_HORZ = 1,
		CHECK_VERT = 2,
		CHECK_BOTH = 3
	};

	enum Special {
		SP_NONE = 0,
		SP_VDOUBLE_TOP = 1,
		SP_VDOUBLE_BOTTOM = 2
	};

	class NameList {
	public:
		u32 count;
		u32 offsets[1]; // variable size

		const char *getName(int index) {
			return ((char*)this) + offsets[index];
		}

		bool contains(const char *name) {
			for (int i = 0; i < count; i++) {
				if (strcmp(name, getName(i)) == 0)
					return true;
			}

			return false;
		}
	};

	class Entry {
	public:
		u8 lowerBound, upperBound;
		u8 count, type;
		u32 tileNumOffset;

		u8 *getTileNums() {
			return ((u8*)this) + tileNumOffset;
		}
	};

	class Section {
	public:
		u32 nameListOffset;
		u32 entryCount;
		Entry entries[1]; // variable size

		NameList *getNameList() {
			return (NameList*)(((u32)this) + nameListOffset);
		}
	};

	u32 magic;
	u32 sectionCount;
	u32 offsets[1]; // variable size

	Section *getSection(int id) {
		return (Section*)(((char*)this) + offsets[id]);
	}

	Section *getSection(const char *name);

	static RandomTileData *instance;
};

class RTilemapClass : public TilemapClass {
public:
	// NEWER ADDITIONS
	RandomTileData::Section *sections[4];
};

RandomTileData::Section *RandomTileData::getSection(const char *name) {
	for (int i = 0; i < sectionCount; i++) {
		RandomTileData::Section *sect = getSection(i);

		if (sect->getNameList()->contains(name))
			return sect;
	}

	return 0;
}


// Real tile handling code

RandomTileData *RandomTileData::instance = 0;

dDvdLoader_c s_levelInfoLoader;
bool s_levelInfoLoaded = false;
dDvdLoader_c RandTileLoader;

// This is a bit hacky but I'm lazy
bool LoadLevelInfo() {
	if (s_levelInfoLoaded)
		return true;

	void *data = s_levelInfoLoader.load("/NewerRes/LevelInfo.bin");
	if (data) {
		dLevelInfo_c::s_info.load(data);
		s_levelInfoLoaded = true;
		return true;
	}

	return false;
}

extern "C" bool RandTileLoadHook() {
	// OSReport("Trying to load...");
	void *buf = RandTileLoader.load("/NewerRes/RandTiles.bin");
	bool LIresult = LoadLevelInfo();
	if (buf == 0) {
		// OSReport("Failed.\n");
		return false;
	} else {
		// OSReport("Successfully loaded RandTiles.bin [%p].\n", buf);
		RandomTileData::instance = (RandomTileData*)buf;
		return LIresult;
	}
}


extern "C" void IdentifyTilesets(RTilemapClass *self) {
	self->_C0C = 0xFFFFFFFF;

	for (int i = 0; i < 4; i++) {
		const char *tilesetName = BGDatClass::instance->getTilesetName(self->areaID, i);

		self->sections[i] = RandomTileData::instance->getSection(tilesetName);
		// OSReport("[%d] Chose %p for %s\n", i, self->sections[i], tilesetName);
	}
}

extern "C" void TryAndRandomise(RTilemapClass *self, BGRender *bgr) {
	int fullTile = bgr->tileToPlace & 0x3FF;
	int tile = fullTile & 0xFF;
	int tileset = fullTile >> 8;

	RandomTileData::Section *rtSect = self->sections[tileset];
	if (rtSect == 0)
		return;

	for (int i = 0; i < rtSect->entryCount; i++) {
		RandomTileData::Entry *entry = &rtSect->entries[i];

		if (tile >= entry->lowerBound && tile <= entry->upperBound) {
			// Found it!!
			// Try to make one until we meet the conditions
			u8 type = entry->type & 3;
			u8 special = entry->type >> 2;

			u8 *tileNums = entry->getTileNums();
			u16 chosen = 0xFF;

			// If it's the top special, then ignore this tile, we'll place that one
			// once we choose the bottom one
			if (special == RandomTileData::SP_VDOUBLE_TOP)
				break;

			u16 *top = 0, *left = 0, *right = 0, *bottom = 0;
			if (type == RandomTileData::CHECK_HORZ || type == RandomTileData::CHECK_BOTH) {
				left = self->getPointerToTile((bgr->curX - 1) * 16, bgr->curY * 16);
				right = self->getPointerToTile((bgr->curX + 1) * 16, bgr->curY * 16);
			}

			if (type == RandomTileData::CHECK_VERT || type == RandomTileData::CHECK_BOTH) {
				top = self->getPointerToTile(bgr->curX * 16, (bgr->curY - 1) * 16);
				bottom = self->getPointerToTile(bgr->curX * 16, (bgr->curY + 1) * 16);
			}

			int attempts = 0;
			while (true) {
				// is there even a point to using that special random function?
				chosen = (tileset << 8) | tileNums[MakeRandomNumberForTiles(entry->count)];

				// avoid infinite loops
				attempts++;
				if (attempts > 5)
					break;

				if (top != 0 && *top == chosen)
					continue;
				if (bottom != 0 && *bottom == chosen)
					continue;
				if (left != 0 && *left == chosen)
					continue;
				if (right != 0 && *right == chosen)
					continue;
				break;
			}

			bgr->tileToPlace = chosen;

			if (special == RandomTileData::SP_VDOUBLE_BOTTOM) {
				if (top == 0)
					top = self->getPointerToTile(bgr->curX * 16, (bgr->curY - 1) * 16);

				*top = (chosen - 0x10);
			}

			return;
		}
	}
}



//
// processed\../src/layouthax.cpp
//

#include <game.h>

void LoadPregameStyleNameAndNumber(m2d::EmbedLayout_c *layout);
extern "C" void InsertPauseWindowText(void *thing) {
	m2d::EmbedLayout_c *el = (m2d::EmbedLayout_c*)(((u8*)thing)+0x70);
	LoadPregameStyleNameAndNumber(el);
}


//
// processed\../src/objkinoko.cpp
//

#include <game.h>
#include <g3dhax.h>


class SomethingAboutShrooms {
	public:
		m3d::mdl_c models[3];
		float scale, _C4, offsetToEdge;
		m3d::anmTexPat_c animations[3];

		struct info_s {
			const char *leftName;
			const char *middleName;
			const char *rightName;
			float size; // 8 for small, 16 for big
			const char *lrName;
			const char *middleNameAgain;
		};

		void setup(mAllocator_c *allocator,
				nw4r::g3d::ResFile *resFile, info_s *info,
				float length, float colour, float scale);

		// plus more methods I don't know

		void drawWithMatrix(float yOffset, mMtx *matrix);
};


class dRotatorThing_c {
	public:
		s16 _p5, output, _p1, _p2, _p3;
		s16 _p6, _p7, _p0;
		u32 someBool;

		void setup(s16 a, s16 b, s16 c, s16 d, s16 initialRotation, s16 f, s16 g, s16 h);
		s16 execute();
};


class daObjKinoko_c : public dStageActor_c {
	public:
		mHeapAllocator_c allocator;
		nw4r::g3d::ResFile resFile;
		SomethingAboutShrooms renderer;
		StandOnTopCollider colliders[3];
		dRotatorThing_c xRotator;
		dRotatorThing_c zRotator;
		u8 thickness, touchCompare;

		void loadModels(int thickness, float length, float colour, float scale);
		void addAllColliders();
		void updateAllColliders();
		void removeAllColliders();
		u8 checkIfTouchingObject();

		int onCreate();
		int onExecute();
		int onDraw();
		int onDelete();

		int creationHook();
		int drawHook();

		int original_onCreate();

		~daObjKinoko_c();
};


// This will replace Nintendo's onCreate
int daObjKinoko_c::creationHook() {
	original_onCreate();

	// if rotation is off, do nothing else
	if (!((settings >> 28) & 1))
		return 1;

	// OK, figure out the rotation
	u8 sourceRotation = (settings >> 24) & 0xF;

	// 0 is up. -0x4000 is right, 0x4000 is left ...
	s16 rotation;

	// We'll flip it later.
	// Thus: 0..7 rotates left (in increments of 0x800),
	// 8..15 rotates right (in increments of 0x800 too).
	// To specify facing up, well.. just use 0.

	if (sourceRotation < 8)
		rotation = (sourceRotation * 0x800) - 0x4000;
	else
		rotation = (sourceRotation * 0x800) - 0x3800;

	rotation = -rotation;

	rot.z = rotation;

	/* Original code: */
	int lengthInTiles = settings & 0xF;

	float sizeMult = (thickness == 1) ? 1.0f : 0.5f;
	float length = sizeMult * ((32.0f + (lengthInTiles * 16.0f)) - 16.0f);

	float topPos = (sizeMult * 16.0f);

	float cosThing = nw4r::math::CosFIdx((lengthInTiles * 16.0f) / 256.0f);
	float anotherThing = (4.0f + topPos) / cosThing;

	// Middle Collider
	colliders[0].init(this,
			/*xOffset=*/0.0f, /*yOffset=*/0.0f,
			/*topYOffset=*/topPos,
			/*rightSize=*/length, /*leftSize=*/-length,
			/*rotation=*/rotation, /*_45=*/1
			);

	colliders[0]._47 = 0;
	colliders[0].flags = 0x80180 | 0xC00;

	// Now get the info to move the colliders by ....
	float rotFIdx = ((float)rotation) / 256.0f;
	float sinRot, cosRot;
	nw4r::math::SinCosFIdx(&sinRot, &cosRot, rotFIdx);
	//OSReport("Rotation is %d, so rotFIdx is %f\n", rotation, rotFIdx);
	//OSReport("Sin: %f, Cos: %f\n", sinRot, cosRot);
	
	float leftXOffs = (cosRot * -length) - (sinRot * topPos);
	float leftYOffs = (sinRot * -length) + (cosRot * topPos);
	float rightXOffs = (cosRot * length) - (sinRot * topPos);
	float rightYOffs = (sinRot * length) + (cosRot * topPos);
	//OSReport("leftXOffs: %f, leftYOffs: %f\n", leftXOffs, leftYOffs);
	//OSReport("rightXOffs: %f, rightYOffs: %f\n", rightXOffs, rightYOffs);

	// Right Collider
	colliders[1].init(this,
			/*xOffset=*/rightXOffs, /*yOffset=*/rightYOffs,
			/*topYOffset=*/0.0f,
			/*rightSize=*/anotherThing, /*leftSize=*/0.0f,
			/*rotation=*/rotation - 0x2000, /*_45=*/1
			);

	colliders[1]._47 = 0;
	colliders[1].flags = 0x80100 | 0x800;

	// Left Collider
	colliders[2].init(this,
			/*xOffset=*/leftXOffs, /*yOffset=*/leftYOffs,
			/*topYOffset=*/0.0f,
			/*rightSize=*/0.0f, /*leftSize=*/-anotherThing,
			/*rotation=*/rotation + 0x2000, /*_45=*/1
			);

	colliders[2]._47 = 0;
	colliders[2].flags = 0x80080 | 0x400;

	return 1;
}


// This will replace Nintendo's onDraw
int daObjKinoko_c::drawHook() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationZ(&rot.z);
	matrix.applyRotationX(&xRotator.output);
	matrix.applyRotationZ(&zRotator.output);
	renderer.drawWithMatrix(0.0f, &matrix);

	return 1;
}



//
// processed\../src/tilegod.cpp
//

#include <game.h>
#include <sfx.h>

//#define REIMPLEMENT

extern "C" bool SpawnEffect(const char*, int, Vec*, S16Vec*, Vec*);

class daChengeBlock_c : public dStageActor_c {
	static daChengeBlock_c *build();

	u32 _394;
	u64 initialFlags;

	enum Action { Destroy, Create };
	enum Pattern { Fill, CheckerA, CheckerB };

	int width, height;
	Action action;
	int blockType;
	int isPermanent;
	Pattern pattern;
	u16 hasTriggered;

	u32 _3BC;


	int onCreate();
	int onExecute();

	void doStuff(Action action, bool wasCalledOnCreation);
	void tryToTrigger();
};

#ifdef REIMPLEMENT
daChengeBlock_c *daChengeBlock_c::build() {
	return new(AllocFromGameHeap1(sizeof(daChengeBlock_c))) daChengeBlock_c;
}



int daChengeBlock_c::onCreate() { //So IDK if it's a treeki error or not but this actually isn't executed and the original onCreate is used
	hasTriggered = 0;

	height = settings & 0xF;
	width = (settings & 0xF0) >> 4;
	blockType = (settings & 0xF000) >> 12;
	pattern = (Pattern)((settings & 0x30000) >> 16);
	isPermanent = (settings & 0xF0000000) >> 28;

	if (width == 0)
		width++;
	if (height == 0)
		height++;

	action = (Action)((settings & 0xF00) >> 8);

	initialFlags = dFlagMgr_c::instance->flags & dStageActor_c::creatingFlagMask;

	if (initialFlags) {
		if (action == Destroy) {
			doStuff(Destroy, true);
		} else {
			doStuff(Create, true);
			hasTriggered = true;
		}

		if (isPermanent)
			return 2;
	}

	return 1;
}


int daChengeBlock_c::onExecute() {
	tryToTrigger();

	if (!hasTriggered)
		checkZoneBoundaries(0);

	return 1;
}


#endif // REIMPLEMENT

// Red, Brick, Blank/Unused, Stone, Wood, Blank
static const u16 Tiles[] = {124, 2, 12, 123, 15, 0};

void daChengeBlock_c::doStuff(Action action, bool wasCalledOnCreation) { 
	int actualPattern = (settings & 0x20000) ? CheckerB : ((settings & 0x10000) ? CheckerA : Fill);
	u16 perTilePatternFlag = 1, perRowPatternFlag = 1;

	u16 worldX = ((u16)pos.x) & 0xFFF0;
	u16 baseWorldX = worldX;
	u16 worldY = ((u16)(-pos.y)) & 0xFFF0;

	if (actualPattern == CheckerB) {
		perTilePatternFlag = 0;
		perRowPatternFlag = 0;
	}

	u16 tile;
	if (action != Destroy) {
		if (blockType & 8) {
			// Specify a tile number
			tile = 0x8000 | ((blockType & 3) << 8) | ((settings & 0xFF00000) >> 20);
		} else {
			// fall through
			tile = Tiles[blockType];
		}
	} else {
		tile = 0;
	}

	for (u16 y = 0; y < height; y++) {
		for (u16 x = 0; x < width; x++) {
			if (perTilePatternFlag) {
				u16 *pExistingTile = dBgGm_c::instance->getPointerToTile(worldX, worldY, currentLayerID);
				u16 existingTile = pExistingTile ? *pExistingTile : 0;
				//OSReport("tile: %X; WY=%d\n", tile, worldY);
				dBgGm_c::instance->placeTile(worldX, worldY, currentLayerID, tile);

				if (!wasCalledOnCreation) {
					Vec effectPos;

					if (action == Destroy) {
						if (blockType != 2) {
							effectPos.x = ((float)(worldX)) + 8.0f;
							effectPos.y = ((float)(-worldY)) - 8.0f;
							effectPos.z = pos.z;

							u16 shardType;
							switch (existingTile) {
								case 0x30: shardType = 0; break;
								case 0x31: shardType = 3; break;
								case 0x32: shardType = 4; break;
								case 0x33: shardType = 2; break;
								case 0x34: shardType = 1; break;
								case 0x37: shardType = 5; break;
								default: shardType = 0xFFFF;
							}

							if (!(settings & 0x40000)) {
								if (shardType == 0xFFFF) {
									SpawnEffect("Wm_en_burst_ss", 0, &effectPos, 0, 0);
								} else {
									u32 sets = (shardType << 8) | 3;
									effectPos.y -= 8;
									dEffectBreakMgr_c::instance->spawnTile(&effectPos, sets, 0);
								}
							}

							if (!(settings & 0x80000)) {
								Vec2 soundPos;
								ConvertStagePositionToScreenPosition(&soundPos, &effectPos);
								SoundPlayingClass::instance2->PlaySoundAtPosition(SE_OBJ_BLOCK_BREAK, &soundPos, 0);
							}
						}
					} else {
						effectPos.x = ((float)(worldX)) + 8.0f;
						effectPos.y = ((float)(-worldY)) - 8.0f;
						effectPos.z = pos.z;

						if (!(settings & 0x40000)) {
							if (blockType != 2) {
								SpawnEffect("Wm_en_burst_ss", 0, &effectPos, 0, 0);
							}
						}
					}
				}
			}

			if (actualPattern != Fill) {
				perTilePatternFlag ^= 1;
			}

			worldX += 16;
		}

		if (actualPattern != Fill) {
			perRowPatternFlag ^= 1;
			perTilePatternFlag = perRowPatternFlag;
		}

		worldX = baseWorldX;
		worldY += 16;
	}
}


#ifdef REIMPLEMENT
void daChengeBlock_c::tryToTrigger() {
	u64 result = spriteFlagMask & dFlagMgr_c::instance->flags;

	if (action == Destroy) {
		if (result & initialFlags) {
			if (result) {
				doStuff(Destroy, false);
				hasTriggered = true;
			} else {
				doStuff(Create, false);
				hasTriggered = false;
			}

			initialFlags = result;

			if (isPermanent)
				fBase_c::Delete();
		}
	} else {
		if (result & initialFlags) {
			if (result) {
				doStuff(Create, false);
				hasTriggered = true;
			} else {
				doStuff(Destroy, false);
				hasTriggered = false;
			}

			initialFlags = result;

			if (isPermanent)
				fBase_c::Delete();
		}
	}
}
#endif


//
// processed\../src/linegod.cpp
//

#include <common.h>
#include <game.h>

// TODO: make "No Deactivation"

struct BgActor {
	u16 def_id;		// 0x00
	u16 x;			// 0x02
	u16 y;			// 0x04
	u8 layer;		// 0x06
	u8 EXTRA_off;	// 0x07
	u32 actor_id;	// 0x08
};

struct BgActorDef {
	u32 tilenum;
	u16 actor;
	u8 _06[2];
	float x;
	float y;
	float z;
	float width;
	float height;
	u32 extra_var;
};

struct dBgActorManager_c {
	u32 vtable;		// 0x00
	u8 _04[0x34];	// 0x04
	BgActor *array;	// 0x38
	u32 count;		// 0x3C
	u32 type;		// 0x40
};

extern dBgActorManager_c *dBgActorManager;

extern BgActorDef *BgActorDefs;

struct BG_GM_hax {
	u8 _00[0x8FE64];
	float _0x8FE64;
	float _0x8FE68;
	float _0x8FE6C;
	float _0x8FE70;
};

extern BG_GM_hax *BG_GM_ptr;

// Regular class is 0x3D0.
// Let's add stuff to the end just to be safe.
// Size is now 0x400
// 80898798 38600400

#define LINEGOD_FUNC_ACTIVATE	0
#define LINEGOD_FUNC_DEACTIVATE	1

struct LineGod {
	u32 id;			// 0x00
	u32 settings;	// 0x04
	u16 name;		// 0x08
	u8 _0A[6];		// 0x0A
	u8 _10[0x9C];	// 0x10
	float x;		// 0xAC
	float y;		// 0xB0
	float z;		// 0xB4
	u8 _B8[0x318];	// 0xB8
	u64 eventFlag;	// 0x3D0
	u8 func;		// 0x3D4
	u8 width;		// 0x3D5
	u8 height;		// 0x3D6
	u8 lastEvState;	// 0x3D7
	BgActor *ac[8];	// 0x3D8
};


fBase_c *FindActorByID(u32 id);

u16 *GetPointerToTile(BG_GM_hax *self, u16 x, u16 y, u16 layer, short *blockID_p, bool unused);



void LineGod_BuildList(LineGod *self);
bool LineGod_AppendToList(LineGod *self, BgActor *ac);
void LineGod_Update(LineGod *self);


bool LineGod_Create(LineGod *self) {
	char eventNum	= (self->settings >> 24)	& 0xFF;
	self->eventFlag = (u64)1 << (eventNum - 1);
	
	
	
	self->func		= (self->settings)			& 1;
	self->width		= (self->settings >> 4)		& 15;
	self->height	= (self->settings >> 8)		& 15;
	
	self->lastEvState = 0xFF;
	
	LineGod_BuildList(self);
	LineGod_Update(self);
	
	return true;
}

bool LineGod_Execute(LineGod *self) {
	LineGod_Update(self);
	return true;
}

void LineGod_BuildList(LineGod *self) {
	for (int clearIdx = 0; clearIdx < 8; clearIdx++) {
		self->ac[clearIdx] = 0;
	}
	
	

	float gLeft = self->x - (BG_GM_ptr->_0x8FE64 - fmod(BG_GM_ptr->_0x8FE64, 16));
	float gTop = self->y - (BG_GM_ptr->_0x8FE6C - fmod(BG_GM_ptr->_0x8FE6C, 16));

	// 1 unit padding to avoid catching stuff that is not in our rectangle
	Vec grect1 = (Vec){
		gLeft + 1, gTop - (self->height * 16) + 1, 0
	};

	Vec grect2 = (Vec){
		gLeft + (self->width * 16) - 1, gTop - 1, 0
	};

	
	for (int i = 0; i < dBgActorManager->count; i++) {
		BgActor *ac = &dBgActorManager->array[i];

		// the Def width/heights are padded with 8 units on each side
		// except for one of the steep slopes, which differs for no reason

		BgActorDef *def = &BgActorDefs[ac->def_id];
		float aXCentre = (ac->x * 16) + def->x;
		float aYCentre = (-ac->y * 16) + def->y;

		float xDistToCentre = (def->width - 16) / 2;
		float yDistToCentre = (def->height - 16) / 2;

		Vec arect1 = (Vec){
			aXCentre - xDistToCentre, aYCentre - yDistToCentre, 0
		};
		
		Vec arect2 = (Vec){
			aXCentre + xDistToCentre, aYCentre + yDistToCentre, 0
		};

		if (RectanglesOverlap(&arect1, &arect2, &grect1, &grect2))
			LineGod_AppendToList(self, ac);
	}
}

bool LineGod_AppendToList(LineGod *self, BgActor *ac) {
	
	for (int search = 0; search < 8; search++) {
		if (self->ac[search] == 0) {
			self->ac[search] = ac;
			return true;
		}
	}
	
	return false;
}

void LineGod_Update(LineGod *self) {
	
	u8 newEvState = 0;
	if (dFlagMgr_c::instance->flags & self->eventFlag)
		newEvState = 1;
	
	if (newEvState == self->lastEvState)
		return;
	
	u16 x_bias = (BG_GM_ptr->_0x8FE64 / 16);
	u16 y_bias = -(BG_GM_ptr->_0x8FE6C / 16);
	
	
	u8 offState;
	if (self->func == LINEGOD_FUNC_ACTIVATE)
		offState = (newEvState == 1) ? 1 : 0;
	else
		offState = (newEvState == 1) ? 0 : 1;
	
	
	for (int i = 0; i < 8; i++) {
		if (self->ac[i] != 0) {
			BgActor *ac = self->ac[i];
			
			
			ac->EXTRA_off = offState;
			if (offState == 1 && ac->actor_id != 0) {
				fBase_c *assoc_ac = FindActorByID(ac->actor_id);
				if (assoc_ac != 0)
					assoc_ac->Delete();
				ac->actor_id = 0;
			}
			
			u16 *tile = GetPointerToTile(BG_GM_ptr, (ac->x + x_bias) * 16, (ac->y + y_bias) * 16, 0, 0, 0);
			if (offState == 1)
				*tile = 0;
			else
				*tile = BgActorDefs[ac->def_id].tilenum;
			
		}
	}
	
	
	
	self->lastEvState = newEvState;
}

//
// processed\../src/tilesetfixer.cpp
//

#include <common.h>
#include <game.h>

const char *GetTilesetName(void *cls, int areaNum, int slotNum);

void DoFixes(int areaNumber, int slotNumber);
void SwapObjData(u8 *data, int slotNumber);

extern "C" void *OriginalTilesetLoadingThing(void *, void *, int, int);

// Main hook
void *TilesetFixerHack(void *cls, void *heap, int areaNum, int layerNum) {
	if (layerNum == 0) {
		for (int i = 1; i < 4; i++) {
			DoFixes(areaNum, i);
		}
	}

	return OriginalTilesetLoadingThing(cls, heap, areaNum, layerNum);
}



// File format definitions
struct ObjLookupEntry {
	u16 offset;
	u8 width;
	u8 height;
};


void DoFixes(int areaNumber, int slotNumber) {
	// This is where it all starts
	const char *tsName = GetTilesetName(BGDatClass, areaNumber, slotNumber);

	if (tsName == 0 || tsName[0] == 0) {
		return;
	}


	char untHDname[64], untname[64];
	snprintf(untHDname, 64, "BG_unt/%s_hd.bin", tsName);
	snprintf(untname, 64, "BG_unt/%s.bin", tsName);

	u32 unt_hd_length;
	void *bg_unt_hd_data = DVD_GetFile(GetDVDClass2(), tsName, untHDname, &unt_hd_length);
	void *bg_unt = DVD_GetFile(GetDVDClass2(), tsName, untname);


	ObjLookupEntry *lookups = (ObjLookupEntry*)bg_unt_hd_data;

	int objCount = unt_hd_length / sizeof(ObjLookupEntry);

	for (int i = 0; i < objCount; i++) {
		// process each object
		u8 *thisObj = (u8*)((u32)bg_unt + lookups[i].offset);

		SwapObjData(thisObj, slotNumber);
	}
}


void SwapObjData(u8 *data, int slotNumber) {
	// rudimentary parser which will hopefully work

	while (*data != 0xFF) {
		u8 cmd = *data;

		if (cmd == 0xFE || (cmd & 0x80) != 0) {
			data++;
			continue;
		}

		if ((data[2] & 3) != 0) {
			data[2] &= 0xFC;
			data[2] |= slotNumber;
		}
		data += 3;
	}

}


//
// processed\../src/exitEvent.cpp
//

#include <game.h>
#include <stage.h>
#include "msgbox.h"

const char *ExitEventFileList[] = {"OpeningScene", 0};

class dExitEvent_c : public dStageActor_c {
	public:
		static dActor_c *build();

		bool hasBeenActivated;
		bool hasExitedStage;
		int onExecute();
};

/*****************************************************************************/
// Glue Code
dActor_c *dExitEvent_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dExitEvent_c));
	dExitEvent_c *c = new(buffer) dExitEvent_c;
	return c;
}

const SpriteData ExitEventSpriteData = { ProfileId::ExitEvent, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile ExitEventProfile(&dExitEvent_c::build, SpriteId::ExitEvent, ExitEventSpriteData, ProfileId::ExitEvent, ProfileId::ExitEvent, "ExitEvent", ExitEventFileList);


int dExitEvent_c::onExecute() {
	if (dFlagMgr_c::instance->flags & spriteFlagMask) {
		if (!hasBeenActivated) {
//			OSReport("Activating Palace Dude\n");
			hasBeenActivated = true;

			int delay;
			if (!(settings & 0xF000000)) {
				delay = 270;
				StopBGMMusic();
				SaveBlock *save = GetSaveFile()->GetBlock(-1);
				GameMgrP->switchPalaceFlag |= (1 << (settings >> 28));
			} else {
				delay = 1020;
			}

			dMsgBoxManager_c::instance->showMessage(
				settings & 0xFFFFFF, // message ID
				false, // cannot cancel
				delay // delay
				);
		}
	}

	if (hasBeenActivated) {
		if (hasExitedStage)
			return true;
//		OSReport("Palace Dude is activated, %d\n", dMsgBoxManager_c::instance->visible);
		if (!dMsgBoxManager_c::instance->visible) {
//			OSReport("Exiting\n");
			u32 wmsettings = 0;
			if (settings & 0xF000000) {
				SaveGame(0, false);
				wmsettings = 0x80000000;
			}
			SaveGame(0, true);
			ExitStage(WORLD_MAP, wmsettings, BEAT_LEVEL, MARIO_WIPE);
			hasExitedStage = true;
		}
	}

	return true;

}



//
// processed\../src/eventblock.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

// Patches MIST_INTERMITTENT (sprite 239)

class daEnEventBlock_c : public daEnBlockMain_c {
public:
	enum Mode {
		TOGGLE_EVENT = 0,
		SWAP_EVENTS = 1
	};

	TileRenderer tile;
	Physics::Info physicsInfo;

	u8 event1;
	u8 event2;
	Mode mode;

	void equaliseEvents();

	int onCreate();
	int onDelete();
	int onExecute();

	void calledWhenUpMoveExecutes();
	void calledWhenDownMoveExecutes();

	void blockWasHit(bool isDown);

	USING_STATES(daEnEventBlock_c);
	DECLARE_STATE(Wait);

	static dActor_c *build();
};


const char *EventBlockFileList[] = {0};
const SpriteData eventBlockSpriteData = { ProfileId::EventBlock, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile eventBlockProfile(&daEnEventBlock_c::build, SpriteId::EventBlock, eventBlockSpriteData, ProfileId::MIST_INTERMITTENT, ProfileId::EventBlock, "EventBlock", EventBlockFileList);


CREATE_STATE(daEnEventBlock_c, Wait);


int daEnEventBlock_c::onCreate() {
	blockInit(pos.y);

	physicsInfo.x1 = -8;
	physicsInfo.y1 = 16;
	physicsInfo.x2 = 8;
	physicsInfo.y2 = 0;

	physicsInfo.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.flagsMaybe = 0x260;
	physics.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics.addToList();

	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->add(&tile);

	tile.x = pos.x - 8;
	tile.y = -(16 + pos.y);
	tile.tileNumber = 0x97;

	mode = (Mode)((settings >> 16) & 0xF);
	event1 = ((settings >> 8) & 0xFF) - 1;
	event2 = (settings & 0xFF) - 1;

	equaliseEvents();

	doStateChange(&daEnEventBlock_c::StateID_Wait);

	return true;
}


int daEnEventBlock_c::onDelete() {
	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->remove(&tile);

	physics.removeFromList();

	return true;
}


int daEnEventBlock_c::onExecute() {
	acState.execute();
	physics.update();
	blockUpdate();

	tile.setPosition(pos.x-8, -(16+pos.y), pos.z);
	tile.setVars(scale.x);

	equaliseEvents();

	bool isActive = dFlagMgr_c::instance->active(event2);

	tile.tileNumber = (isActive ? 0x96 : 0x97);

	// now check zone bounds based on state
	if (acState.getCurrentState()->isEqual(&StateID_Wait)) {
		checkZoneBoundaries(0);
	}

	return true;
}


dActor_c *daEnEventBlock_c::build() {

	void *buffer = AllocFromGameHeap1(sizeof(daEnEventBlock_c));
	daEnEventBlock_c *c = new(buffer) daEnEventBlock_c;


	return c;
}


void daEnEventBlock_c::equaliseEvents() {
	if (mode != SWAP_EVENTS)
		return;

	bool f1 = dFlagMgr_c::instance->active(event1);
	bool f2 = dFlagMgr_c::instance->active(event2);

	if (!f1 && !f2) {
		dFlagMgr_c::instance->set(event1, 0, true, false, false);
	}

	if (f1 && f2) {
		dFlagMgr_c::instance->set(event2, 0, false, false, false);
	}
}


void daEnEventBlock_c::blockWasHit(bool isDown) {
	pos.y = initialY;

	if (mode == TOGGLE_EVENT) {
		if (dFlagMgr_c::instance->active(event2))
			dFlagMgr_c::instance->set(event2, 0, false, false, false);
		else
			dFlagMgr_c::instance->set(event2, 0, true, false, false);

	} else if (mode == SWAP_EVENTS) {
		if (dFlagMgr_c::instance->active(event1)) {
			dFlagMgr_c::instance->set(event1, 0, false, false, false);
			dFlagMgr_c::instance->set(event2, 0, true, false, false);
		} else {
			dFlagMgr_c::instance->set(event1, 0, true, false, false);
			dFlagMgr_c::instance->set(event2, 0, false, false, false);
		}
	}

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.addToList();
	
	doStateChange(&StateID_Wait);
}



void daEnEventBlock_c::calledWhenUpMoveExecutes() {
	if (initialY >= pos.y)
		blockWasHit(false);
}

void daEnEventBlock_c::calledWhenDownMoveExecutes() {
	if (initialY <= pos.y)
		blockWasHit(true);
}



void daEnEventBlock_c::beginState_Wait() {
}

void daEnEventBlock_c::endState_Wait() {
}

void daEnEventBlock_c::executeState_Wait() {
	int result = blockResult();

	if (result == 0)
		return;

	if (result == 1) {
		doStateChange(&daEnBlockMain_c::StateID_UpMove);
		anotherFlag = 2;
		isGroundPound = false;
	} else {
		doStateChange(&daEnBlockMain_c::StateID_DownMove);
		anotherFlag = 1;
		isGroundPound = true;
	}
}



//
// processed\../src/msgbox.cpp
//

#include <common.h>
#include <game.h>
#include "sfx.h"
#include "msgbox.h"

// Replaces: EN_LIFT_ROTATION_HALF (Sprite 107; Profile ID 481 @ 80AF96F8)


dMsgBoxManager_c *dMsgBoxManager_c::instance = 0;
dMsgBoxManager_c *dMsgBoxManager_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dMsgBoxManager_c));
	dMsgBoxManager_c *c = new(buffer) dMsgBoxManager_c;

	instance = c;
	return c;
}

#define ANIM_BOX_APPEAR 0
#define ANIM_BOX_DISAPPEAR 1

extern int MessageBoxIsShowing;

/*****************************************************************************/
// Events
int dMsgBoxManager_c::onCreate() {
	if (!layoutLoaded) {
		if (!layout.loadArc("msgbox.arc", false))
			return false;

		static const char *brlanNames[2] = {
			"BoxAppear.brlan",
			"BoxDisappear.brlan",
		};

		static const char *groupNames[2] = {
			"G_Box", "G_Box",
		};

		layout.build("MessageBox.brlyt");

		if (IsWideScreen()) {
			layout.layout.rootPane->scale.x = 0.7711f;
		}

		layout.loadAnimations(brlanNames, 2);
		layout.loadGroups(groupNames, (int[2]){0,1}, 2);
		layout.disableAllAnimations();

		layout.drawOrder = 140;

		layoutLoaded = true;
	}

	visible = false;

	return true;
}

int dMsgBoxManager_c::onExecute() {
	state.execute();

	layout.execAnimations();
	layout.update();

	return true;
}

int dMsgBoxManager_c::onDraw() {
	if (visible) {
		layout.scheduleForDrawing();
	}

	return true;
}

int dMsgBoxManager_c::onDelete() {
	instance = 0;

	MessageBoxIsShowing = false;
	if (canCancel && StageC4::instance)
		StageC4::instance->_1D = 0; // disable no-pause
	msgDataLoader.unload();

	return layout.free();
}

/*****************************************************************************/
// Load Resources
CREATE_STATE_E(dMsgBoxManager_c, LoadRes);

void dMsgBoxManager_c::executeState_LoadRes() {
	if (msgDataLoader.load("/NewerRes/Messages.bin")) {
		state.setState(&StateID_Wait);
	}
}

/*****************************************************************************/
// Waiting
CREATE_STATE_E(dMsgBoxManager_c, Wait);

void dMsgBoxManager_c::executeState_Wait() {
	// null
}

/*****************************************************************************/
// Show Box
void dMsgBoxManager_c::showMessage(int id, bool canCancel, int delay) {
	if (!this) {
		OSReport("Message Block: No message block manager found.\n");
		return;
	}

	// get the data file
	header_s *data = (header_s*)msgDataLoader.buffer;

	const wchar_t *title = 0, *msg = 0;

	for (int i = 0; i < data->count; i++) {
		if (data->entry[i].id == id) {
			title = (const wchar_t*)((u32)data + data->entry[i].titleOffset);
			msg = (const wchar_t*)((u32)data + data->entry[i].msgOffset);
			break;
		}
	}

	if (title == 0) {
		OSReport("Message Box: Message %08x not found\n", id);
		return;
	}

	layout.findTextBoxByName("T_title")->SetString(title);
	layout.findTextBoxByName("T_msg")->SetString(msg);

	this->canCancel = canCancel;
	this->delay = delay;
	layout.findPictureByName("button")->SetVisible(canCancel);

	state.setState(&StateID_BoxAppearWait);
}


CREATE_STATE(dMsgBoxManager_c, BoxAppearWait);

void dMsgBoxManager_c::beginState_BoxAppearWait() {
	visible = true;
	MessageBoxIsShowing = true;
	StageC4::instance->_1D = 1; // enable no-pause
	layout.enableNonLoopAnim(ANIM_BOX_APPEAR);

	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_SYS_KO_DIALOGUE_IN, 1);
}

void dMsgBoxManager_c::executeState_BoxAppearWait() {
	if (!layout.isAnimOn(ANIM_BOX_APPEAR)) {
		state.setState(&StateID_ShownWait);
	}
}

void dMsgBoxManager_c::endState_BoxAppearWait() { }

/*****************************************************************************/
// Wait For Player To Finish
CREATE_STATE(dMsgBoxManager_c, ShownWait);

void dMsgBoxManager_c::beginState_ShownWait() { }
void dMsgBoxManager_c::executeState_ShownWait() {
	if (canCancel) {
		int nowPressed = Remocon_GetPressed(GetActiveRemocon());

		if (nowPressed & WPAD_TWO)
			state.setState(&StateID_BoxDisappearWait);
	}

	if (delay > 0) {
		delay--;
		if (delay == 0)
			state.setState(&StateID_BoxDisappearWait);
	}
}
void dMsgBoxManager_c::endState_ShownWait() { }

/*****************************************************************************/
// Hide Box
CREATE_STATE(dMsgBoxManager_c, BoxDisappearWait);

void dMsgBoxManager_c::beginState_BoxDisappearWait() {
	layout.enableNonLoopAnim(ANIM_BOX_DISAPPEAR);

	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_SYS_DIALOGUE_OUT_AUTO, 1);
}

void dMsgBoxManager_c::executeState_BoxDisappearWait() {
	if (!layout.isAnimOn(ANIM_BOX_DISAPPEAR)) {
		state.setState(&StateID_Wait);

		for (int i = 0; i < 2; i++)
			layout.resetAnim(i);
		layout.disableAllAnimations();
	}
}

void dMsgBoxManager_c::endState_BoxDisappearWait() {
	visible = false;
	MessageBoxIsShowing = false;
	if (canCancel && StageC4::instance)
		StageC4::instance->_1D = 0; // disable no-pause
}

/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
// Replaces: EN_BLUR (Sprite 152; Profile ID 603 @ 80ADD890)


class daEnMsgBlock_c : public daEnBlockMain_c {
	public:
	TileRenderer tile;
	Physics::Info physicsInfo;
	u16 msg;
	u8 eventID;
	bool eventTriggered;

	int onCreate();
	int onDelete();
	int onExecute();

	void calledWhenUpMoveExecutes();
	void calledWhenDownMoveExecutes();
	bool wasEventTriggered();

	void blockWasHit(bool isDown);

	USING_STATES(daEnMsgBlock_c);
	DECLARE_STATE(Wait);

	static daEnMsgBlock_c *build();
};


CREATE_STATE(daEnMsgBlock_c, Wait);


int daEnMsgBlock_c::onCreate() {
	// read settings
	this->eventID = ((this->settings >> 16) & 0xFF);
	this->msg = this->settings & 0xFFFF;
	this->eventTriggered = false;

	OSReport("Linking message %d to event %d\n", this->msg, this->eventID);

	blockInit(pos.y);

	physicsInfo.x1 = -8;
	physicsInfo.y1 = 16;
	physicsInfo.x2 = 8;
	physicsInfo.y2 = 0;

	physicsInfo.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.flagsMaybe = 0x260;
	physics.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics.addToList();

	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->add(&tile);

	tile.x = pos.x - 8;
	tile.y = -(16 + pos.y);
	tile.tileNumber = 0x98;

	doStateChange(&daEnMsgBlock_c::StateID_Wait);

	return true;
}


int daEnMsgBlock_c::onDelete() {
	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->remove(&tile);

	physics.removeFromList();

	return true;
}


int daEnMsgBlock_c::onExecute() {
	// check if event was triggered
	this->wasEventTriggered();

	acState.execute();
	physics.update();
	blockUpdate();

	tile.setPosition(pos.x-8, -(16+pos.y), pos.z);
	tile.setVars(scale.x);

	// now check zone bounds based on state
	if (acState.getCurrentState()->isEqual(&StateID_Wait)) {
		checkZoneBoundaries(0);
	}

	return true;
}


daEnMsgBlock_c *daEnMsgBlock_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daEnMsgBlock_c));
	return new(buffer) daEnMsgBlock_c;
}


void daEnMsgBlock_c::blockWasHit(bool isDown) {
	this->pos.y = initialY;

	if (dMsgBoxManager_c::instance) {
		dMsgBoxManager_c::instance->showMessage(this->msg);
	} else {
		OSReport("No MsgBoxManager found! Deleting this message block\n");
		Delete(false);
	}

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.addToList();

	doStateChange(&StateID_Wait);
}



void daEnMsgBlock_c::calledWhenUpMoveExecutes() {
	if (initialY >= pos.y)
		blockWasHit(false);
}

void daEnMsgBlock_c::calledWhenDownMoveExecutes() {
	if (initialY <= pos.y)
		blockWasHit(true);
}

bool daEnMsgBlock_c::wasEventTriggered() {
	// check if event was triggered
	bool eventActive = dFlagMgr_c::instance->flags & (((u64)1 << (this->eventID - 1)) | spriteFlagMask) == 1;
	if (eventActive && !this->eventTriggered) {
		OSReport("MsgBlock: Triggered msg %d by event %d\n", this->msg, this->eventID);

		// act as if it was hit
		this->blockWasHit(true);
		this->eventTriggered = true;

		return true;
	}

	if (this->eventTriggered && !eventActive) {
		// enable the event triggeredness again
		OSReport("MsgBlock: Re-enabling!");
		this->eventTriggered = false;
	}

	return false;
}


void daEnMsgBlock_c::beginState_Wait() {
}

void daEnMsgBlock_c::endState_Wait() {
}

void daEnMsgBlock_c::executeState_Wait() {
	int result = blockResult();

	if (result == 0)
		return;

	if (result == 1) {
		doStateChange(&daEnBlockMain_c::StateID_UpMove);
		anotherFlag = 2;
		isGroundPound = false;
	} else {
		doStateChange(&daEnBlockMain_c::StateID_DownMove);
		anotherFlag = 1;
		isGroundPound = true;
	}
}

//
// processed\../src/eventlooper.cpp
//

#include <common.h>
#include <game.h>

struct EventLooper {
	u32 id;			// 0x00
	u32 settings;	// 0x04
	u16 name;		// 0x08
	u8 _0A[6];		// 0x0A
	u8 _10[0x9C];	// 0x10
	float x;		// 0xAC
	float y;		// 0xB0
	float z;		// 0xB4
	u8 _B8[0x318];	// 0xB8
	// Any variables you add to the class go here; starting at offset 0x3D0
	u64 eventFlag;	// 0x3D0
	u64 eventActive;	// 0x3D0
	u8 delay;		// 0x3D4
	u8 delayCount;	// 0x3D7
};

void EventLooper_Update(EventLooper *self);



bool EventLooper_Create(EventLooper *self) {
	char eventStart	= (self->settings >> 24)	& 0xFF;
	char eventEnd	= (self->settings >> 16)	& 0xFF;

	// Putting all the events into the flag
	int i;
	u64 q = (u64)0;
	for(i=eventStart;i<(eventEnd+1);i++)
	{
		q = q | ((u64)1 << (i - 1));
	}
		
	self->eventFlag = q;
	
	self->delay		= (((self->settings) & 0xFF) + 1) * 10;
	self->delayCount = 0;
	
	char tmpEvent= (self->settings >> 8)	& 0xFF;
	if (tmpEvent == 0)
	{
		self->eventActive = (u64)0xFFFFFFFFFFFFFFFF;
	}
	else
	{
		self->eventActive = (u64)1 << (tmpEvent - 1);
		
	}
	

	if (dFlagMgr_c::instance->flags & self->eventActive)
	{
		u64 evState = (u64)1 << (eventStart - 1);
		dFlagMgr_c::instance->flags |= evState;
	}

	EventLooper_Update(self);
	
	return true;
}

bool EventLooper_Execute(EventLooper *self) {
	EventLooper_Update(self);
	return true;
}


void EventLooper_Update(EventLooper *self) {
	
	if ((dFlagMgr_c::instance->flags & self->eventActive) == 0)
		return;

	// Waiting for the right moment
	if (self->delayCount < self->delay) 
	{

		self->delayCount = self->delayCount + 1;
		return;
	}	
	
	// Reset the delay
	self->delayCount = 0;
	
	// Find which event(s) is/are on
	u64 evState = dFlagMgr_c::instance->flags & self->eventFlag;
	
	// Turn off the old events
	dFlagMgr_c::instance->flags = dFlagMgr_c::instance->flags & (~self->eventFlag);
	
	// Shift them right if they can, if not, reset!
	evState = evState << 1;
	if (evState < self->eventFlag)
	{
		dFlagMgr_c::instance->flags = dFlagMgr_c::instance->flags | evState;
	}
	
	else
	{
		char eventStart	= (self->settings >> 24)	& 0xFF;
		evState = (u64)1 << (eventStart - 1);
		dFlagMgr_c::instance->flags = dFlagMgr_c::instance->flags | evState;
	}
	
	
}

//
// processed\../src/spritespawner.cpp
//

#include <game.h>
#include <profile.h>

class dSpriteSpawner_c : public dStageActor_c {
	public:
		static dActor_c *build();

		u64 classicEventOverride;
		Actors profileID;
		bool respawn;
		u32 childSettings;
		u32 childID;

		int onCreate();
		int onExecute();
};


const char *SpriteSpawnerFileList[] = {0};
const SpriteData SpriteSpawnerSpriteData = { ProfileId::SpriteSpawner, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile SpriteSpawnerProfile(&dSpriteSpawner_c::build, SpriteId::SpriteSpawner, SpriteSpawnerSpriteData, ProfileId::EN_BOYON, ProfileId::SpriteSpawner, "SpriteSpawner", SpriteSpawnerFileList);


dActor_c *dSpriteSpawner_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dSpriteSpawner_c));
	dSpriteSpawner_c *c = new(buffer) dSpriteSpawner_c;
	return c;
}


int dSpriteSpawner_c::onCreate() {
	char classicEventNum = (settings >> 28) & 0xF;
	classicEventOverride = (classicEventNum == 0) ? 0 : ((u64)1 << (classicEventNum - 1));

	profileID = (Actors)((settings >> 16) & 0x7FF);
	respawn = (settings >> 27) & 1;

	u16 tempSet = settings & 0xFFFF;
	childSettings =
		(tempSet & 3) | ((tempSet & 0xC) << 2) |
		((tempSet & 0x30) << 4) | ((tempSet & 0xC0) << 6) |
		((tempSet & 0x300) << 8) | ((tempSet & 0xC00) << 10) |
		((tempSet & 0x3000) << 12) | ((tempSet & 0xC000) << 14);

	return true;
}


int dSpriteSpawner_c::onExecute() {
	u64 effectiveFlag = classicEventOverride | spriteFlagMask;

	if (dFlagMgr_c::instance->flags & effectiveFlag) {
		if (!childID) {
			dStageActor_c *newAc = dStageActor_c::create(profileID, childSettings, &pos, 0, 0);
			childID = newAc->id;
		}
	} else {
		if (respawn)
			return true;

		if (childID) {
			dStageActor_c *ac = (dStageActor_c*)fBase_c::search(childID);
			if (ac) {
				pos = ac->pos;
				ac->Delete(1);
			}
			childID = 0;
		}
	}

	if (respawn) {
		if (childID) {
			dStageActor_c *ac = (dStageActor_c*)fBase_c::search(childID);
			if (!ac) {
				dStageActor_c *newAc = dStageActor_c::create(profileID, childSettings, &pos, 0, 0);
				childID = newAc->id;
			}
		}
	}
	return true;
}
//
// processed\../src/spriteswapper.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

class SpriteSpawnerTimed : public dStageActor_c {
public:
	int onCreate();
	int onExecute();

	static dActor_c *build();

	u64 eventFlag;	// 0x3D0
	u16 type;		// 0x3D4
	u32 inheritSet;	// 0x3D6
	u8 lastEvState;	// 0x3DA
	u32 timer;
};


const char *SpriteSwapperFileList[] = {0};
const SpriteData SpriteSwapperSpriteData = { ProfileId::SpriteSwapper, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile SpriteSwapperProfile(&SpriteSpawnerTimed::build, SpriteId::SpriteSwapper, SpriteSwapperSpriteData, ProfileId::EN_REMOCON_TORIMOCHI, ProfileId::SpriteSwapper, "SpriteSwapper", SpriteSwapperFileList);


dActor_c *SpriteSpawnerTimed::build() {
	void *buffer = AllocFromGameHeap1(sizeof(SpriteSpawnerTimed));
	return new(buffer) SpriteSpawnerTimed;
}


int SpriteSpawnerTimed::onCreate() {

	char eventNum	= (this->settings >> 28)	& 0xF;

	this->eventFlag = (u64)1 << (eventNum - 1);
	this->type		= (this->settings >> 16) & 0xFFF;
	
	short tempSet = this->settings & 0xFFFF;
	this->inheritSet = (tempSet & 3) | ((tempSet & 0xC) << 2) | ((tempSet & 0x30) << 4) | ((tempSet & 0xC0) << 6) | ((tempSet & 0x300) << 8) | ((tempSet & 0xC00) << 10) | ((tempSet & 0x3000) << 12) | ((tempSet & 0xC000) << 14);
	
	this->timer = 0;
	
	return true;
}

int SpriteSpawnerTimed::onExecute() {

	if (dFlagMgr_c::instance->flags & this->eventFlag) {		 // If the event is on
		if (this->timer < 1) {						// If the timer is empty
			CreateActor(this->type, this->inheritSet, this->pos, 0, 0);
			this->timer = 120;
		}		

		this->timer--;
	}

	else {
		this->timer = 0;
	}

	return true;
}

//
// processed\../src/topman.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>

const char* TMarcNameList [] = {
	"topman",
	NULL	
};

class daTopman : public dEn_c {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;

	m3d::mdl_c bodyModel;

	m3d::anmChr_c chrAnimation;

	int timer;
	char damage;
	char isDown;
	float XSpeed;
	u32 cmgr_returnValue;
	bool isBouncing;
	char isInSpace;
	char fromBehind;
	char isWaiting;
	char backFire;
	int directionStore;

	public: static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();
	bool calculateTileCollisions();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	// bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	void _vf148();
	void _vf14C();
	bool CreateIceActors();
	void addScoreWhenHit(void *other);

	USING_STATES(daTopman);
	DECLARE_STATE(Walk);
	DECLARE_STATE(Turn);
	DECLARE_STATE(Wait);
	DECLARE_STATE(KnockBack);
	DECLARE_STATE(Die);
};

const SpriteData TopmanSpriteData = { ProfileId::Topman, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile TopmanProfile(&daTopman::build, SpriteId::Topman, TopmanSpriteData, ProfileId::TARZAN_ROPE, ProfileId::Topman, "Topman", TMarcNameList);

dActor_c *daTopman::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daTopman));
	return new(buffer) daTopman;
}

///////////////////////
// Externs and States
///////////////////////
	extern "C" void *EN_LandbarrelPlayerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);

	//FIXME make this dEn_c->used...
	extern "C" char usedForDeterminingStatePress_or_playerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther, int unk1);
	extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);


	CREATE_STATE(daTopman, Walk);
	CREATE_STATE(daTopman, Turn);
	CREATE_STATE(daTopman, Wait);
	CREATE_STATE(daTopman, KnockBack);
	CREATE_STATE(daTopman, Die);

	// 	begoman_attack2"	// wobble back and forth tilted forwards
	// 	begoman_attack3"	// Leaned forward, antennae extended
	// 	begoman_damage"		// Bounces back slightly
	// 	begoman_damage2"	// Stops spinning and wobbles to the ground like a top
	// 	begoman_stand"		// Stands still, waiting
	// 	begoman_wait"		// Dizzily Wobbles
	// 	begoman_wait2"		// spins around just slightly
	// 	begoman_attack"		// Rocks backwards, and then attacks to an upright position, pulsing out his antennae


////////////////////////
// Collision Functions
////////////////////////

	// Collision callback to help shy guy not die at inappropriate times and ruin the dinner

	void daTopman::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {

		char hitType;
		hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);

		if(hitType == 1 || hitType == 2) {	// regular jump or mini jump
			this->_vf220(apOther->owner);
		} 
		else if(hitType == 3) {	// spinning jump or whatever?
			this->_vf220(apOther->owner);
		} 
		else if(hitType == 0) {
			EN_LandbarrelPlayerCollision(this, apThis, apOther);
			if (this->pos.x > apOther->owner->pos.x) {
				this->backFire = 1;
			}
			else {
				this->backFire = 0;
			}
			doStateChange(&StateID_KnockBack);
		} 

		// fix multiple player collisions via megazig
		deathInfo.isDead = 0;
		this->flags_4FC |= (1<<(31-7));
		this->counter_504[apOther->owner->which_player] = 0;
	}

	void daTopman::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->playerCollision(apThis, apOther);
	}

	bool daTopman::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->dEn_c::playerCollision(apThis, apOther);
		this->_vf220(apOther->owner);

		deathInfo.isDead = 0;
		this->flags_4FC |= (1<<(31-7));
		this->counter_504[apOther->owner->which_player] = 0;
		return true;
	}

	bool daTopman::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->collisionCatD_Drill(apThis, apOther);
		return true;
	}

	bool daTopman::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->collisionCatD_Drill(apThis, apOther);
		return true;
	}

	bool daTopman::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
		backFire = apOther->owner->direction ^ 1;
		// doStateChange(&StateID_KnockBack);
		doStateChange(&StateID_Die);
		return true;
	}

	bool daTopman::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){
		doStateChange(&StateID_Die);
		return true;
	}

	bool daTopman::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
		doStateChange(&StateID_Die);
		return true;
	}

	bool daTopman::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){
		backFire = apOther->owner->direction ^ 1;
		doStateChange(&StateID_KnockBack);
		return true;
	}

	bool daTopman::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){
		backFire = apOther->owner->direction ^ 1;
		doStateChange(&StateID_KnockBack);
		return true;
	}

	bool daTopman::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
		backFire = apOther->owner->direction ^ 1;
		doStateChange(&StateID_KnockBack);
		return true;
	}

	// void daTopman::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {
	// 	doStateChange(&StateID_DieFall);
	// }

	// These handle the ice crap
	void daTopman::_vf148() {
		dEn_c::_vf148();
		doStateChange(&StateID_Die);
	}
	void daTopman::_vf14C() {
		dEn_c::_vf14C();
		doStateChange(&StateID_Die);
	}

	DoSomethingCool my_struct;

	extern "C" void sub_80024C20(void);
	extern "C" void __destroy_arr(void*, void(*)(void), int, int);
	//extern "C" __destroy_arr(struct DoSomethingCool, void(*)(void), int cnt, int bar);

	bool daTopman::CreateIceActors()
	{
	    struct DoSomethingCool my_struct = { 0, this->pos, {2.5, 2.5, 2.5}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	    this->frzMgr.Create_ICEACTORs( (void*)&my_struct, 1 );
	    __destroy_arr( (void*)&my_struct, sub_80024C20, 0x3C, 1 );
	    return true;
	}

	void daTopman::addScoreWhenHit(void *other) {}


bool daTopman::calculateTileCollisions() {
	// Returns true if sprite should turn, false if not.

	HandleXSpeed();
	HandleYSpeed();
	doSpriteMovement();

	cmgr_returnValue = collMgr.isOnTopOfTile();
	collMgr.calculateBelowCollisionWithSmokeEffect();

	if (isBouncing) {
		stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);
		if (speed.y != 0.0f)
			isBouncing = false;
	}

	float xDelta = pos.x - last_pos.x;
	if (xDelta >= 0.0f)
		direction = 0;
	else
		direction = 1;

	if (collMgr.isOnTopOfTile()) {
		// Walking into a tile branch

		if (cmgr_returnValue == 0)
			isBouncing = true;

		if (speed.x != 0.0f) {
			//playWmEnIronEffect();
		}

		speed.y = 0.0f;

		// u32 blah = collMgr.s_80070760();
		// u8 one = (blah & 0xFF);
		// static const float incs[5] = {0.00390625f, 0.0078125f, 0.015625f, 0.0234375f, 0.03125f};
		// x_speed_inc = incs[one];
		max_speed.x = (direction == 1) ? -0.8f : 0.8f;
	} else {
		x_speed_inc = 0.0f;
	}

	// Bouncing checks
	if (_34A & 4) {
		Vec v = (Vec){0.0f, 1.0f, 0.0f};
		collMgr.pSpeed = &v;

		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;

		collMgr.pSpeed = &speed;

	} else {
		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;
	}

	collMgr.calculateAdjacentCollision(0);

	// Switch Direction
	if (collMgr.outputMaybe & (0x15 << direction)) {
		if (collMgr.isOnTopOfTile()) {
			isBouncing = true;
		}
		return true;
	}
	return false;
}

void daTopman::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daTopman::onCreate() {

	this->deleteForever = true;
	
	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("topman", "g3d/begoman_spike.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("begoman");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Map(&bodyModel, 0);


	// Animations start here
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("begoman_wait");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	// Stuff I do understand
	this->scale = (Vec){0.2, 0.2, 0.2};

	// this->pos.y = this->pos.y + 30.0; // X is vertical axis
	this->rot.x = 0; // X is vertical axis
	this->rot.y = 0xD800; // Y is horizontal axis
	this->rot.z = 0; // Z is ... an axis >.>
	this->direction = 1; // Heading left.
	
	this->speed.x = 0.0;
	this->speed.y = 0.0;
	this->max_speed.x = 0.8;
	this->x_speed_inc = 0.0;
	this->XSpeed = 0.8;

	this->isInSpace = this->settings & 0xF;
	this->isWaiting = (this->settings >> 4) & 0xF;
	this->fromBehind = 0;

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 12.0;

	HitMeBaby.xDistToEdge = 14.0;
	HitMeBaby.yDistToEdge = 12.0;		

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	// Tile collider

	// These fucking rects do something for the tile rect
	spriteSomeRectX = 28.0f;
	spriteSomeRectY = 32.0f;
	_320 = 0.0f;
	_324 = 16.0f;

	static const lineSensor_s below(12<<12, 4<<12, 0<<12);
	static const pointSensor_s above(0<<12, 12<<12);
	static const lineSensor_s adjacent(6<<12, 9<<12, 14<<12);

	collMgr.init(this, &below, &above, &adjacent);
	collMgr.calculateBelowCollisionWithSmokeEffect();

	cmgr_returnValue = collMgr.isOnTopOfTile();

	if (collMgr.isOnTopOfTile())
		isBouncing = false;
	else
		isBouncing = true;


	// State Changers
	bindAnimChr_and_setUpdateRate("begoman_wait2", 1, 0.0, 1.0); 
	if (this->isWaiting == 0) {
		doStateChange(&StateID_Walk); }
	else {
		doStateChange(&StateID_Wait); }

	this->onExecute();
	return true;
}

int daTopman::onDelete() {
	return true;
}

int daTopman::onExecute() {
	acState.execute();
	updateModelMatrices();
	
	float rect[] = {0.0, 0.0, 38.0, 38.0};
	int ret = this->outOfZone(this->pos, (float*)&rect, this->currentZoneID);
	if(ret) {
		this->Delete(1);
	}
	return true;
}

int daTopman::onDraw() {
	bodyModel.scheduleForDrawing();

	return true;
}

void daTopman::updateModelMatrices() {
	matrix.translation(pos.x, pos.y - 2.0, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


///////////////
// Walk State
///////////////
	void daTopman::beginState_Walk() {
		this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
		this->speed.x = (direction) ? -0.8f : 0.8f;

		this->max_speed.y = (this->isInSpace) ? -2.0 : -4.0;
		this->speed.y = 	(this->isInSpace) ? -2.0 : -4.0;
		this->y_speed_inc = (this->isInSpace) ? -0.09375 : -0.1875;
	}
	void daTopman::executeState_Walk() { 

		if (!this->isOutOfView()) {
			nw4r::snd::SoundHandle *handle = PlaySound(this, SE_BOSS_JR_CROWN_JR_RIDE);
			if (handle)
				handle->SetVolume(0.5f, 0); 
		}
	
		bool ret = calculateTileCollisions();
		if (ret) {
			doStateChange(&StateID_Turn);
		}
		bodyModel._vf1C();

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}
	}
	void daTopman::endState_Walk() { this->timer += 1; }


///////////////
// Turn State
///////////////
	void daTopman::beginState_Turn() {
		this->direction ^= 1;
		this->speed.x = 0.0;
	}
	void daTopman::executeState_Turn() { 

		bodyModel._vf1C();
		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
		int done = SmoothRotation(&this->rot.y, amt, 0x800);

		if(done) {
			this->doStateChange(&StateID_Walk);
		}
	}
	void daTopman::endState_Turn() { }


///////////////
// Wait State
///////////////
	void daTopman::beginState_Wait() {
		this->max_speed.x = 0;
		this->speed.x = 0;

		this->max_speed.y = (this->isInSpace) ? -2.0 : -4.0;
		this->speed.y = 	(this->isInSpace) ? -2.0 : -4.0;
		this->y_speed_inc = (this->isInSpace) ? -0.09375 : -0.1875;
	}
	void daTopman::executeState_Wait() { 

		if (!this->isOutOfView()) {
			nw4r::snd::SoundHandle *handle = PlaySound(this, SE_BOSS_JR_CROWN_JR_RIDE);
			if (handle)
				handle->SetVolume(0.5f, 0); 
		}
	
		bool ret = calculateTileCollisions();
		if (ret) {
			doStateChange(&StateID_Turn);
		}

		bodyModel._vf1C();
		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}
	}
	void daTopman::endState_Wait() { }


///////////////
// Die State
///////////////
	void daTopman::beginState_Die() {
		dEn_c::dieFall_Begin();

		bindAnimChr_and_setUpdateRate("begoman_damage2", 1, 0.0, 1.0); 
		this->timer = 0;
	}
	void daTopman::executeState_Die() { 

		bodyModel._vf1C();

		PlaySound(this, SE_EMY_MECHAKOOPA_DAMAGE);
		if(this->chrAnimation.isAnimationDone()) {
			this->kill();
			this->Delete(this->deleteForever);
		}
	}
	void daTopman::endState_Die() { }


///////////////
// Knockback State
///////////////
	void daTopman::beginState_KnockBack() {
		bindAnimChr_and_setUpdateRate("begoman_damage", 1, 0.0, 0.75); 

		directionStore = direction;
		speed.x = (backFire) ? XSpeed*5.0f : XSpeed*-5.0f;
		max_speed.x = speed.x;
	}
	void daTopman::executeState_KnockBack() { 

		bool ret = calculateTileCollisions();
		this->speed.x = this->speed.x / 1.1;

		bodyModel._vf1C();
		if(this->chrAnimation.isAnimationDone()) {
			if (this->isWaiting == 0) {
				OSReport("Done being knocked back, going back to Walk state\n");
				doStateChange(&StateID_Walk); }
			else {
				OSReport("Done being knocked back, going back to Wait state\n");
				doStateChange(&StateID_Wait); }
		}

	}
	void daTopman::endState_KnockBack() { 
		direction = directionStore;
		bindAnimChr_and_setUpdateRate("begoman_wait2", 1, 0.0, 1.0); 
	}
	

//
// processed\../src/bossMegaGoomba.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include "boss.h"

extern "C" void *StageScreen;

const char* MegaGoombaFileList [] = {
	"kuriboBig",
	"kuriboBoss",
	NULL	
};

class daMegaGoomba_c : public dEn_c {
	public:
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c animationChr;

	float timer;
	float dying;

	lineSensor_s belowSensor;
	lineSensor_s adjacentSensor;

	ActivePhysics leftTrapAPhysics, rightTrapAPhysics;
	ActivePhysics stalkAPhysics;

	HermiteKey keysX[0x10];
	unsigned int Xkey_count;
	HermiteKey keysY[0x10];
	unsigned int Ykey_count;

	char life;
	bool already_hit;

	float XSpeed;
	float JumpHeight;
	float JumpDist;
	float JumpTime;

	char isBigBoss;
	char isPanic;

	bool takeHit(char count);

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	
	void dieFall_Begin();
	void dieFall_Execute();
	static dActor_c *build();

	void setupBodyModel();
	void setupCollision();

	void updateModelMatrices();

	void stunPlayers();
	void unstunPlayers();

	bool hackOfTheCentury;

	bool playerStunned[4];

	void removeMyActivePhysics();
	void addMyActivePhysics();

	int tryHandleJumpedOn(ActivePhysics *apThis, ActivePhysics *apOther);

	void spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	void addScoreWhenHit(void *other);
	bool _vf120(ActivePhysics *apThis, ActivePhysics *apOther);
	bool _vf110(ActivePhysics *apThis, ActivePhysics *apOther);
	bool _vf108(ActivePhysics *apThis, ActivePhysics *apOther);

	void powBlockActivated(bool isNotMPGP);

	void dieOther_Begin();
	void dieOther_Execute();
	void dieOther_End();

	USING_STATES(daMegaGoomba_c);
	DECLARE_STATE(Shrink);
	DECLARE_STATE(Walk);
	DECLARE_STATE(Turn);
};

const SpriteData MegaGoombaSpriteData = { ProfileId::MegaGoomba, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile MegaGoombaProfile(&daMegaGoomba_c::build, SpriteId::MegaGoomba, MegaGoombaSpriteData, ProfileId::MegaGoomba, ProfileId::MegaGoomba, "MegaGoomba", MegaGoombaFileList);

dActor_c *daMegaGoomba_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daMegaGoomba_c));
	return new(buffer) daMegaGoomba_c;
}


void daMegaGoomba_c::removeMyActivePhysics() {
	aPhysics.removeFromList();
	stalkAPhysics.removeFromList();
	leftTrapAPhysics.removeFromList();
	rightTrapAPhysics.removeFromList();
}

void daMegaGoomba_c::addMyActivePhysics() {
	aPhysics.addToList();
	stalkAPhysics.addToList();
	leftTrapAPhysics.addToList();
	rightTrapAPhysics.addToList();
}


void setNewActivePhysicsRect(daMegaGoomba_c *actor, Vec *scale) {
	float amtX = scale->x * 0.5f;
	float amtY = scale->y * 0.5f;

	actor->belowSensor.flags = SENSOR_LINE;
	actor->belowSensor.lineA = s32((amtX * -28.0f) * 4096.0f);
	actor->belowSensor.lineB = s32((amtX * 28.0f) * 4096.0f);
	actor->belowSensor.distanceFromCenter = 0;

	actor->adjacentSensor.flags = SENSOR_LINE;
	actor->adjacentSensor.lineA = s32((amtY * 4.0f) * 4096.0f);
	actor->adjacentSensor.lineB = s32((amtY * 32.0f) * 4096.0f);
	actor->adjacentSensor.distanceFromCenter = s32((amtX * 46.0f) * 4096.0f);

	u8 cat1 = 3, cat2 = 0;
	u32 bitfield1 = 0x6f, bitfield2 = 0xffbafffe;

	ActivePhysics::Info info = {
		0.0f, amtY*57.0f, amtX*20.0f, amtY*31.0f,
		cat1, cat2, bitfield1, bitfield2, 0, &dEn_c::collisionCallback};
	actor->aPhysics.initWithStruct(actor, &info);

	// Original trapezium was -12,12 to -48,48
	ActivePhysics::Info left = {
		amtX*-32.0f, amtY*55.0f, amtX*12.0f, amtY*30.0f,
		cat1, cat2, bitfield1, bitfield2, 0, &dEn_c::collisionCallback};
	actor->leftTrapAPhysics.initWithStruct(actor, &left);
	actor->leftTrapAPhysics.trpValue0 = amtX * 12.0f;
	actor->leftTrapAPhysics.trpValue1 = amtX * 12.0f;
	actor->leftTrapAPhysics.trpValue2 = amtX * -12.0f;
	actor->leftTrapAPhysics.trpValue3 = amtX * 12.0f;
	actor->leftTrapAPhysics.collisionCheckType = 3;

	ActivePhysics::Info right = {
		amtX*32.0f, amtY*55.0f, amtX*12.0f, amtY*30.0f,
		cat1, cat2, bitfield1, bitfield2, 0, &dEn_c::collisionCallback};
	actor->rightTrapAPhysics.initWithStruct(actor, &right);
	actor->rightTrapAPhysics.trpValue0 = amtX * -12.0f;
	actor->rightTrapAPhysics.trpValue1 = amtX * -12.0f;
	actor->rightTrapAPhysics.trpValue2 = amtX * -12.0f;
	actor->rightTrapAPhysics.trpValue3 = amtX * 12.0f;
	actor->rightTrapAPhysics.collisionCheckType = 3;

	ActivePhysics::Info stalk = {
		0.0f, amtY*12.0f, amtX*28.0f, amtY*12.0f,
		cat1, cat2, bitfield1, bitfield2, 0, &dEn_c::collisionCallback};
	actor->stalkAPhysics.initWithStruct(actor, &stalk);

}


//FIXME make this dEn_c->used...
extern "C" int SomeStrangeModification(dStageActor_c* actor);
extern "C" void DoStuffAndMarkDead(dStageActor_c *actor, Vec vector, float unk);
extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);

void daMegaGoomba_c::powBlockActivated(bool isNotMPGP) {
}

CREATE_STATE(daMegaGoomba_c, Shrink);
CREATE_STATE(daMegaGoomba_c, Walk);
CREATE_STATE(daMegaGoomba_c, Turn);


//TODO better fix for possible bug with sign (ex. life=120; count=-9;)
bool daMegaGoomba_c::takeHit(char count) {
	OSReport("Taking a hit!\n");
	if(!this->already_hit) {
		int c = count;
		int l = this->life;
		if(l - c > 127) {
			c = 127 - l;
		}
		this->life -= c;
		// this->XSpeed += 0.10;

		// float rate = this->animationChr.getUpdateRate();
		// this->animationChr.setUpdateRate(rate+0.05);
		this->JumpHeight += 12.0;
		this->JumpDist += 12.0;
		this->JumpTime += 5.0;
		doStateChange(&StateID_Shrink);
		this->already_hit = true;
	}
	return (life <= 0) ? true : false;
}

#define ACTIVATE	1
#define DEACTIVATE	0

extern "C" void *EN_LandbarrelPlayerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
void daMegaGoomba_c::spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	//HE'S TOO BADASS TO STOP FOR SMALLER GOOMBAS
	#if 0
		float me = apThis->firstFloatArray[3];
		if(((this->direction == 1) && (me > 0.0)) || ((this->direction == 0) && (me < 0.0))) {
			dStateBase_c* state = this->acState.getCurrentState();
			if(!state->isEqual(&StateID_Turn)) {
				doStateChange(&StateID_Turn);
			}
		}
	#endif
}
void daMegaGoomba_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) { 
	if (apThis == &stalkAPhysics) {
		dEn_c::playerCollision(apThis, apOther);
		return;
	}

	/* * * * * * * * * * * * * * * * * * * * *
	 * 0=normal??,1=dontHit,2=dontKill
	 * daEnBrosBase_c ::player = 0
	 * daEnBrosBase_c::yoshi   = 0
	 * daEnPipePirahna::player = 1
	 * daEnPipePirahna::yoshi  = 1
	 * daEnKuriboBase_c::player = 0
	 * daEnKuriboBase_c::yoshi  = 0
	 * daEnLargeKuribo_c::player = 0
	 * daEnLargeKuribo_c::yoshi  = 2
	 * daEnNokonoko_c::player = 0
	 * daEnNokonoko_c::yoshi  = 0
	 * daEnSubBoss_c     = 2
	 *
	 * * * * * * * * * * * * * * * * * * * * */
	//FIXME rename and make part of dStageActor_c
	//unk=0 does _vfs, unk=1 does playSeCmnStep
	//char ret = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);

	if (tryHandleJumpedOn(apThis, apOther) == 0) {
		this->dEn_c::playerCollision(apThis, apOther);
		this->_vf220(apOther->owner);
		this->counter_504[apOther->owner->which_player] = 180;
	}
}

int daMegaGoomba_c::tryHandleJumpedOn(ActivePhysics *apThis, ActivePhysics *apOther) {
	float saveBounce = EnemyBounceValue;
	EnemyBounceValue = 5.2f;

	char ret = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 2);

	EnemyBounceValue = saveBounce;

	if(ret == 1 || ret == 3) {
		apOther->someFlagByte |= 2;
		if(this->takeHit(1)) {
			// kill me
			VEC2 eSpeed = {speed.x, speed.y};
			killWithSpecifiedState(apOther->owner, &eSpeed, &dEn_c::StateID_DieOther);
		}
	}

	return ret;
}
bool daMegaGoomba_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) { 
	if (this->counter_504[apOther->owner->which_player] > 0) { return false; }
	VEC2 eSpeed = {speed.x, speed.y};
	killWithSpecifiedState(apOther->owner, &eSpeed, &dEn_c::StateID_DieOther);
	return true;
}
bool daMegaGoomba_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) { 
	return collisionCat7_GroundPound(apThis, apOther);
}

bool daMegaGoomba_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daMegaGoomba_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
extern "C" void dAcPy_vf3F8(void* player, dEn_c* monster, int t);
bool daMegaGoomba_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther) {
	if (tryHandleJumpedOn(apThis, apOther) == 0) {
		dAcPy_vf3F8(apOther->owner, this, 3);
		this->counter_504[apOther->owner->which_player] = 0xA;
	}
	return true;
}
bool daMegaGoomba_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
	if(this->takeHit(1))
		doStateChange(&StateID_DieFall);
	return true;
}
bool daMegaGoomba_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther) {
	if(this->takeHit(1))
		doStateChange(&StateID_DieFall);
	return true;
}
bool daMegaGoomba_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	return collisionCat7_GroundPound(apThis, apOther);
}
bool daMegaGoomba_c::collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true;
}
bool daMegaGoomba_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true;
}
bool daMegaGoomba_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther) {
	if(this->takeHit(1))
		doStateChange(&StateID_DieFall);
	return true;
}
void daMegaGoomba_c::addScoreWhenHit(void *other) {}
bool daMegaGoomba_c::_vf120(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true; // Replicate existing broken behaviour
}
bool daMegaGoomba_c::_vf110(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true; // Replicate existing broken behaviour
}
bool daMegaGoomba_c::_vf108(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true; // Replicate existing broken behaviour
}

void daMegaGoomba_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->animationChr.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->animationChr, unk2);
	this->animationChr.setUpdateRate(rate);
}

void daMegaGoomba_c::dieFall_Begin() {
	this->dEn_c::dieFall_Begin();
	PlaySound(this, SE_EMY_KURIBO_L_DAMAGE_03);
}
void daMegaGoomba_c::dieFall_Execute() {
	
	this->timer = this->timer + 1.0;
	
	this->dying = this->dying + 0.15;
	
	this->pos.x = this->pos.x + 0.15;
	this->pos.y = this->pos.y + ((-0.2 * (this->dying*this->dying)) + 5);
	
	this->dEn_c::dieFall_Execute();
}

void daMegaGoomba_c::setupBodyModel() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	nw4r::g3d::ResFile rf(getResource("kuriboBoss", "g3d/kuriboBoss.brres"));
	nw4r::g3d::ResMdl mdl = rf.GetResMdl("kuriboBig");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);

	bool ret;
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("walk");
	ret = this->animationChr.setup(mdl, anmChr, &this->allocator, 0);
	this->bindAnimChr_and_setUpdateRate("walk", 1, 0.0, 0.2);

	allocator.unlink();
}

void daMegaGoomba_c::setupCollision() {
	//POINTLESS WITH GROWTH
	this->scale.x = this->scale.y = this->scale.z = 0.666;

	this->collMgr.init(this, &belowSensor, 0, &adjacentSensor);

	char foo = this->appearsOnBackFence;
	this->pos_delta2.x = 0.0;
	this->pos_delta2.y = 16.0;
	this->pos_delta2.z = 0.0;

	this->pos.z = (foo == 0) ? 1500.0 : -2500.0;

	this->_518 = 2;

	//NOT NEEDED
	//this->doStateChange(&StateID_Walk);
}

int daMegaGoomba_c::onCreate() {
	/*80033230 daEnLkuribo_c::onCreate()*/
	this->setupBodyModel();
	this->max_speed.y = -4.0;
	this->direction = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
	this->rot.y = (this->direction) ? 0xE000 : 0x2000;
	this->_518 = 2;

	isBigBoss = this->settings & 0xF;
	this->animationChr.setCurrentFrame(69.0);

	aPhysics.addToList();
	stalkAPhysics.addToList();
	leftTrapAPhysics.addToList();
	rightTrapAPhysics.addToList();

	this->_120 |= 0x200;

	this->_36D = 0;
	this->setupCollision();

	//HOMEMADE//
	speed.y = 0.0;
	dying = 0.0;
	rot.x = rot.z = 0;
	life = 3;
	already_hit = false;
	this->x_speed_inc = 0.1;
	this->pos.y -= 16.0;

	// 2.0 is good final speed
	this->XSpeed = 0.2;
	this->JumpHeight = 48.0;
	this->JumpDist = 64.0;
	this->JumpTime = 50.0;

	// doStateChange(&StateID_Grow);

	scale.x = 4.0f;
	scale.y = 4.0f;
	scale.z = 4.0f;
	setNewActivePhysicsRect(this, &this->scale);
	doStateChange(&StateID_Walk);

	this->onExecute();
	return true;
}

int daMegaGoomba_c::onDelete() {
	unstunPlayers();
	return true;
}

int daMegaGoomba_c::onExecute() {
	//80033450
	acState.execute();
	if (!hackOfTheCentury) {
		hackOfTheCentury = true;
	} else {
		checkZoneBoundaries(0);
	}
	updateModelMatrices();

	return true;
}

int daMegaGoomba_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daMegaGoomba_c::updateModelMatrices() {
	// This won't work with wrap because I'm lazy.
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}



// Shrink State
void daMegaGoomba_c::beginState_Shrink() {
	this->timer = 1.0;
	Xkey_count = 4;
	keysX[0] = (HermiteKey){  0.0, this->scale.y,        0.5 };
	keysX[1] = (HermiteKey){ 10.0, this->scale.y - 0.75, 0.5 };
	keysX[2] = (HermiteKey){ 20.0, this->scale.y - 0.35, 0.5 };
	keysX[3] = (HermiteKey){ 39.0, this->scale.y - 0.75, 0.5 };

	// disable being hit
	Vec tempVec = (Vec){0.0, 0.0, 0.0};
	setNewActivePhysicsRect(this,  &tempVec );
}
void daMegaGoomba_c::executeState_Shrink() { 
	this->timer += 1.0;
	
	float modifier = GetHermiteCurveValue(this->timer, this->keysX, Xkey_count);
	this->scale = (Vec){modifier, modifier, modifier};

	if(this->timer == 2.0)
		PlaySound(this, SE_EMY_KURIBO_L_DAMAGE_02);

	if (this->timer > 40.0) { doStateChange(&StateID_Walk); }
}
void daMegaGoomba_c::endState_Shrink() {
	// enable being hit
	setNewActivePhysicsRect(this, &this->scale);
	this->already_hit = false;
}



// Turn State
void daMegaGoomba_c::beginState_Turn() {
	this->direction ^= 1;
	this->speed.x = 0.0;
}
void daMegaGoomba_c::executeState_Turn() { 
	this->bodyModel._vf1C();

	this->HandleYSpeed();
	this->doSpriteMovement();

	/*this->_vf2D0();	//nullsub();*/
	int ret = SomeStrangeModification(this);

	if(ret & 1)
		this->speed.y = 0.0;
	if(ret & 4)
		this->pos.x = this->last_pos.x;
	DoStuffAndMarkDead(this, this->pos, 1.0);
	u16 amt = (this->direction == 0) ? 0x2000 : 0xE000;
	int done = SmoothRotation(&this->rot.y, amt, 0x80);
	if(done) {
		this->doStateChange(&StateID_Walk);
	}

	int frame = (int)(this->animationChr.getCurrentFrame() * 5.0);
	if ((frame == 100) || (frame == 325) || (frame == 550) || (frame == 775)) {
		ShakeScreen(StageScreen, 0, 1, 0, 0);
		stunPlayers();
		PlaySound(this, SE_BOSS_MORTON_GROUND_SHAKE);
	}

	if (isBigBoss) {
		if ((frame == 250) || (frame == 500) || (frame == 700) || (frame == 900))
			unstunPlayers();
	}
	else {
		if ((frame == 200) || (frame == 425) || (frame == 650) || (frame == 875))
			unstunPlayers();
	}
}
void daMegaGoomba_c::endState_Turn() {
	this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
}


// Walk State
void daMegaGoomba_c::beginState_Walk() {
	//inline this piece of code
	//YOU SUCK, WHOEVER ADDED THIS LINE OF CODE AND MADE ME SPEND AGES
	//HUNTING DOWN WHAT WAS BREAKING TURNING. -Treeki
	//this->direction = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
	this->speed.x = this->speed.z = 0.0;
	this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
	this->speed.y = -4.0;
	this->y_speed_inc = -0.1875;
}
void daMegaGoomba_c::executeState_Walk() { 
	/* 800345e0 - daEnLkuribo_c::executeState_Walk() */
	this->bodyModel._vf1C();
	//HOMEMADE//
	this->HandleXSpeed();
	this->HandleYSpeed();
	this->doSpriteMovement();
	u16 amt = (this->direction == 0) ? 0x2000 : 0xE000;
	SmoothRotation(&this->rot.y, amt, 0x200);
	/*this->_vf2D0();	//nullsub();*/
	int ret = SomeStrangeModification(this);
	if(ret & 1)
		this->speed.y = 0.0;
	u32 bitfield = this->collMgr.outputMaybe;
	if(bitfield & (0x15<<this->direction)) {
		this->pos.x = this->last_pos.x;
		this->doStateChange(&StateID_Turn);
		//this->acState.setField10ToOne();
	}
	/*u32 bitfield2 = this->collMgr.adjacentTileProps[this->direction];
	if(bitfield2) {
		this->doStateChange(&StateID_Turn);
	}*/
	DoStuffAndMarkDead(this, this->pos, 1.0);


	int frame = (int)(this->animationChr.getCurrentFrame() * 5.0);
	if ((frame == 100) || (frame == 325) || (frame == 550) || (frame == 775)) {
		ShakeScreen(StageScreen, 0, 1, 0, 0);
		stunPlayers();
		PlaySound(this, SE_BOSS_MORTON_GROUND_SHAKE);
	}

	if (isBigBoss) {
		if ((frame == 250) || (frame == 500) || (frame == 700) || (frame == 900))
			unstunPlayers();
	}
	else {
		if ((frame == 200) || (frame == 425) || (frame == 650) || (frame == 875))
			unstunPlayers();
	}

	if(this->animationChr.isAnimationDone()) {
		this->animationChr.setCurrentFrame(0.0);

		int new_dir = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, pos);
		if(this->direction != new_dir)
			doStateChange(&StateID_Turn);
	}
}
void daMegaGoomba_c::endState_Walk() { }





extern "C" void stunPlayer(void *, int);
extern "C" void unstunPlayer(void *);

void daMegaGoomba_c::stunPlayers() {
	for (int i = 0; i < 4; i++) {
		playerStunned[i] = false;

		dStageActor_c *player = GetSpecificPlayerActor(i);
		if (player) {
			if (player->collMgr.isOnTopOfTile() && player->currentZoneID == currentZoneID) {
				stunPlayer(player, 1);
				playerStunned[i] = true;
			}
		}
	}
}

void daMegaGoomba_c::unstunPlayers() {
	for (int i = 0; i < 4; i++) {
		dStageActor_c *player = GetSpecificPlayerActor(i);
		if (player && playerStunned[i]) {
			unstunPlayer(player);
		}
	}
}



void daMegaGoomba_c::dieOther_Begin() {
	animationChr.bind(&bodyModel, resFile.GetResAnmChr("damage"), true);
	bodyModel.bindAnim(&animationChr, 2.0f);
	speed.x = speed.y = speed.z = 0.0f;
	removeMyActivePhysics();

	PlaySound(this, SE_EMY_KURIBO_L_SPLIT_HPDP);

	rot.y = 0;
	counter_500 = 60;
}

void daMegaGoomba_c::dieOther_End() {
	dEn_c::dieOther_End();
}

void daMegaGoomba_c::dieOther_Execute() {
	bodyModel._vf1C();
	if (counter_500 == 0) {
		SpawnEffect("Wm_ob_icebreaksmk", 0, &pos, &(S16Vec){0,0,0}, &(Vec){5.0f, 5.0f, 5.0f});
		Delete(1);
	}
}


//
// processed\../src/bossSamurshai.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include "boss.h"

extern "C" void *SoundRelatedClass;
extern "C" void *MapSoundPlayer(void *SoundRelatedClass, int soundID, int unk);
extern "C" void dAcPy_vf3F8(void* player, dEn_c* monster, int t);

const char* SSarcNameList [] = {
	"Shynja",
	NULL	
};

void ChucksAndKnucks(ActivePhysics *apThis, ActivePhysics *apOther);

class daSamurshai : public daBoss {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c chrAnimation;

	mEf::es2 effect;

	int isBigBoss;
	int jumpCounter;
	char isDown;
	Vec initialPos;
	float XSpeed;
	u32 cmgr_returnValue;
	dStageActor_c *chosenOne;
	bool topHurts;
	bool slowDown;
	bool isBouncing;
	bool walkStateIsCharging;
	float amountCharged;

	ActivePhysics Chuckles;
	ActivePhysics Knuckles;

	public: static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();
	bool calculateTileCollisions();

	void powBlockActivated(bool isNotMPGP);

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	void addScoreWhenHit(void *other);
	int randomPlayer();

	bool isNearWall();

	USING_STATES(daSamurshai);

	DECLARE_STATE(Intro);
	DECLARE_STATE(Walk);
	DECLARE_STATE(Turn);
	DECLARE_STATE(Chop);
	DECLARE_STATE(ChargeSlash);
	DECLARE_STATE(Uppercut);
	DECLARE_STATE(SpinAttack);
	DECLARE_STATE(Damage);
	DECLARE_STATE(Outro);
};

const SpriteData SamurshaiSpriteData = {ProfileId::Samurshai, 0x5, -0x31, 0, 0x10, 0x10, 0x40, 0x40, 0x40, 0, 0, 0};
// #      -ID- ----  -X Offs- -Y Offs-  -RectX1- -RectY1- -RectX2- -RectY2-  -1C- -1E- -20- -22-  Flag ----
Profile SamurshaiProfile(&daSamurshai::build, SpriteId::Samurshai, SamurshaiSpriteData, ProfileId::WM_PUKU, ProfileId::Samurshai, "Samurshai", SSarcNameList);

dActor_c *daSamurshai::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daSamurshai));
	return new(buffer) daSamurshai;
}

///////////////////////
// Externs and States
///////////////////////
	extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);

	CREATE_STATE(daSamurshai, Intro);
	CREATE_STATE(daSamurshai, Walk);
	CREATE_STATE(daSamurshai, Turn);
	CREATE_STATE(daSamurshai, Chop);
	CREATE_STATE(daSamurshai, ChargeSlash);
	CREATE_STATE(daSamurshai, Uppercut);
	CREATE_STATE(daSamurshai, SpinAttack);
	CREATE_STATE(daSamurshai, Damage);
	CREATE_STATE(daSamurshai, Outro);


////////////////////////
// Collision Functions
////////////////////////

	void ChucksAndKnucks(ActivePhysics *apThis, ActivePhysics *apOther) {
		if (((dEn_c*)apOther->owner)->name == PLAYER)
			((dEn_c*)apThis->owner)->_vf220(apOther->owner);
	}

	void daSamurshai::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {

		char hitType = 0;
		// this is shit code
		dStateBase_c *whatState = acState.getCurrentState();
		if (whatState == &StateID_Damage) {
			// nothing
		} else if (whatState == &StateID_Walk && walkStateIsCharging) {
			// also nothing
		} else {
			hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 2);
		}

		if (hitType == 2) {
			// Mini jump
			apOther->someFlagByte |= 2;
		} else if (hitType > 0) {
			apOther->someFlagByte |= 2;
			if (this->isDown == 0) { 
				this->playEnemyDownSound1();
				damage += 5;
				if (damage >= 15) { doStateChange(&StateID_Outro); }
				else { doStateChange(&StateID_Damage); }
			}
		} 
		else {
			this->dEn_c::playerCollision(apThis, apOther);
			this->_vf220(apOther->owner);
		} 

		deathInfo.isDead = 0;
		this->flags_4FC |= (1<<(31-7));
		this->counter_504[apOther->owner->which_player] = 0;
	}

	void daSamurshai::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) { this->playerCollision(apThis, apOther); }
	bool daSamurshai::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
		return collisionCat7_GroundPound(apThis, apOther);
	}
	bool daSamurshai::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
		apOther->someFlagByte |= 2;

		if (this->isDown == 0) { 
			damage += 5;
			if (damage >= 15) { doStateChange(&StateID_Outro); }
			else { doStateChange(&StateID_Damage); }
		}

		deathInfo.isDead = 0;
		this->flags_4FC |= (1<<(31-7));
		this->counter_504[apOther->owner->which_player] = 5;
		bouncePlayerWhenJumpedOn(apOther->owner);
		return true;
	}
	bool daSamurshai::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
		return this->collisionCat7_GroundPound(apThis, apOther);
	}
	bool daSamurshai::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
		if (this->isDown == 0) { 
			damage += 3;
			if (damage >= 15) { doStateChange(&StateID_Outro); }
			else { doStateChange(&StateID_Damage); }
		}
		return true;
	}
	bool daSamurshai::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){
		return true;
	}
	bool daSamurshai::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){
		dAcPy_vf3F8(apOther->owner, this, 3);

		deathInfo.isDead = 0;
		this->flags_4FC |= (1<<(31-7));
		this->counter_504[apOther->owner->which_player] = 0;
		return true;
	}
	bool daSamurshai::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){ 
		//damage += 4;
		//SpawnEffect("Wm_mr_fireball_hit", 0, &apOther->owner->pos, &apOther->owner->rot, &apOther->owner->scale);
		//PlaySoundAsync(this, SE_OBJ_FIREBALL_DISAPP);
		//if (damage >= 15) { doStateChange(&StateID_Outro); }
		return true;
	}
	bool daSamurshai::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
		//damage += 1;
		//SpawnEffect("Wm_mr_fireball_hit", 0, &apOther->owner->pos, &apOther->owner->rot, &apOther->owner->scale);
		//PlaySoundAsync(this, SE_OBJ_FIREBALL_DISAPP);		
		//if (damage >= 15) { doStateChange(&StateID_Outro); }
		return true;
	}
	bool daSamurshai::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {
		return true;
	}
	bool daSamurshai::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
		//damage += 2;
		//this->spawnHitEffectAtPosition((Vec2){apOther->owner->pos.x, apOther->owner->pos.y});
		//if (damage >= 15) { doStateChange(&StateID_Outro); }
		return true;
	}


	void daSamurshai::addScoreWhenHit(void *other) { }
	void daSamurshai::powBlockActivated(bool isNotMPGP) { }

	bool daSamurshai::calculateTileCollisions() {
		// Returns true if sprite should turn, false if not.

		HandleXSpeed();
		HandleYSpeed();
		doSpriteMovement();

		cmgr_returnValue = collMgr.isOnTopOfTile();
		collMgr.calculateBelowCollisionWithSmokeEffect();

		if (isBouncing) {
			stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);
			if (speed.y != 0.0f)
				isBouncing = false;
		}

		if (collMgr.isOnTopOfTile()) {
			// Walking into a tile branch

			if (cmgr_returnValue == 0)
				isBouncing = true;

			speed.y = 0.0f;
		} 

		// Bouncing checks
		if (_34A & 4) {
			Vec v = (Vec){0.0f, 1.0f, 0.0f};
			collMgr.pSpeed = &v;

			if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
				speed.y = 0.0f;

			collMgr.pSpeed = &speed;

		} else {
			if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
				speed.y = 0.0f;
		}

		collMgr.calculateAdjacentCollision(0);

		// Switch Direction
		if (collMgr.outputMaybe & (0x15 << direction)) {
			if (collMgr.isOnTopOfTile()) {
				isBouncing = true;
			}
			pos.x += direction ? 2.0 : -2.0;
			return true;
		}
		return false;
	}

void daSamurshai::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daSamurshai::onCreate() {

	isBigBoss = settings & 0xF;

	// Model Setup
		allocator.link(-1, GameHeaps[0], 0, 0x20);

		this->resFile.data = getResource("Shynja", "g3d/Shynja.brres");
		nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("Shynja");
		bodyModel.setup(mdl, &allocator, 0x224, 1, 0);

		// Animations start here
		nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("c18_IDLE_R");
		this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

		allocator.unlink();

	// Character Setup

		scale = (Vec){25.0, 25.0, 25.0};

		pos.y = pos.y - 16.0 * 3.0;
		rot.x = 0; // X is vertical axis
		rot.y = 0xD800; // Y is horizontal axis
		rot.z = 0; // Z is ... an axis >.>
		direction = 1; // Heading left.
		
		speed.x = 0.0;
		speed.y = 0.0;
		XSpeed = 2.5;
		max_speed.x = 50.0;
		initialPos = pos;
		topHurts = false;

	// Physics
		ActivePhysics::Info HitMeBaby;

		HitMeBaby.xDistToCenter = 0.0;
		HitMeBaby.yDistToCenter = 15.0;

		HitMeBaby.xDistToEdge = 13.0;
		HitMeBaby.yDistToEdge = 15.0;		

		HitMeBaby.category1 = 0x3;
		HitMeBaby.category2 = 0x0;
		HitMeBaby.bitfield1 = 0x4F;
		HitMeBaby.bitfield2 = 0xffbafffe;
		HitMeBaby.unkShort1C = 0;
		HitMeBaby.callback = &dEn_c::collisionCallback;

		this->aPhysics.initWithStruct(this, &HitMeBaby);
		this->aPhysics.addToList();

	// Tile collider

		// These fucking rects do something for the tile rect
		spriteSomeRectX = 48.0f;
		spriteSomeRectY = 36.0f;
		_320 = 0.0f;
		_324 = 18.0f;

		// These structs tell stupid collider what to collide with - these are from koopa troopa
		static const lineSensor_s below(-0<<12, 0<<12, 0<<12);
		static const pointSensor_s above(0<<12, 12<<12);
		static const lineSensor_s adjacent(6<<12, 9<<12, 6<<12);

		collMgr.init(this, &below, &above, &adjacent);
		collMgr.calculateBelowCollisionWithSmokeEffect();

		cmgr_returnValue = collMgr.isOnTopOfTile();

		if (collMgr.isOnTopOfTile())
			isBouncing = false;
		else
			isBouncing = true;

	// Sword Physics
		// Chuckles is left, Knuckles is Right
		ActivePhysics::Info iChuckles;
		ActivePhysics::Info iKnuckles;

		iChuckles.xDistToCenter = -27.0;
		iChuckles.yDistToCenter = 8.0;
		iChuckles.xDistToEdge   = 27.0;
		iChuckles.yDistToEdge   = 6.0;

		iKnuckles.xDistToCenter = 27.0;
		iKnuckles.yDistToCenter = 8.0;
		iKnuckles.xDistToEdge   = 27.0;
		iKnuckles.yDistToEdge   = 6.0;

		iKnuckles.category1  = iChuckles.category1  = 0x3;		iKnuckles.category2  = iChuckles.category2  = 0x0;
		iKnuckles.bitfield1  = iChuckles.bitfield1  = 0x4F;
		iKnuckles.bitfield2  = iChuckles.bitfield2  = 0x6;
		iKnuckles.unkShort1C = iChuckles.unkShort1C = 0x0;
		iKnuckles.callback   = iChuckles.callback   = ChucksAndKnucks;

		Chuckles.initWithStruct(this, &iChuckles);
		Knuckles.initWithStruct(this, &iKnuckles);

	doStateChange(&StateID_Intro);

	this->onExecute();
	return true;
}

int daSamurshai::onDelete() {
	return true;
}
int daSamurshai::onExecute() {
	acState.execute();
	updateModelMatrices();

	return true;
}
int daSamurshai::onDraw() {
	bodyModel.scheduleForDrawing();
	bodyModel._vf1C();

	return true;
}
void daSamurshai::updateModelMatrices() {
	// This won't work with wrap because I'm lazy.
	matrix.translation(pos.x, pos.y + 0.0, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


///////////////
// Intro State
///////////////
	void daSamurshai::beginState_Intro() { 
		this->timer = 0;

		// Stop the BGM Music
		StopBGMMusic();

		// Set the necessary Flags and make Mario enter Demo Mode
		dStage32C_c::instance->freezeMarioBossFlag = 1;
		WLClass::instance->_4 = 4;
		WLClass::instance->_8 = 0;

		MakeMarioEnterDemoMode();

		// Make sure to use the correct position
		Vec KamekPos = (Vec){pos.x - 124.0, pos.y + 104.0, 3564.0};
		S16Vec KamekRot = (S16Vec){0, 0, 0};

		rot.y = 0x2800; // Y is horizontal axis
		speed.x = 0.0;
		speed.y = 0.0;

		pos.x = pos.x - 224.0;
		pos.y = pos.y + 320.0;

		// Create And use Kameck
		Kameck = (daKameckDemo*)createChild(KAMECK_FOR_CASTLE_DEMO, (dStageActor_c*)this, 0, &KamekPos, &KamekRot, 0);
		Kameck->doStateChange(&daKameckDemo::StateID_DemoSt);
		Kameck->pos.x = Kameck->pos.x - 32.0;
	}

	void daSamurshai::executeState_Intro() { 
		this->timer += 1;

		OSReport("Timer: %d", timer);
		if (timer == 230) { bindAnimChr_and_setUpdateRate("c18_INTRO", 1, 0.0, 1.0); } 

		if ((timer > 220) && (timer < 240)) {
			pos.x += (224.0 / 20.0);
			pos.y -= (320.0 / 20.0);
		}

		if (timer == 230) { 
			SpawnEffect("Wm_en_hanapetal", 0, &pos, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});
			SpawnEffect("Wm_ob_itemget_ring", 0, &(Vec){pos.x, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){8.0, 0.1, 1.5});
			MapSoundPlayer(SoundRelatedClass, SE_OBJ_WOOD_BOX_BREAK, 1);
			MapSoundPlayer(SoundRelatedClass, SE_BOSS_KAMECK_DOWN, 1);
			this->Kameck->doStateChange(&daKameckDemo::StateID_DieFall);	
		}

		if ((timer > 230) && (timer < 350)) {
			Kameck->pos.x += (200.0 / 120.0);
			Kameck->pos.y -= (260.0 / 120.0);
		}

		int done = 0;
		if ((timer > 330) && (done == 0)) {
			u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
			done = SmoothRotation(&this->rot.y, amt, 0x2000);
		}

		if (timer == 400) { bindAnimChr_and_setUpdateRate("c18_IDLE_R", 1, 0.0, 1.0); }

		if (timer == 500) { 
			MapSoundPlayer(SoundRelatedClass, SE_BOSS_WENDY_RING_BOUND, 1);
			walkStateIsCharging = false;
			doStateChange(&StateID_Walk); 
		}
	}
	void daSamurshai::endState_Intro() { 
		CleanupKameck(this, Kameck);

		rot.y = 0xD800; // Y is horizontal axis
		direction = 1; // Heading left.
		XSpeed = 2.0;
		max_speed.x = 50.0;		
	}

///////////////
// Walk State
///////////////
	int daSamurshai::randomPlayer() {
		int players[4];
		int playerCount = 0;

		for (int i = 0; i < 4; i++) {
			if (Player_Active[i] != 0 && Player_Lives[Player_ID[i]] > 0) {
				players[playerCount] = i;
				playerCount++;
			}
		}
		return players[MakeRandomNumber(playerCount)];
	}

	void daSamurshai::beginState_Walk() {
		Chuckles.removeFromList();
		Knuckles.removeFromList();	

		bindAnimChr_and_setUpdateRate(walkStateIsCharging ? "c18_CHARGE" : "c18_RUNNING", 1, 0.0, 0.5); 
		chosenOne = GetSpecificPlayerActor(this->randomPlayer());

		speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
		if (walkStateIsCharging)
			speed.x *= 1.7f;

		this->max_speed.y = -4.0;
		this->speed.y = -4.0;
		this->y_speed_inc = -0.1875;

		OSReport("Speed: %f / %f", speed.x, max_speed.x);
	}
	void daSamurshai::executeState_Walk() { 
		MapSoundPlayer(SoundRelatedClass, SE_EMY_MOUSE_WALK, 1);

		float xDistance = pos.x - chosenOne->pos.x;
		float yDistance = pos.y - chosenOne->pos.y;

		// OSReport("Distance: %f, %f", xDistance, yDistance);
		if (!walkStateIsCharging && (xDistance >  64.0) && (direction == 0)) { doStateChange(&StateID_Turn); }
		if (!walkStateIsCharging && (xDistance < -64.0) && (direction == 1)) { doStateChange(&StateID_Turn); }

		if (xDistance < 0.0) { xDistance = -xDistance; }

		if (walkStateIsCharging) {
			amountCharged += abs(speed.x);

			// should we stop charging?
			if (amountCharged > 480.0f && !isNearWall()) {
				speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
				doStateChange(&StateID_Uppercut);
			}
		}

		// Condition for Chop
		if (!walkStateIsCharging && xDistance < 32.0) { doStateChange(&StateID_Chop); }

		// Condition For Charge Slash
		if (!walkStateIsCharging && isBigBoss) {
			if ((xDistance < 96.0) && (xDistance > 64.0)) {
				int charge = MakeRandomNumber(100);
				if (charge > 95) { doStateChange(&StateID_ChargeSlash); }
			}
		}

		// Aerial Attacks!
		if (!walkStateIsCharging && yDistance < -24.0) {
			
			// Condition For Spin Attack
			// if (xDistance < 32.0) { doStateChange(&StateID_SpinAttack); }

			// Condition for Uppercut
			if ((xDistance > 48.0) && (xDistance < 64.0) && !isNearWall())
				doStateChange(&StateID_Uppercut);
		}

		bool ret = calculateTileCollisions(); 
		if (ret) {
			doStateChange(&StateID_Turn);
		}

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}
	}
	void daSamurshai::endState_Walk() { }

///////////////
// Turn State
///////////////
	void daSamurshai::beginState_Turn() {
		bindAnimChr_and_setUpdateRate("c18_RUNNING", 1, 0.0, 0.5); 
		this->speed.x = (direction) ? 0.5f : -0.5f;
		this->direction ^= 1;
		x_speed_inc = 0.0;
	}
	void daSamurshai::executeState_Turn() { 

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
		int done = SmoothRotation(&this->rot.y, amt, 0x1000);

		if(done) {
			this->doStateChange(&StateID_Walk);
		}
	}
	void daSamurshai::endState_Turn() { }

///////////////
// Chop State
///////////////
	void daSamurshai::beginState_Chop() { 
		bindAnimChr_and_setUpdateRate("c18_H_CUT_R", 1, 0.0, 1.0);
		chrAnimation.setCurrentFrame(0.0);
		timer = 0;
		
	}
	void daSamurshai::executeState_Chop() { 

		speed.x = speed.x / 1.5;

		if (chrAnimation.getCurrentFrame() == 15.0) {
			MapSoundPlayer(SoundRelatedClass, SE_EMY_CRASHER_PUNCH, 1);
			if (this->direction == 1) { 
				SpawnEffect("Wm_ob_itemget_ring", 0, &(Vec){pos.x - 18.0, pos.y + 16.0, pos.z-200.0}, &(S16Vec){0,0,0}, &(Vec){2.5, 0.5, 1.5});
				Chuckles.addToList();
			}
			else {
				SpawnEffect("Wm_ob_itemget_ring", 0, &(Vec){pos.x + 18.0, pos.y + 16.0, pos.z-200.0}, &(S16Vec){0,0,0}, &(Vec){2.5, 0.5, 1.5});
				Knuckles.addToList();
			}	
		}

		if (chrAnimation.getCurrentFrame() == 20.0) {
			MapSoundPlayer(SoundRelatedClass, SE_OBJ_WOOD_BOX_BREAK, 1);
			if (this->direction == 1) { 
				SpawnEffect("Wm_en_hit", 0, &(Vec){pos.x - 38.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
				SpawnEffect("Wm_en_hanapetal", 0, &(Vec){pos.x - 38.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){2.0, 2.0, 2.0});
				Chuckles.removeFromList();
			}
			else {
				SpawnEffect("Wm_en_hit", 0, &(Vec){pos.x + 38.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
				SpawnEffect("Wm_en_hanapetal", 0, &(Vec){pos.x + 38.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){2.0, 2.0, 2.0});
				Knuckles.removeFromList();	
			}
		}

		if(this->chrAnimation.isAnimationDone()) {
			timer += 1;
			if (timer > 45) {
				walkStateIsCharging = false;
				doStateChange(&StateID_Walk);
			}
		}
	}
	void daSamurshai::endState_Chop() { }

///////////////
// ChargeSlash State
///////////////
	void daSamurshai::beginState_ChargeSlash() { 
		timer = 0;
		slowDown = false;
		topHurts = false;
		speed.x = 0.0;
	}
	void daSamurshai::executeState_ChargeSlash() { 

		// End if the animation is finally over
		if ((chrAnimation.isAnimationDone()) && (slowDown) ) {
			walkStateIsCharging = false;
			doStateChange(&StateID_Walk);
			return;
		}

		// What to do if he hits a wall
		bool ret = calculateTileCollisions();
		if (ret) {
			OSReport("Hit the wall");
			bindAnimChr_and_setUpdateRate("c18_R_BLOCK_BREAK_R", 1, 0.0, 1.0);
			speed.x = (direction) ? 0.5f : -0.5f;
			topHurts = false;
			slowDown = true;
			timer = 500;
		}

		if (timer == 500) { speed.x = speed.x / 1.05; return; }

		// Begin the charge effect
		if (timer == 0) { bindAnimChr_and_setUpdateRate("c18_OB_IDLE_R", 1, 0.0, 0.5); 
			if (direction == 1)
				SpawnEffect("Wm_ob_keyget02_lighit", 0, &(Vec){pos.x + 7.0, pos.y + 14.0, pos.z - 5500.0}, &(S16Vec){0,0,0}, &(Vec){0.8, 0.8, 0.8});
			else 
				SpawnEffect("Wm_ob_keyget02_lighit", 0, &(Vec){pos.x - 7.0, pos.y + 14.0, pos.z + 5500.0}, &(S16Vec){0,0,0}, &(Vec){0.8, 0.8, 0.8});
		}

		// Start to cut
		if (timer == 60) { bindAnimChr_and_setUpdateRate("c18_H_CUT_R", 1, 0.0, 1.0); }

		// After enough charging, speed on!
		if (timer == 70) { speed.x = (direction) ? -16.0f : 16.0f; chrAnimation.setUpdateRate(0.0); }

		// He should not be able to be hurt for a while
		if (timer == 72) { topHurts = true; }

		OSReport("Speed: %f @ %d", speed.x, timer);
		float absSpeed; 
		if (speed.x < 0.0) { absSpeed = -speed.x; }
		else			   { absSpeed =  speed.x; }

		// Can be bopped again when he gets slow enough
		if (absSpeed < 1.0) { topHurts = false; chrAnimation.setUpdateRate(1.0); }

		// During the dash
		if (absSpeed > 0.0) {
			// Slow that horsey down, tiger
			if (slowDown) { speed.x = speed.x / 1.5; return; }

			effect.spawn("Wm_mr_p_iceslip", 0, &(Vec){pos.x, pos.y+8.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});			
			SpawnEffect("Wm_en_hanapetal", 0, &pos, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});
			SpawnEffect("Wm_ob_itemget_ring", 0, &(Vec){pos.x, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){4.0, 0.1, 1.5});

			if (timer == 75) { slowDown = true; }
			// Positive if Mario is left of Samurai, negative if he is to the right
			// float xDistance = pos.x - chosenOne->pos.x;

			// // direction 1 is going left, direction 0 is going right
			// if ((xDistance > 0) && (direction == 0)) { 
			// 	SpawnEffect("Wm_ob_itemget_ring", 0, &(Vec){pos.x, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){4.0, 0.1, 1.5});
			// 	slowDown = true; }

			// if ((xDistance < 0) && (direction == 1)) { 
			// 	SpawnEffect("Wm_ob_itemget_ring", 0, &(Vec){pos.x, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){4.0, 0.1, 1.5});
			// 	slowDown = true; }
		}

		this->timer += 1;
	}
	void daSamurshai::endState_ChargeSlash() { 
		slowDown = false;
	}

///////////////
// Uppercut State
///////////////
	void daSamurshai::beginState_Uppercut() { 
		bindAnimChr_and_setUpdateRate("c18_H_SHOT_R", 1, 0.0, 2.0);
		slowDown = false;
		timer = 0;
	}
	void daSamurshai::executeState_Uppercut() { 

		if ((slowDown) && (this->chrAnimation.isAnimationDone())) {
			timer++;
			if (timer > 45) {
				walkStateIsCharging = false;
				doStateChange(&StateID_Walk);
			}
		}

		if (slowDown) {
			return;
		}

		if (this->chrAnimation.getCurrentFrame() == 34.0) {
			topHurts = true;
			MapSoundPlayer(SoundRelatedClass, SE_EMY_CRASHER_PUNCH, 1);
			MapSoundPlayer(SoundRelatedClass, SE_BOSS_CMN_JUMP_M, 1);

			speed.y = 4.0;
			y_speed_inc = -0.1875;

			if (this->direction == 1) { 
				effect.spawn("Wm_ob_itemget_ring", 0, &(Vec){pos.x - 48.0, pos.y + 32.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){0.5, 1.5, 1.5});
				Chuckles.addToList();
			}
			else {
				effect.spawn("Wm_ob_itemget_ring", 0, &(Vec){pos.x + 48.0, pos.y + 32.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){0.5, 1.5, 1.5});
				Knuckles.addToList();
			}	
		}

		if (this->chrAnimation.getCurrentFrame() == 64.0) {
			if (topHurts) {
				if (this->direction == 1) { 
					SpawnEffect("Wm_en_hit", 0, &(Vec){pos.x - 38.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
					SpawnEffect("Wm_en_hanapetal", 0, &(Vec){pos.x - 38.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){2.0, 2.0, 2.0});
					Chuckles.removeFromList();
				}
				else {
					SpawnEffect("Wm_en_hit", 0, &(Vec){pos.x + 38.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
					SpawnEffect("Wm_en_hanapetal", 0, &(Vec){pos.x + 38.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){2.0, 2.0, 2.0});
					Knuckles.removeFromList();	
				}

				MapSoundPlayer(SoundRelatedClass, SE_OBJ_WOOD_BOX_BREAK, 1);
				topHurts = false;
			}
		}

		if ((this->chrAnimation.getCurrentFrame() > 34.0) && (speed.y == 0)) {
			speed.x = 0.0f; 
		}

		if ((this->chrAnimation.isAnimationDone()) && (speed.y == 0.0)) { 
			bindAnimChr_and_setUpdateRate("c18_DIVING_STEAL_R", 1, 0.0, 1.0);
			slowDown = true;
		}	

		bool ret = calculateTileCollisions();
	}
	void daSamurshai::endState_Uppercut() { slowDown = false; }

///////////////
// SpinAttack State
///////////////
	void daSamurshai::beginState_SpinAttack() { 
		bindAnimChr_and_setUpdateRate("c18_NORMAL_STEAL_R", 1, 0.0, 1.0);
	}
	void daSamurshai::executeState_SpinAttack() { 

		if((int)this->chrAnimation.getCurrentFrame() == 20) {
			topHurts = true;
			PlaySoundAsync(this, SE_EMY_CRASHER_PUNCH);

			speed.y = 3.0;
			y_speed_inc = -0.1875;

			if (this->direction == 1) { Chuckles.addToList(); }
			else { Knuckles.addToList(); }	
		}

		if (((int)chrAnimation.getCurrentFrame() > 20) && ((int)this->chrAnimation.getCurrentFrame() < 60)) {
			scale = (Vec){1.0, 1.0, 1.0};
			if (this->direction == 1) { 
				effect.spawn("Wm_mr_spinjump", 0, &(Vec){pos.x - 18.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &scale);
			}
			else {
				effect.spawn("Wm_mr_spinjump", 0, &(Vec){pos.x + 18.0, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &scale);
			}
		}

		if((int)this->chrAnimation.getCurrentFrame() == 65) {
			topHurts = false;
			PlaySoundAsync(this, SE_EMY_CRASHER_PUNCH);

			if (this->direction == 1) { Chuckles.removeFromList(); }
			else { Knuckles.removeFromList(); }	
		}

		if ((this->chrAnimation.isAnimationDone()) && (speed.y == 0.0)) {
			walkStateIsCharging = false;
			doStateChange(&StateID_Walk);
		}

		bool ret = calculateTileCollisions();

	}
	void daSamurshai::endState_SpinAttack() { 
	}

///////////////
// Damage State
///////////////
	void daSamurshai::beginState_Damage() {
		bindAnimChr_and_setUpdateRate("c18_L_DMG_F_1_R", 1, 0.0, 1.0); 

		this->max_speed.x = 0;
		this->speed.x = 0;
		this->x_speed_inc = 0;

		this->max_speed.y = -2.0;
		this->speed.y = -2.0;
		this->y_speed_inc = -0.1875;

		this->timer = 0;
		this->isDown = 1;

		Chuckles.removeFromList();
		Knuckles.removeFromList();
		aPhysics.removeFromList();

		SpawnEffect("Wm_ob_switch", 0, &(Vec){pos.x, pos.y + 16.0, pos.z}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		MapSoundPlayer(SoundRelatedClass, SE_BOSS_CMN_DAMAGE_DEF, 1);
	}
	void daSamurshai::executeState_Damage() { 
		calculateTileCollisions();
	
		effect.spawn("Wm_en_spindamage", 0, &(Vec){pos.x, pos.y + 40.0, 0}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});

		if (this->chrAnimation.isAnimationDone()) {
			if 		(timer == 0) { bindAnimChr_and_setUpdateRate("c18_L_DMG_F_3_R", 1, 0.0, 1.0); timer = 1; }
			else if (timer == 1) { bindAnimChr_and_setUpdateRate("c18_L_DMG_F_4_R", 1, 0.0, 1.0); timer = 2; }
			else if (timer == 2) {
				walkStateIsCharging = true;
				amountCharged = 0.0f;
				doStateChange(&StateID_Walk);
			}
		}
	}
	void daSamurshai::endState_Damage() {
		aPhysics.addToList();

		this->isDown = 0;		
		this->rot.y = (direction) ? 0xD800 : 0x2800;
	}

///////////////
// Outro State
///////////////
	void daSamurshai::beginState_Outro() { 

		bindAnimChr_and_setUpdateRate("c18_SP_BLOCK_R", 1, 0.0, 1.0); 
		OutroSetup(this);
		aPhysics.removeFromList();

		this->max_speed.x = 0;
		this->speed.x = 0;
		this->x_speed_inc = 0;

		this->max_speed.y = -2.0;
		this->speed.y = -2.0;
		this->y_speed_inc = -0.1875;

		this->timer = 0;
		this->isDown = 1;

		Chuckles.removeFromList();
		Knuckles.removeFromList();
		MapSoundPlayer(SoundRelatedClass, SE_BOSS_CMN_DAMAGE_LAST, 1);

	}
	void daSamurshai::executeState_Outro() {
		calculateTileCollisions();

		if (this->dying == 1) { 

			if (this->timer > 180) { ExitStage(WORLD_MAP, 0, BEAT_LEVEL, MARIO_WIPE); }
			if (this->timer == 60) { PlayerVictoryCries(this); }	
			
			this->timer += 1;
			return; 
		}	

		if ((chrAnimation.getCurrentFrame() == 41.0) || (chrAnimation.getCurrentFrame() == 62.0)) {
			SpawnEffect("Wm_en_landsmoke_s", 0, &(Vec){pos.x, pos.y - 8.0, pos.z + 500.0}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		}

		if (chrAnimation.isAnimationDone()) { 
			SpawnEffect("Wm_ob_cmnshotstar", 0, &(Vec){pos.x + 8.0, pos.y - 8.0, pos.z + 500.0}, &(S16Vec){0,0,0}, &(Vec){1.75, 1.75, 1.75});
			SpawnEffect("Wm_mr_wirehit_hit", 0, &(Vec){pos.x + 8.0, pos.y, pos.z + 500.0}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});

			MapSoundPlayer(SoundRelatedClass, STRM_BGM_SHIRO_BOSS_CLEAR, 1);
			BossGoalForAllPlayers();

			this->dying = 1;
			this->timer = 0;	
		}
	
		this->timer += 1;
	}
	void daSamurshai::endState_Outro() { }

bool daSamurshai::isNearWall() {
	// back up our current settings
	VEC3 savePos = pos;
	VEC3 saveSpeed = speed;
	int saveDirection = direction;

	float checkLeft = (direction == 0) ? 8.0f : 104.0f;
	float checkRight = (direction == 0) ? 104.0f : 8.0f;

	bool result = false;

	speed.x = -0.1f;
	speed.y = 0.0f;
	pos.x = savePos.x - checkLeft;
	direction = 1; // left
	if (collMgr.calculateAdjacentCollision())
		result = true;

	speed.x = 0.1f;
	speed.y = 0.0f;
	pos.x = savePos.x + checkRight;
	direction = 0; // right
	if (collMgr.calculateAdjacentCollision())
		result = true;

	// restore our settings
	pos = savePos;
	speed = saveSpeed;
	direction = saveDirection;

	return result;
}


//
// processed\../src/bossTopman.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include <stage.h>
#include <profile.h>
#include "boss.h"

const char* STMarcNameList [] = {
	"topman",
	NULL	
};

class daDreidel : public daBoss {
public:
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;

	m3d::mdl_c bodyModel;

	m3d::anmChr_c chrAnimation;

	char isDown;
	float XSpeed;
	u32 cmgr_returnValue;
	bool isBouncing;
	char isInSpace;
	char fromBehind;
	char isInvulnerable;
	int isInvulnerableCountdown;
	int isTurningCountdown;
	char charging;
	int flashing;

	float dying;

	static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();
	bool calculateTileCollisions();

	void powBlockActivated(bool isNotMPGP);

	void spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	void addScoreWhenHit(void *other);

	USING_STATES(daDreidel);
	DECLARE_STATE(Walk);
	DECLARE_STATE(Turn);
	DECLARE_STATE(KnockBack);

	DECLARE_STATE(ChargePrep);
	DECLARE_STATE(Charge);
	DECLARE_STATE(ChargeRecover);
	DECLARE_STATE(Damage);

	DECLARE_STATE(Grow);
	DECLARE_STATE(Outro);

};

const SpriteData SuperTopmanSpriteData = { ProfileId::SuperTopman, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile SuperTopmanProfile(&daDreidel::build, SpriteId::SuperTopman, SuperTopmanSpriteData, ProfileId::SLOW_QUICK_TAG, ProfileId::SuperTopman, "Topman", STMarcNameList);

dActor_c *daDreidel::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daDreidel));
	return new(buffer) daDreidel;
}

///////////////////////
// Externs and States
///////////////////////
	extern "C" void *EN_LandbarrelPlayerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
	// CalculateDistanceFromActorsNextPosToFurthestPlayer???
	extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);


	CREATE_STATE(daDreidel, Walk);
	CREATE_STATE(daDreidel, Turn);
	CREATE_STATE(daDreidel, KnockBack);

	CREATE_STATE(daDreidel, ChargePrep);
	CREATE_STATE(daDreidel, Charge);
	CREATE_STATE(daDreidel, ChargeRecover);
	CREATE_STATE(daDreidel, Damage);

	CREATE_STATE(daDreidel, Grow);
	CREATE_STATE(daDreidel, Outro);

	// 	begoman_attack2"	// wobble back and forth tilted forwards
	// 	begoman_attack3"	// Leaned forward, antennae extended
	// 	begoman_damage"		// Bounces back slightly
	// 	begoman_damage2"	// Stops spinning and wobbles to the ground like a top
	// 	begoman_stand"		// Stands still, waiting
	// 	begoman_wait"		// Dizzily Wobbles
	// 	begoman_wait2"		// spins around just slightly
	// 	begoman_attack"		// Rocks backwards, and then attacks to an upright position, pulsing out his antennae


////////////////////////
// Collision Functions
////////////////////////
	// void topCollisionCallback(ActivePhysics *apThis, ActivePhysics *apOther);

	// void topCollisionCallback(ActivePhysics *apThis, ActivePhysics *apOther) {
	// 	OSReport("Collided with %d", apOther->owner->name);
	// 	if (apOther->owner->name != 041) { 
	// 		dEn_c::collisionCallback(apThis, apOther); 
	// 	}
	// 	else {
	// 		daDreidel *actor = (daDreidel*)apThis->owner;
	// 		actor->damage += 1;
	// 		actor->doStateChange(&daDreidel::StateID_Damage);

	// 		if (actor->damage > 2) { actor->doStateChange(&daDreidel::StateID_Outro); }
	// 	}
	// }
	void daDreidel::addScoreWhenHit(void *other) { };

	void daDreidel::spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		if (apOther->owner->name == 390) { //time to get hurt
			OSReport("YO SUP I'M A TOPMAN AND I'M COLLIDING WITH A FUCKING WALL [%d]\n", damage);
			if (this->isInvulnerable) {
				OSReport("I'm invulnerable so I'm ignoring it\n");
				return;
			}
			this->damage += 1;
			OSReport("I'm increasing my damage to %d\n", damage);
			doStateChange(&StateID_Damage);

			if (this->damage == 3) { doStateChange(&StateID_Outro); }
		}
		else { dEn_c::spriteCollision(apThis, apOther); }
	}

	void daDreidel::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {


		char hitType;
		hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);

		if(hitType > 0) {
			this->_vf220(apOther->owner);
			this->counter_504[apOther->owner->which_player] = 0;
		} else {

			if (this->charging == 1) {

				char MarioPos;

				if (this->pos.x < apOther->owner->pos.x) { MarioPos = 0; } // Mario is to the right
				else 									 { MarioPos = 1; } // Mario is to the left
				

				if (this->direction != MarioPos) {	// Mario is stnading behind the boss
					EN_LandbarrelPlayerCollision(this, apThis, apOther);
					if (MarioPos == 1)  { this->direction = 1; }
					else 				{ this->direction = 0; }

					doStateChange(&StateID_KnockBack);
				}

				else { // Mario is standing in front of the boss
					this->_vf220(apOther->owner);
					EN_LandbarrelPlayerCollision(this, apThis, apOther);
				}
			}

			else if (this->isInvulnerable == 0) { 

				if (this->pos.x > apOther->owner->pos.x) {
					this->direction = 1;
				}
				else {
					this->direction = 0;
				}
			
				this->counter_504[apOther->owner->which_player] = 0;
				EN_LandbarrelPlayerCollision(this, apThis, apOther);
				doStateChange(&StateID_KnockBack);
			}
			else {
				this->counter_504[apOther->owner->which_player] = 0;
				EN_LandbarrelPlayerCollision(this, apThis, apOther);
			}
		} 

		deathInfo.isDead = 0;
		this->flags_4FC |= (1<<(31-7));
	}

	void daDreidel::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->playerCollision(apThis, apOther);
	}

	bool daDreidel::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
		DamagePlayer(this, apThis, apOther);
		return true;
	}
	bool daDreidel::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
		DamagePlayer(this, apThis, apOther);
		return true;
	}
	bool daDreidel::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
		DamagePlayer(this, apThis, apOther);
		return true;
	}

	bool daDreidel::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) { 
		if (this->isInvulnerable == 0) { 
			doStateChange(&StateID_KnockBack);
		}
		return true;
	}
	bool daDreidel::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){ 
		if (this->isInvulnerable == 0) { 
			doStateChange(&StateID_KnockBack);
		}
		return true;
	}


	bool daDreidel::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){ return true; }
	bool daDreidel::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) { return true; }
	bool daDreidel::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){ return true; }
	bool daDreidel::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) { return true; }
	bool daDreidel::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) { return true; }

void daDreidel::powBlockActivated(bool isNotMPGP) { }


bool daDreidel::calculateTileCollisions() {
	// Returns true if sprite should turn, false if not.

	HandleXSpeed();
	HandleYSpeed();
	doSpriteMovement();

	cmgr_returnValue = collMgr.isOnTopOfTile();
	collMgr.calculateBelowCollisionWithSmokeEffect();

	if (isBouncing) {
		stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);
		if (speed.y != 0.0f)
			isBouncing = false;
	}

	float xDelta = pos.x - last_pos.x;
	if (xDelta >= 0.0f)
		direction = 0;
	else
		direction = 1;

	if (collMgr.isOnTopOfTile()) {
		// Walking into a tile branch

		if (cmgr_returnValue == 0)
			isBouncing = true;

		if (speed.x != 0.0f) {
			//playWmEnIronEffect();
		}

		speed.y = 0.0f;

		// u32 blah = collMgr.s_80070760();
		// u8 one = (blah & 0xFF);
		// static const float incs[5] = {0.00390625f, 0.0078125f, 0.015625f, 0.0234375f, 0.03125f};
		// x_speed_inc = incs[one];
		max_speed.x = (direction == 1) ? -1.0f : 1.0f;
	} else {
		x_speed_inc = 0.0f;
	}

	// Bouncing checks
	if (_34A & 4) {
		Vec v = (Vec){0.0f, 1.0f, 0.0f};
		collMgr.pSpeed = &v;

		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;

		collMgr.pSpeed = &speed;

	} else {
		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;
	}

	collMgr.calculateAdjacentCollision(0);

	// Switch Direction
	if (collMgr.outputMaybe & (0x15 << direction)) {
		if (collMgr.isOnTopOfTile()) {
			isBouncing = true;
		}
		return true;
	}
	return false;
}

void daDreidel::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daDreidel::onCreate() {
	
	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("topman", "g3d/begoman_spike.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("begoman");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Map(&bodyModel, 0);


	// Animations start here
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("begoman_wait");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	// Stuff I do understand
	this->scale = (Vec){0.2, 0.2, 0.2};

	// this->pos.y = this->pos.y + 30.0; // X is vertical axis
	this->rot.x = 0; // X is vertical axis
	this->rot.y = 0xD800; // Y is horizontal axis
	this->rot.z = 0; // Z is ... an axis >.>
	this->direction = 1; // Heading left.
	
	this->speed.x = 0.0;
	this->speed.y = 0.0;
	this->max_speed.x = 1.1;
	this->x_speed_inc = 0.0;
	this->XSpeed = 1.1;

	this->isInSpace = this->settings & 0xF;
	this->fromBehind = 0;
	this->flashing = 0; 


	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 24.0;

	HitMeBaby.xDistToEdge = 28.0;
	HitMeBaby.yDistToEdge = 24.0;		

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	// Tile collider

	// These fucking rects do something for the tile rect
	spriteSomeRectX = 28.0f;
	spriteSomeRectY = 32.0f;
	_320 = 0.0f;
	_324 = 16.0f;

	// These structs tell stupid collider what to collide with - these are from koopa troopa
	static const lineSensor_s below(12<<12, 4<<12, 0<<12);
	static const pointSensor_s above(0<<12, 12<<12);
	static const lineSensor_s adjacent(6<<12, 9<<12, 6<<12);

	collMgr.init(this, &below, &above, &adjacent);
	collMgr.calculateBelowCollisionWithSmokeEffect();

	cmgr_returnValue = collMgr.isOnTopOfTile();

	if (collMgr.isOnTopOfTile())
		isBouncing = false;
	else
		isBouncing = true;


	// State Changers
	bindAnimChr_and_setUpdateRate("begoman_wait2", 1, 0.0, 1.0); 
	doStateChange(&StateID_Grow);

	this->onExecute();
	return true;
}

int daDreidel::onDelete() {
	return true;
}

int daDreidel::onExecute() {
	acState.execute();
	updateModelMatrices();
	
	return true;
}

int daDreidel::onDraw() {

	if (this->isInvulnerable == 1) {
		this->flashing++;
	}

	if (this->flashing < 5) {
		bodyModel.scheduleForDrawing();
	}

	bodyModel._vf1C();

	if (this->flashing > 8) { this->flashing = 0; }

	return true;
}

void daDreidel::updateModelMatrices() {
	matrix.translation(pos.x, pos.y - 2.0, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}



///////////////
// Grow State
///////////////
	void daDreidel::beginState_Grow() { 
		bindAnimChr_and_setUpdateRate("begoman_wait2", 1, 0.0, 0.75); 

		this->timer = 0;

		SetupKameck(this, Kameck);
	}

	void daDreidel::executeState_Grow() { 
		
		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		this->timer += 1;
		
		bool ret;
		ret = GrowBoss(this, Kameck, 0.2, 0.4, 0, this->timer);

		if (ret) { 	
			PlaySound(this, SE_EMY_MECHAKOOPA_BOUND);
			doStateChange(&StateID_Walk); 
		}
	}
	void daDreidel::endState_Grow() { 
		this->chrAnimation.setUpdateRate(1.0);
		CleanupKameck(this, Kameck);
	}


///////////////
// Walk State
///////////////
	void daDreidel::beginState_Walk() {
		this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
		this->speed.x = (direction) ? -1.2f : 1.2f;

		this->max_speed.y = (this->isInSpace) ? -2.0 : -4.0;
		this->speed.y = 	(this->isInSpace) ? -2.0 : -4.0;
		this->y_speed_inc = (this->isInSpace) ? -0.09375 : -0.1875;

		this->isTurningCountdown = 0;
	}
	void daDreidel::executeState_Walk() { 

		if (this->isInvulnerableCountdown > 0) {
			this->isInvulnerableCountdown--;
		}
		else {
			this->isInvulnerable = 0;
			this->flashing = 0;
		}

		PlaySound(this, SE_BOSS_JR_CROWN_JR_RIDE); // 5
	
		bool ret = calculateTileCollisions();
		if (ret) {
			doStateChange(&StateID_Turn);
		}

		u8 dir = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
		if (dir != this->direction) {
			this->isTurningCountdown++;
		}

		if (this->isTurningCountdown > 60) { doStateChange(&StateID_Turn); }

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}
	}
	void daDreidel::endState_Walk() { this->timer += 1; }


///////////////
// Turn State
///////////////
	void daDreidel::beginState_Turn() {
		this->direction ^= 1;
		this->speed.x = 0.0;
	}
	void daDreidel::executeState_Turn() { 

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
		int done = SmoothRotation(&this->rot.y, amt, 0x800);

		if(done) {
			if (this->damage > 0) 	{ doStateChange(&StateID_ChargePrep); }
			else 					{ doStateChange(&StateID_Walk); }
		}
	}
	void daDreidel::endState_Turn() { this->rot.y = (this->direction) ? 0xD800 : 0x2800; }


///////////////
// Knockback State
///////////////
	void daDreidel::beginState_KnockBack() {
		bindAnimChr_and_setUpdateRate("begoman_damage", 1, 0.0, 0.65); 

		this->max_speed.x = (this->direction) ? 6.5f : -6.5f;
		this->speed.x = (this->direction) ? 6.5f : -6.5f;
	}
	void daDreidel::executeState_KnockBack() { 

		bool ret = calculateTileCollisions();
		if (ret) {
			this->max_speed.x = -this->max_speed.x;
			this->speed.x = -this->speed.x;
		}
		this->speed.x = this->speed.x / 1.08;

		bodyModel._vf1C();
		if(this->chrAnimation.isAnimationDone()) {
			if (this->damage > 0) 	{ doStateChange(&StateID_ChargePrep); }
			else 					{ doStateChange(&StateID_Walk); }
		}

	}
	void daDreidel::endState_KnockBack() { 
		if (this->rot.y == 0x2800) {
			// CreateEffect(&this->pos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0}, 175);
			this->direction = 0; 
		}
		else {
			// CreateEffect(&this->pos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0}, 192);
			this->direction = 1; 
		}
		// this->direction ^= 1;
		bindAnimChr_and_setUpdateRate("begoman_wait2", 1, 0.0, 1.0); 
	}


///////////////
// ChargePrep State
///////////////
	void daDreidel::beginState_ChargePrep() {
		bindAnimChr_and_setUpdateRate("begoman_attack", 1, 0.0, 0.9); 
	}
	void daDreidel::executeState_ChargePrep() { 
		if(this->chrAnimation.isAnimationDone()) {
			doStateChange(&StateID_Charge);
		}
	}
	void daDreidel::endState_ChargePrep() { }


///////////////
// Charge State
///////////////
	void daDreidel::beginState_Charge() {
		bindAnimChr_and_setUpdateRate("begoman_attack3", 1, 0.0, 1.0); 
		this->timer = 0;
		this->isTurningCountdown = 0;

		this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
		this->speed.x = (direction) ? -2.6f : 2.6f;

		this->max_speed.y = (this->isInSpace) ? -2.0 : -4.0;
		this->speed.y = 	(this->isInSpace) ? -2.0 : -4.0;
		this->y_speed_inc = (this->isInSpace) ? -0.09375 : -0.1875;

		this->charging = 1;
	}
	void daDreidel::executeState_Charge() { 

		if (this->isInvulnerableCountdown > 0) {
			this->isInvulnerableCountdown--;
		}
		else {
			this->isInvulnerable = 0;
			this->flashing = 0;
		}

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		bool ret = calculateTileCollisions();
		if (ret) {
			doStateChange(&StateID_ChargeRecover);
		}

		u8 dir = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
		if (dir != this->direction) {
			this->isTurningCountdown++;
			this->speed.x = this->speed.x / 1.04;
		}

		if (this->isTurningCountdown > 90) { doStateChange(&StateID_Turn); }
	}
	void daDreidel::endState_Charge() { 
		this->charging = 0; 

		this->counter_504[0] = 0;
		this->counter_504[1] = 0;
		this->counter_504[2] = 0;
		this->counter_504[3] = 0;
	}


///////////////
// ChargeRecover State
///////////////
	void daDreidel::beginState_ChargeRecover() {
		bindAnimChr_and_setUpdateRate("begoman_stand", 1, 0.0, 0.5); 
	}
	void daDreidel::executeState_ChargeRecover() { 
		if(this->chrAnimation.isAnimationDone()) {
			doStateChange(&StateID_Turn);
		}
	}
	void daDreidel::endState_ChargeRecover() { }


///////////////
// Damage State
///////////////
	void daDreidel::beginState_Damage() {
		this->isInvulnerable = 1;
		bindAnimChr_and_setUpdateRate("begoman_wait", 1, 0.0, 0.75); 
		this->timer = 0;

		PlaySound(this, SE_PLY_TOUCH_BIRI);
		PlaySound(this, SE_BOSS_JR_ELEC_SPARK);
		PlaySound(this, SE_EMY_BIRIKYU_SPARK);

		Vec front = {this->pos.x-4.0, this->pos.y+8.0, 5500.0};
		Vec back = {this->pos.x-4.0, this->pos.y+8.0, -5500.0};

		SpawnEffect("Wm_ob_cmnspark", 0, &front, 0, &(Vec){2.5, 2.5, 1.5});
		SpawnEffect("Wm_mr_wirehit_line", 0, &front, 0, &(Vec){1.5, 1.5, 1.5});
		SpawnEffect("Wm_mr_kick_grain", 0, &front, 0, &(Vec){1.5, 1.5, 1.5});
		SpawnEffect("Wm_mr_wirehit_glow", 0, &back, 0, &(Vec){2.5, 2.5, 2.5});
	}
	void daDreidel::executeState_Damage() { 

		if(this->chrAnimation.isAnimationDone()) {
			this->timer += 1;
			if (this->timer == 1) {

				u8 dir = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
				if (dir != this->direction) {
					doStateChange(&StateID_Turn);
				}
				else {
					if (this->damage > 1) 	{ doStateChange(&StateID_ChargePrep); }
					else 					{ doStateChange(&StateID_Walk); }
				}
			}
			else {
			}
			this->chrAnimation.setCurrentFrame(0.0);
		}
	}
	void daDreidel::endState_Damage() { 
		bindAnimChr_and_setUpdateRate("begoman_wait2", 1, 0.0, 1.0); 
		this->isInvulnerableCountdown = 90; 
	}


///////////////
// Outro State
///////////////
	void daDreidel::beginState_Outro() { 
		OutroSetup(this);
	}
	void daDreidel::executeState_Outro() {

		if (this->dying == 1) { 
			if (this->timer > 180) { ExitStage(WORLD_MAP, 0, BEAT_LEVEL, MARIO_WIPE); }
			if (this->timer == 60) { PlayerVictoryCries(this); }	
			
			this->timer += 1;
			return; 
		}	

		bool ret;
		ret = ShrinkBoss(this, &this->pos, 0.5, this->timer);

		if (ret == true) 	{ 
			BossExplode(this, &this->pos); 
			this->dying = 1;
			this->timer = 0;	
		}
		else 		{ PlaySound(this, SE_EMY_BUBBLE_EXTINCT); }
	
		this->timer += 1;
	}
	void daDreidel::endState_Outro() { }

//
// processed\../src/effectvideo.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>

extern "C" bool SpawnEffect(const char*, int, Vec*, S16Vec*, Vec*);

class EffectVideo : public dEn_c {
	int onCreate();
	int onExecute();
	int onDelete();

	u64 eventFlag;
	s32 timer;
	u32 delay;

	u32 effect;
	u8 type;
	float effect_scale;

	static EffectVideo *build();

};


EffectVideo *EffectVideo::build() {
	void *buffer = AllocFromGameHeap1(sizeof(EffectVideo));
	return new(buffer) EffectVideo;
}


int EffectVideo::onCreate() {
	
	this->timer = 0;

	char eventNum	= (this->settings >> 24) & 0xFF;

	this->eventFlag = (u64)1 << (eventNum - 1);
	
	this->type		= (this->settings >> 16) & 0xF;
	this->effect	= this->settings & 0xFFF;
	this->effect_scale	= float((this->settings >> 20) & 0xF) / 4.0;
	this->delay		= (this->settings >> 12) & 0xF * 30;
	
	if (this->effect_scale == 0.0) { this->effect_scale = 1.0; }

	this->onExecute();
	return true;
}


int EffectVideo::onDelete() {
	return true;
}


int EffectVideo::onExecute() {

	if (dFlagMgr_c::instance->flags & this->eventFlag) {

		if (this->timer == this->delay) {

			if (this->type == 0) { // Plays a sound
				PlaySoundAsync(this, this->effect);
			}
	
			else {	// Plays an Effect

				const char *efName = 0;
				
				// Effect notes:
				// Values 1-675 will always work
				// Values 676-746 require Iggy (sprites 337/372) or the Magic Fireball Spawn Area
				// Values 747-821 require Bowser Jr. (sprites 211/405/406) or the Bowser Jr. Castle Cutscene (sprite 408)
				// Values 822-906 require Kamek (sprite 383)
				// Values 907-981 require Bowser (sprite 419) and Bowser Fireballs (sprite 449) with the custom code
				// Values 982-1045 require Larry (sprites 189/192) or the Magic Fireball Spawn Area
				// Values 1046-1109 require Lemmy (sprites 340/381)
				// Values 1110-1174 require Ludwig (sprites 348/365)
				// Values 1175-1258 require Morton (sprites 344/349)
				// Values 1259-1329 require Roy (sprite 364) or the Magic Fireball Spawn Area
				// Values 1330-1395 require Wendy (sprites 336/375)
				// Values 1396-1608 only work in Multiplayer mode
				// Values 1609-1661 only work if the Ambush flag in the Area Settings is enabled

				switch (this->effect) {
					case 1: efName = "Wm_2d_1up01"; break;
					case 2: efName = "Wm_2d_1up02"; break;
					case 3: efName = "Wm_2d_coin100"; break;
					case 4: efName = "Wm_2d_coin100a"; break;
					case 5: efName = "Wm_2d_coinlight"; break;
					case 6: efName = "Wm_2d_continue"; break;
					case 7: efName = "Wm_2d_courseclear"; break;
					case 8: efName = "Wm_2d_courseclearsmcld01"; break;
					case 9: efName = "Wm_2d_courseclearsmcld02"; break;
					case 10: efName = "Wm_2d_courseclear_cld"; break;
					case 11: efName = "Wm_2d_courseclear_da"; break;
					case 12: efName = "Wm_2d_courseclear_kiraL"; break;
					case 13: efName = "Wm_2d_courseclear_kiraR"; break;
					case 14: efName = "Wm_2d_courseclear_smkL"; break;
					case 15: efName = "Wm_2d_courseclear_smkR"; break;
					case 16: efName = "Wm_2d_gameover"; break;
					case 17: efName = "Wm_2d_gameover_a"; break;
					case 18: efName = "Wm_2d_gameover_b"; break;
					case 19: efName = "Wm_2d_moviecoinkira"; break;
					case 20: efName = "Wm_2d_moviecoinvanish"; break;
					case 21: efName = "Wm_2d_movieopen"; break;
					case 22: efName = "Wm_2d_movieopen_a"; break;
					case 23: efName = "Wm_2d_movieopen_b1"; break;
					case 24: efName = "Wm_2d_movieopen_b2"; break;
					case 25: efName = "Wm_2d_mrstarkira"; break;
					case 26: efName = "Wm_2d_multiclear"; break;
					case 27: efName = "Wm_2d_result"; break;
					case 28: efName = "Wm_2d_resultno1"; break;
					case 29: efName = "Wm_2d_resultrest"; break;
					case 30: efName = "Wm_2d_resultscore"; break;
					case 31: efName = "Wm_2d_result_a1"; break;
					case 32: efName = "Wm_2d_result_a2"; break;
					case 33: efName = "Wm_2d_result_b1"; break;
					case 34: efName = "Wm_2d_result_b2"; break;
					case 35: efName = "Wm_2d_starcoinget"; break;
					case 36: efName = "Wm_2d_starcoinvanish"; break;
					case 37: efName = "Wm_2d_stockitem"; break;
					case 38: efName = "Wm_2d_stockitem_a"; break;
					case 39: efName = "Wm_2d_stockitem_b"; break;
					case 40: efName = "Wm_2d_timeup"; break;
					case 41: efName = "Wm_2d_timeupsmoke"; break;
					case 42: efName = "Wm_2d_timeupstar"; break;
					case 43: efName = "Wm_2d_timeupstarcld"; break;
					case 44: efName = "Wm_2d_titlestar01"; break;
					case 45: efName = "Wm_2d_titlestar02"; break;
					case 46: efName = "Wm_bg_volcano"; break;
					case 47: efName = "Wm_bg_volcano_a"; break;
					case 48: efName = "Wm_bg_volcano_b"; break;
					case 49: efName = "Wm_bs_kameckmagic"; break;
					case 50: efName = "Wm_bs_kameckmagic_a"; break;
					case 51: efName = "Wm_bs_kameckmagic_b"; break;
					case 52: efName = "Wm_bs_kameckmagic_c"; break;
					case 53: efName = "Wm_bs_kameckmagic_d"; break;
					case 54: efName = "Wm_bs_kameckmagic_e"; break;
					case 55: efName = "Wm_bs_kameckmagic_f"; break;
					case 56: efName = "Wm_en_atitismoke"; break;
					case 57: efName = "Wm_en_birikyu"; break;
					case 58: efName = "Wm_en_birikyu_biri"; break;
					case 59: efName = "Wm_en_birikyu_glw"; break;
					case 60: efName = "Wm_en_birikyu_kira"; break;
					case 61: efName = "Wm_en_blockcloud"; break;
					case 62: efName = "Wm_en_bombheibreak"; break;
					case 63: efName = "Wm_en_bombignition"; break;
					case 64: efName = "Wm_en_bomignition_gl01"; break;
					case 65: efName = "Wm_en_bomignition_ln"; break;
					case 66: efName = "Wm_en_bomignition_pati"; break;
					case 67: efName = "Wm_en_brakesmoke"; break;
					case 68: efName = "Wm_en_bubble"; break;
					case 69: efName = "Wm_en_bubble_a"; break;
					case 70: efName = "Wm_en_bubble_b"; break;
					case 71: efName = "Wm_en_burst_big"; break;
					case 72: efName = "Wm_en_burst_m"; break;
					case 73: efName = "Wm_en_burst_s"; break;
					case 74: efName = "Wm_en_burst_ss"; break;
					case 75: efName = "Wm_en_burst_water01"; break;
					case 76: efName = "Wm_en_burst_water02"; break;
					case 77: efName = "Wm_en_choroappear"; break;
					case 78: efName = "Wm_en_choroescape"; break;
					case 79: efName = "Wm_en_cmnmagmawave"; break;
					case 80: efName = "Wm_en_cmnwater"; break;
					case 81: efName = "Wm_en_cmnwater02"; break;
					case 82: efName = "Wm_en_cmnwaterdash"; break;
					case 83: efName = "Wm_en_cmnwatertail"; break;
					case 84: efName = "Wm_en_comattack"; break;
					case 85: efName = "Wm_en_crowattack_l"; break;
					case 86: efName = "Wm_en_crowattack_r"; break;
					case 87: efName = "Wm_en_crowfly"; break;
					case 88: efName = "Wm_en_crowhit"; break;
					case 89: efName = "Wm_en_dossunfall01"; break;
					case 90: efName = "Wm_en_dossunfall02"; break;
					case 91: efName = "Wm_en_dossunfall03"; break;
					case 92: efName = "Wm_en_explosion"; break;
					case 93: efName = "Wm_en_explosion_gl01"; break;
					case 94: efName = "Wm_en_explosion_gl02"; break;
					case 95: efName = "Wm_en_explosion_hd"; break;
					case 96: efName = "Wm_en_explosion_ln"; break;
					case 97: efName = "Wm_en_explosion_smk"; break;
					case 98: efName = "Wm_en_explosion_un"; break;
					case 99: efName = "Wm_en_firebar"; break;
					case 100: efName = "Wm_en_firebar_fire"; break;
					case 101: efName = "Wm_en_firebar_ind"; break;
					case 102: efName = "Wm_en_firebrnsign"; break;
					case 103: efName = "Wm_en_firebrnsignind"; break;
					case 104: efName = "Wm_en_firebros_fire"; break;
					case 105: efName = "Wm_en_firebros_fire_a"; break;
					case 106: efName = "Wm_en_firebros_fire_b"; break;
					case 107: efName = "Wm_en_fireburner"; break;
					case 108: efName = "Wm_en_fireburner3ind"; break;
					case 109: efName = "Wm_en_fireburner4ind"; break;
					case 110: efName = "Wm_en_fireburner6ind"; break;
					case 111: efName = "Wm_en_firesnkspark01"; break;
					case 112: efName = "Wm_en_firesnkspark02"; break;
					case 113: efName = "Wm_en_firesnk_icehitsmk_b"; break;
					case 114: efName = "Wm_en_firesnk_icehitsmk_h"; break;
					case 115: efName = "Wm_en_firesnk_icehit_b"; break;
					case 116: efName = "Wm_en_firesnk_icehit_h"; break;
					case 117: efName = "Wm_en_firevanish"; break;
					case 118: efName = "Wm_en_hanapetal"; break;
					case 119: efName = "Wm_en_hanapetal_a"; break;
					case 120: efName = "Wm_en_hanapetal_b"; break;
					case 121: efName = "Wm_en_hanasnort"; break;
					case 122: efName = "Wm_en_hanasnort_cld"; break;
					case 123: efName = "Wm_en_hanasnort_l"; break;
					case 124: efName = "Wm_en_hanasnort_r"; break;
					case 125: efName = "Wm_en_hit"; break;
					case 126: efName = "Wm_en_hit_ring"; break;
					case 127: efName = "Wm_en_huhubreath"; break;
					case 128: efName = "Wm_en_huhubreathstart"; break;
					case 129: efName = "Wm_en_huhudamage01"; break;
					case 130: efName = "Wm_en_huhudamage02"; break;
					case 131: efName = "Wm_en_huhufloat"; break;
					case 132: efName = "Wm_en_huhuhaze"; break;
					case 133: efName = "Wm_en_huhurevival01"; break;
					case 134: efName = "Wm_en_huhurevival02"; break;
					case 135: efName = "Wm_en_igafirehit"; break;
					case 136: efName = "Wm_en_iron"; break;
					case 137: efName = "Wm_en_keronpafire"; break;
					case 138: efName = "Wm_en_keronpafire_ca"; break;
					case 139: efName = "Wm_en_keronpafire_f"; break;
					case 140: efName = "Wm_en_keronpalight"; break;
					case 141: efName = "Wm_en_killershot"; break;
					case 142: efName = "Wm_en_killersmoke"; break;
					case 143: efName = "Wm_en_killervanish"; break;
					case 144: efName = "Wm_en_kingkiller"; break;
					case 145: efName = "Wm_en_kingkiller_gr"; break;
					case 146: efName = "Wm_en_kingkiller_rg"; break;
					case 147: efName = "Wm_en_kingkiller_sm"; break;
					case 148: efName = "Wm_en_kuribobigsplit"; break;
					case 149: efName = "Wm_en_kuribobigsplit_gr01"; break;
					case 150: efName = "Wm_en_kuribobigsplit_gr02"; break;
					case 151: efName = "Wm_en_kuribobigsplit_ht"; break;
					case 152: efName = "Wm_en_kuribobigsplit_rg"; break;
					case 153: efName = "Wm_en_kuribobigsplit_sk"; break;
					case 154: efName = "Wm_en_kuribosplit"; break;
					case 155: efName = "Wm_en_kuribosplit_gl01"; break;
					case 156: efName = "Wm_en_kuribosplit_gl02"; break;
					case 157: efName = "Wm_en_kuribosplit_sk"; break;
					case 158: efName = "Wm_en_landsmoke"; break;
					case 159: efName = "Wm_en_landsmoke_s"; break;
					case 160: efName = "Wm_en_magkillersmoke"; break;
					case 161: efName = "Wm_en_magmawave"; break;
					case 162: efName = "Wm_en_magmawave_a"; break;
					case 163: efName = "Wm_en_magmawave_b"; break;
					case 164: efName = "Wm_en_mgkillershot_l"; break;
					case 165: efName = "Wm_en_mgkillershot_r"; break;
					case 166: efName = "Wm_en_mgsearchkiller"; break;
					case 167: efName = "Wm_en_movecloud"; break;
					case 168: efName = "Wm_en_obakedoor"; break;
					case 169: efName = "Wm_en_obakedoor_ic"; break;
					case 170: efName = "Wm_en_obakedoor_sm"; break;
					case 171: efName = "Wm_en_pakkunfire"; break;
					case 172: efName = "Wm_en_pakkunfire00"; break;
					case 173: efName = "Wm_en_pakkunsweat"; break;
					case 174: efName = "Wm_en_pakkun_ball01"; break;
					case 175: efName = "Wm_en_pakkun_ball02"; break;
					case 176: efName = "Wm_en_pakkun_foo"; break;
					case 177: efName = "Wm_en_patametsweat"; break;
					case 178: efName = "Wm_en_poisoninbig01"; break;
					case 179: efName = "Wm_en_poisoninbig02"; break;
					case 180: efName = "Wm_en_poisonwave"; break;
					case 181: efName = "Wm_en_poisonwave_a"; break;
					case 182: efName = "Wm_en_poisonwave_b"; break;
					case 183: efName = "Wm_en_quicksand"; break;
					case 184: efName = "Wm_en_sanbohit"; break;
					case 185: efName = "Wm_en_sanbohitsmk"; break;
					case 186: efName = "Wm_en_sanbohit_hit"; break;
					case 187: efName = "Wm_en_sanbohit_ring"; break;
					case 188: efName = "Wm_en_sanbohit_smk"; break;
					case 189: efName = "Wm_en_sanbosmoke"; break;
					case 190: efName = "Wm_en_sanbospillsand"; break;
					case 191: efName = "Wm_en_searchkiller"; break;
					case 192: efName = "Wm_en_shellgreentail"; break;
					case 193: efName = "Wm_en_shellredtail"; break;
					case 194: efName = "Wm_en_sndlandsmk"; break;
					case 195: efName = "Wm_en_sndlandsmk_s"; break;
					case 196: efName = "Wm_en_sphitsmoke"; break;
					case 197: efName = "Wm_en_spindamage"; break;
					case 198: efName = "Wm_en_spindamage_big"; break;
					case 199: efName = "Wm_en_spindamage_big_rg"; break;
					case 200: efName = "Wm_en_spindamage_big_st"; break;
					case 201: efName = "Wm_en_spindamage_rg"; break;
					case 202: efName = "Wm_en_spindamage_star"; break;
					case 203: efName = "Wm_en_spsmoke"; break;
					case 204: efName = "Wm_en_sweat"; break;
					case 205: efName = "Wm_en_teresatail"; break;
					case 206: efName = "Wm_en_teresavanish"; break;
					case 207: efName = "Wm_en_vshit"; break;
					case 208: efName = "Wm_en_vshit_glow"; break;
					case 209: efName = "Wm_en_vshit_hit"; break;
					case 210: efName = "Wm_en_vshit_ring"; break;
					case 211: efName = "Wm_en_vshit_star"; break;
					case 212: efName = "Wm_en_watersplash"; break;
					case 213: efName = "Wm_en_watersplash_cld"; break;
					case 214: efName = "Wm_en_waterwave_in"; break;
					case 215: efName = "Wm_en_waterwave_in_a"; break;
					case 216: efName = "Wm_en_waterwave_in_b"; break;
					case 217: efName = "Wm_en_wfsplash_in01_l"; break;
					case 218: efName = "Wm_en_wfsplash_in01_r"; break;
					case 219: efName = "Wm_en_wfsplash_in02_l"; break;
					case 220: efName = "Wm_en_wfsplash_in02_r"; break;
					case 221: efName = "Wm_en_wfsplash_in_l"; break;
					case 222: efName = "Wm_en_wfsplash_in_r"; break;
					case 223: efName = "Wm_en_wfsplash_out01_l"; break;
					case 224: efName = "Wm_en_wfsplash_out01_r"; break;
					case 225: efName = "Wm_en_wfsplash_out02_l"; break;
					case 226: efName = "Wm_en_wfsplash_out02_r"; break;
					case 227: efName = "Wm_en_wfsplash_out_l"; break;
					case 228: efName = "Wm_en_wfsplash_out_r"; break;
					case 229: efName = "Wm_mr_1upkira"; break;
					case 230: efName = "Wm_mr_1upkira_01"; break;
					case 231: efName = "Wm_mr_1upkira_01_s"; break;
					case 232: efName = "Wm_mr_1upkira_01_ss"; break;
					case 233: efName = "Wm_mr_1upkira_02"; break;
					case 234: efName = "Wm_mr_1upkira_02_s"; break;
					case 235: efName = "Wm_mr_1upkira_s"; break;
					case 236: efName = "Wm_mr_1upkira_spin"; break;
					case 237: efName = "Wm_mr_1upkira_spin_s"; break;
					case 238: efName = "Wm_mr_1upkira_spin_ss"; break;
					case 239: efName = "Wm_mr_1upkira_ss"; break;
					case 240: efName = "Wm_mr_2dlandsmoke"; break;
					case 241: efName = "Wm_mr_atitismoke"; break;
					case 242: efName = "Wm_mr_balloonburst"; break;
					case 243: efName = "Wm_mr_balloonburst_h"; break;
					case 244: efName = "Wm_mr_balloonburst_w"; break;
					case 245: efName = "Wm_mr_beachbrakesmk"; break;
					case 246: efName = "Wm_mr_beachbrakesmk_ss"; break;
					case 247: efName = "Wm_mr_beachlandsmk"; break;
					case 248: efName = "Wm_mr_beachlandsmk_s"; break;
					case 249: efName = "Wm_mr_beachlandsmk_ss"; break;
					case 250: efName = "Wm_mr_beachslipsmk"; break;
					case 251: efName = "Wm_mr_beachslipsmk_ss"; break;
					case 252: efName = "Wm_mr_brakesmoke"; break;
					case 253: efName = "Wm_mr_brakesmoke_ss"; break;
					case 254: efName = "Wm_mr_brosquake"; break;
					case 255: efName = "Wm_mr_cliffcatch"; break;
					case 256: efName = "Wm_mr_cliffcatch_cd"; break;
					case 257: efName = "Wm_mr_cloud_on"; break;
					case 258: efName = "Wm_mr_cmnlandsmoke"; break;
					case 259: efName = "Wm_mr_cmnsndlandsmk"; break;
					case 260: efName = "Wm_mr_drop"; break;
					case 261: efName = "Wm_mr_electricshock"; break;
					case 262: efName = "Wm_mr_electricshock_biri01"; break;
					case 263: efName = "Wm_mr_electricshock_biri01_s"; break;
					case 264: efName = "Wm_mr_electricshock_biri02"; break;
					case 265: efName = "Wm_mr_electricshock_biri02_s"; break;
					case 266: efName = "Wm_mr_electricshock_glw"; break;
					case 267: efName = "Wm_mr_electricshock_glw_s"; break;
					case 268: efName = "Wm_mr_electricshock_kira"; break;
					case 269: efName = "Wm_mr_electricshock_kira_s"; break;
					case 270: efName = "Wm_mr_electricshock_s"; break;
					case 271: efName = "Wm_mr_fireball"; break;
					case 272: efName = "Wm_mr_fireball_a"; break;
					case 273: efName = "Wm_mr_fireball_b"; break;
					case 274: efName = "Wm_mr_fireball_hit"; break;
					case 275: efName = "Wm_mr_fireball_hit01"; break;
					case 276: efName = "Wm_mr_flaggetkira"; break;
					case 277: efName = "Wm_mr_flaggetkira_s"; break;
					case 278: efName = "Wm_mr_flaggetkira_ss"; break;
					case 279: efName = "Wm_mr_flutterkick"; break;
					case 280: efName = "Wm_mr_foot_beach"; break;
					case 281: efName = "Wm_mr_foot_ice"; break;
					case 282: efName = "Wm_mr_foot_sand"; break;
					case 283: efName = "Wm_mr_foot_snow"; break;
					case 284: efName = "Wm_mr_foot_water"; break;
					case 285: efName = "Wm_mr_fruitget"; break;
					case 286: efName = "Wm_mr_fruitget_h"; break;
					case 287: efName = "Wm_mr_fruitget_w"; break;
					case 288: efName = "Wm_mr_gauge"; break;
					case 289: efName = "Wm_mr_halfspin"; break;
					case 290: efName = "Wm_mr_hardhit"; break;
					case 291: efName = "Wm_mr_hardhit_glow"; break;
					case 292: efName = "Wm_mr_hardhit_grain"; break;
					case 293: efName = "Wm_mr_hardhit_spak"; break;
					case 294: efName = "Wm_mr_iceball"; break;
					case 295: efName = "Wm_mr_iceball_a"; break;
					case 296: efName = "Wm_mr_iceball_b"; break;
					case 297: efName = "Wm_mr_icebrakesmk"; break;
					case 298: efName = "Wm_mr_icebrakesmk_ss"; break;
					case 299: efName = "Wm_mr_iceslipsmk"; break;
					case 300: efName = "Wm_mr_iceslipsmk_ss"; break;
					case 301: efName = "Wm_mr_itemget01"; break;
					case 302: efName = "Wm_mr_itemget02"; break;
					case 303: efName = "Wm_mr_ivy"; break;
					case 304: efName = "Wm_mr_kickhit"; break;
					case 305: efName = "Wm_mr_kick_glow"; break;
					case 306: efName = "Wm_mr_kick_grain"; break;
					case 307: efName = "Wm_mr_landsmoke"; break;
					case 308: efName = "Wm_mr_landsmoke_s"; break;
					case 309: efName = "Wm_mr_landsmoke_ss"; break;
					case 310: efName = "Wm_mr_magmawave"; break;
					case 311: efName = "Wm_mr_magmawave_a"; break;
					case 312: efName = "Wm_mr_magmawave_b"; break;
					case 313: efName = "Wm_mr_misshit"; break;
					case 314: efName = "Wm_mr_misshit_ring"; break;
					case 315: efName = "Wm_mr_movecliff"; break;
					case 316: efName = "Wm_mr_normalspin"; break;
					case 317: efName = "Wm_mr_normalspin_pm"; break;
					case 318: efName = "Wm_mr_palm"; break;
					case 319: efName = "Wm_mr_palm_s"; break;
					case 320: efName = "Wm_mr_pbeachsmoke"; break;
					case 321: efName = "Wm_mr_pdesertsmoke"; break;
					case 322: efName = "Wm_mr_penguinice"; break;
					case 323: efName = "Wm_mr_penguinsmoke"; break;
					case 324: efName = "Wm_mr_penguinsnow"; break;
					case 325: efName = "Wm_mr_poisonwave"; break;
					case 326: efName = "Wm_mr_poisonwave_a"; break;
					case 327: efName = "Wm_mr_poisonwave_b"; break;
					case 328: efName = "Wm_mr_propellertail"; break;
					case 329: efName = "Wm_mr_p_iceslip"; break;
					case 330: efName = "Wm_mr_p_snowslip"; break;
					case 331: efName = "Wm_mr_quicksand"; break;
					case 332: efName = "Wm_mr_sanddive"; break;
					case 333: efName = "Wm_mr_sanddive_in"; break;
					case 334: efName = "Wm_mr_sanddive_in_m"; break;
					case 335: efName = "Wm_mr_sanddive_m"; break;
					case 336: efName = "Wm_mr_sanddive_out"; break;
					case 337: efName = "Wm_mr_sanddive_out_m"; break;
					case 338: efName = "Wm_mr_sanddive_s"; break;
					case 339: efName = "Wm_mr_sanddive_sb_s"; break;
					case 340: efName = "Wm_mr_sanddive_sd"; break;
					case 341: efName = "Wm_mr_sanddive_sd_m"; break;
					case 342: efName = "Wm_mr_sanddive_smk"; break;
					case 343: efName = "Wm_mr_sanddive_smk_m"; break;
					case 344: efName = "Wm_mr_sanddive_smk_s"; break;
					case 345: efName = "Wm_mr_sandsplash"; break;
					case 346: efName = "Wm_mr_sealandsmk"; break;
					case 347: efName = "Wm_mr_sealandsmk_s"; break;
					case 348: efName = "Wm_mr_sealandsmk_ss"; break;
					case 349: efName = "Wm_mr_slipsmoke"; break;
					case 350: efName = "Wm_mr_slipsmoke_big"; break;
					case 351: efName = "Wm_mr_slipsmoke_ss"; break;
					case 352: efName = "Wm_mr_sndbrakesmk"; break;
					case 353: efName = "Wm_mr_sndbrakesmk_ss"; break;
					case 354: efName = "Wm_mr_sndlandsmk"; break;
					case 355: efName = "Wm_mr_sndlandsmk_s"; break;
					case 356: efName = "Wm_mr_sndlandsmk_ss"; break;
					case 357: efName = "Wm_mr_sndslipsmk"; break;
					case 358: efName = "Wm_mr_sndslipsmk_ss"; break;
					case 359: efName = "Wm_mr_softhit"; break;
					case 360: efName = "Wm_mr_softhit_glow"; break;
					case 361: efName = "Wm_mr_softhit_spak"; break;
					case 362: efName = "Wm_mr_spindepart"; break;
					case 363: efName = "Wm_mr_spindepart_a"; break;
					case 364: efName = "Wm_mr_spindepart_b"; break;
					case 365: efName = "Wm_mr_spindown"; break;
					case 366: efName = "Wm_mr_spindownline"; break;
					case 367: efName = "Wm_mr_spindown_a"; break;
					case 368: efName = "Wm_mr_spindown_b"; break;
					case 369: efName = "Wm_mr_spinjump"; break;
					case 370: efName = "Wm_mr_spinjump_re"; break;
					case 371: efName = "Wm_mr_spinsmoke"; break;
					case 372: efName = "Wm_mr_spinstart"; break;
					case 373: efName = "Wm_mr_sprisesmoke"; break;
					case 374: efName = "Wm_mr_spsmoke"; break;
					case 375: efName = "Wm_mr_starkira"; break;
					case 376: efName = "Wm_mr_starkira_a"; break;
					case 377: efName = "Wm_mr_starkira_a_s"; break;
					case 378: efName = "Wm_mr_starkira_b"; break;
					case 379: efName = "Wm_mr_starkira_b_s"; break;
					case 380: efName = "Wm_mr_starkira_s"; break;
					case 381: efName = "Wm_mr_startail"; break;
					case 382: efName = "Wm_mr_stockitemuse"; break;
					case 383: efName = "Wm_mr_stockitemuse_a"; break;
					case 384: efName = "Wm_mr_stockitemuse_b"; break;
					case 385: efName = "Wm_mr_stockitemuse_c"; break;
					case 386: efName = "Wm_mr_swimpaddle"; break;
					case 387: efName = "Wm_mr_turn_beach_l"; break;
					case 388: efName = "Wm_mr_turn_beach_r"; break;
					case 389: efName = "Wm_mr_turn_ice_l"; break;
					case 390: efName = "Wm_mr_turn_ice_r"; break;
					case 391: efName = "Wm_mr_turn_sand_l"; break;
					case 392: efName = "Wm_mr_turn_sand_r"; break;
					case 393: efName = "Wm_mr_turn_snow_l"; break;
					case 394: efName = "Wm_mr_turn_snow_r"; break;
					case 395: efName = "Wm_mr_turn_usual_l"; break;
					case 396: efName = "Wm_mr_turn_usual_r"; break;
					case 397: efName = "Wm_mr_turn_water_l"; break;
					case 398: efName = "Wm_mr_turn_water_r"; break;
					case 399: efName = "Wm_mr_vshipattack"; break;
					case 400: efName = "Wm_mr_vshipattack_gl"; break;
					case 401: efName = "Wm_mr_vshipattack_hosi"; break;
					case 402: efName = "Wm_mr_vshipattack_ind"; break;
					case 403: efName = "Wm_mr_vshipattack_ind_a"; break;
					case 404: efName = "Wm_mr_vshipattack_ind_b"; break;
					case 405: efName = "Wm_mr_vshipattack_ind_c"; break;
					case 406: efName = "Wm_mr_vshipattack_line"; break;
					case 407: efName = "Wm_mr_vshipattack_ud"; break;
					case 408: efName = "Wm_mr_wallkick_b_l"; break;
					case 409: efName = "Wm_mr_wallkick_b_r"; break;
					case 410: efName = "Wm_mr_wallkick_b_ss_l"; break;
					case 411: efName = "Wm_mr_wallkick_b_ss_r"; break;
					case 412: efName = "Wm_mr_wallkick_b_s_l"; break;
					case 413: efName = "Wm_mr_wallkick_b_s_r"; break;
					case 414: efName = "Wm_mr_wallkick_cld_l"; break;
					case 415: efName = "Wm_mr_wallkick_cld_r"; break;
					case 416: efName = "Wm_mr_wallkick_cld_ss_l"; break;
					case 417: efName = "Wm_mr_wallkick_cld_ss_r"; break;
					case 418: efName = "Wm_mr_wallkick_cld_s_l"; break;
					case 419: efName = "Wm_mr_wallkick_cld_s_r"; break;
					case 420: efName = "Wm_mr_wallkick_c_l"; break;
					case 421: efName = "Wm_mr_wallkick_c_r"; break;
					case 422: efName = "Wm_mr_wallkick_c_ss_l"; break;
					case 423: efName = "Wm_mr_wallkick_c_ss_r"; break;
					case 424: efName = "Wm_mr_wallkick_c_s_l"; break;
					case 425: efName = "Wm_mr_wallkick_c_s_r"; break;
					case 426: efName = "Wm_mr_wallkick_dn_l"; break;
					case 427: efName = "Wm_mr_wallkick_dn_r"; break;
					case 428: efName = "Wm_mr_wallkick_dn_ss_l"; break;
					case 429: efName = "Wm_mr_wallkick_dn_ss_r"; break;
					case 430: efName = "Wm_mr_wallkick_dn_s_l"; break;
					case 431: efName = "Wm_mr_wallkick_dn_s_r"; break;
					case 432: efName = "Wm_mr_wallkick_l"; break;
					case 433: efName = "Wm_mr_wallkick_r"; break;
					case 434: efName = "Wm_mr_wallkick_ss_l"; break;
					case 435: efName = "Wm_mr_wallkick_ss_r"; break;
					case 436: efName = "Wm_mr_wallkick_s_l"; break;
					case 437: efName = "Wm_mr_wallkick_s_r"; break;
					case 438: efName = "Wm_mr_wallkick_up_l"; break;
					case 439: efName = "Wm_mr_wallkick_up_r"; break;
					case 440: efName = "Wm_mr_wallkick_up_ss_l"; break;
					case 441: efName = "Wm_mr_wallkick_up_ss_r"; break;
					case 442: efName = "Wm_mr_wallkick_up_s_l"; break;
					case 443: efName = "Wm_mr_wallkick_up_s_r"; break;
					case 444: efName = "Wm_mr_wallslip_cld"; break;
					case 445: efName = "Wm_mr_wallslip_cld_s"; break;
					case 446: efName = "Wm_mr_wallslip_cld_ss"; break;
					case 447: efName = "Wm_mr_wallslip_l"; break;
					case 448: efName = "Wm_mr_wallslip_r"; break;
					case 449: efName = "Wm_mr_wallslip_ss_l"; break;
					case 450: efName = "Wm_mr_wallslip_ss_r"; break;
					case 451: efName = "Wm_mr_wallslip_s_l"; break;
					case 452: efName = "Wm_mr_wallslip_s_r"; break;
					case 453: efName = "Wm_mr_waterrun_l_ss"; break;
					case 454: efName = "Wm_mr_waterrun_r_ss"; break;
					case 455: efName = "Wm_mr_watersplash"; break;
					case 456: efName = "Wm_mr_waterswim"; break;
					case 457: efName = "Wm_mr_waterwave_in"; break;
					case 458: efName = "Wm_mr_waterwave_in_a"; break;
					case 459: efName = "Wm_mr_waterwave_in_a_ss"; break;
					case 460: efName = "Wm_mr_waterwave_in_b"; break;
					case 461: efName = "Wm_mr_waterwave_in_b_ss"; break;
					case 462: efName = "Wm_mr_waterwave_in_c"; break;
					case 463: efName = "Wm_mr_waterwave_in_d"; break;
					case 464: efName = "Wm_mr_waterwave_in_ss"; break;
					case 465: efName = "Wm_mr_waterwave_out"; break;
					case 466: efName = "Wm_mr_waterwave_out_a"; break;
					case 467: efName = "Wm_mr_waterwave_out_a_ss"; break;
					case 468: efName = "Wm_mr_waterwave_out_b"; break;
					case 469: efName = "Wm_mr_waterwave_out_b_ss"; break;
					case 470: efName = "Wm_mr_waterwave_out_c"; break;
					case 471: efName = "Wm_mr_waterwave_out_ss"; break;
					case 472: efName = "Wm_mr_wfloatsplash"; break;
					case 473: efName = "Wm_mr_wfloatsplash_a"; break;
					case 474: efName = "Wm_mr_wfloatsplash_b"; break;
					case 475: efName = "Wm_mr_wirehit"; break;
					case 476: efName = "Wm_mr_wirehit_glow"; break;
					case 477: efName = "Wm_mr_wirehit_hit"; break;
					case 478: efName = "Wm_mr_wirehit_line"; break;
					case 479: efName = "Wm_mr_wirehit_star"; break;
					case 480: efName = "Wm_mr_yoshifire"; break;
					case 481: efName = "Wm_mr_yoshifirehit"; break;
					case 482: efName = "Wm_mr_yoshifirehit01"; break;
					case 483: efName = "Wm_mr_yoshifire_a"; break;
					case 484: efName = "Wm_mr_yoshifire_b"; break;
					case 485: efName = "Wm_mr_yoshiiceball"; break;
					case 486: efName = "Wm_mr_yoshiiceball_a"; break;
					case 487: efName = "Wm_mr_yoshiiceball_b"; break;
					case 488: efName = "Wm_mr_yoshiicehit"; break;
					case 489: efName = "Wm_mr_yoshiicehit_a"; break;
					case 490: efName = "Wm_mr_yoshiicehit_b"; break;
					case 491: efName = "Wm_mr_yoshistep"; break;
					case 492: efName = "Wm_mr_yoshistep_a"; break;
					case 493: efName = "Wm_mr_yoshistep_a_cld"; break;
					case 494: efName = "Wm_mr_yoshistep_b"; break;
					case 495: efName = "Wm_mr_yssweat"; break;
					case 496: efName = "Wm_mr_yssweatrun"; break;
					case 497: efName = "Wm_mr_ystonguehit"; break;
					case 498: efName = "Wm_mr_ystonguehit_a"; break;
					case 499: efName = "Wm_ob_bluecoinkira"; break;
					case 500: efName = "Wm_ob_boat"; break;
					case 501: efName = "Wm_ob_cmnboxgrain"; break;
					case 502: efName = "Wm_ob_cmnboxpiece"; break;
					case 503: efName = "Wm_ob_cmnboxsmoke"; break;
					case 504: efName = "Wm_ob_cmnicekira"; break;
					case 505: efName = "Wm_ob_cmnrockpiece"; break;
					case 506: efName = "Wm_ob_cmnshothit"; break;
					case 507: efName = "Wm_ob_cmnshotspark"; break;
					case 508: efName = "Wm_ob_cmnshotstar"; break;
					case 509: efName = "Wm_ob_cmnspark"; break;
					case 510: efName = "Wm_ob_cmnsparkloop"; break;
					case 511: efName = "Wm_ob_coin"; break;
					case 512: efName = "Wm_ob_coinkira"; break;
					case 513: efName = "Wm_ob_eggbreak_bl"; break;
					case 514: efName = "Wm_ob_eggbreak_gr"; break;
					case 515: efName = "Wm_ob_eggbreak_rd"; break;
					case 516: efName = "Wm_ob_eggbreak_yw"; break;
					case 517: efName = "Wm_ob_envsunlight"; break;
					case 518: efName = "Wm_ob_envsunlight_a"; break;
					case 519: efName = "Wm_ob_envsunlight_b"; break;
					case 520: efName = "Wm_ob_fallsmoke"; break;
					case 521: efName = "Wm_ob_fallsmoke_big"; break;
					case 522: efName = "Wm_ob_fallsmoke_s"; break;
					case 523: efName = "Wm_ob_firespillar01"; break;
					case 524: efName = "Wm_ob_firespillar02"; break;
					case 525: efName = "Wm_ob_firespillarunder"; break;
					case 526: efName = "Wm_ob_fireworks_1up"; break;
					case 527: efName = "Wm_ob_fireworks_1up01"; break;
					case 528: efName = "Wm_ob_fireworks_1up02"; break;
					case 529: efName = "Wm_ob_fireworks_1upcld1"; break;
					case 530: efName = "Wm_ob_fireworks_1upcld2"; break;
					case 531: efName = "Wm_ob_fireworks_1upgl01"; break;
					case 532: efName = "Wm_ob_fireworks_1upgl02"; break;
					case 533: efName = "Wm_ob_fireworks_b"; break;
					case 534: efName = "Wm_ob_fireworks_b01"; break;
					case 535: efName = "Wm_ob_fireworks_bcld"; break;
					case 536: efName = "Wm_ob_fireworks_g"; break;
					case 537: efName = "Wm_ob_fireworks_g01"; break;
					case 538: efName = "Wm_ob_fireworks_gcld"; break;
					case 539: efName = "Wm_ob_fireworks_k"; break;
					case 540: efName = "Wm_ob_fireworks_k01"; break;
					case 541: efName = "Wm_ob_fireworks_k02"; break;
					case 542: efName = "Wm_ob_fireworks_kcld1"; break;
					case 543: efName = "Wm_ob_fireworks_kcld2"; break;
					case 544: efName = "Wm_ob_fireworks_kgl01"; break;
					case 545: efName = "Wm_ob_fireworks_kgl02"; break;
					case 546: efName = "Wm_ob_fireworks_p"; break;
					case 547: efName = "Wm_ob_fireworks_p01"; break;
					case 548: efName = "Wm_ob_fireworks_pcld"; break;
					case 549: efName = "Wm_ob_fireworks_star"; break;
					case 550: efName = "Wm_ob_fireworks_star01"; break;
					case 551: efName = "Wm_ob_fireworks_star02"; break;
					case 552: efName = "Wm_ob_fireworks_starcld1"; break;
					case 553: efName = "Wm_ob_fireworks_starcld2"; break;
					case 554: efName = "Wm_ob_fireworks_stargl01"; break;
					case 555: efName = "Wm_ob_fireworks_stargl02"; break;
					case 556: efName = "Wm_ob_fireworks_y"; break;
					case 557: efName = "Wm_ob_fireworks_y01"; break;
					case 558: efName = "Wm_ob_fireworks_ycld"; break;
					case 559: efName = "Wm_ob_flagget"; break;
					case 560: efName = "Wm_ob_flaggetkira_cld"; break;
					case 561: efName = "Wm_ob_flagget_kira"; break;
					case 562: efName = "Wm_ob_flagget_light"; break;
					case 563: efName = "Wm_ob_greencoinkira"; break;
					case 564: efName = "Wm_ob_greencoinkira_a"; break;
					case 565: efName = "Wm_ob_greencoinkira_b"; break;
					case 566: efName = "Wm_ob_greencoinkira_c"; break;
					case 567: efName = "Wm_ob_iceattack"; break;
					case 568: efName = "Wm_ob_iceattackkira"; break;
					case 569: efName = "Wm_ob_iceattackline"; break;
					case 570: efName = "Wm_ob_iceattacksmk"; break;
					case 571: efName = "Wm_ob_icebreak"; break;
					case 572: efName = "Wm_ob_icebreaksmk"; break;
					case 573: efName = "Wm_ob_icebreakwt"; break;
					case 574: efName = "Wm_ob_iceevaporate"; break;
					case 575: efName = "Wm_ob_icehit"; break;
					case 576: efName = "Wm_ob_icehithit"; break;
					case 577: efName = "Wm_ob_icehitsmk"; break;
					case 578: efName = "Wm_ob_icehitwat"; break;
					case 579: efName = "Wm_ob_icemisshit"; break;
					case 580: efName = "Wm_ob_icemisshit_smk"; break;
					case 581: efName = "Wm_ob_icepoison"; break;
					case 582: efName = "Wm_ob_icethaw"; break;
					case 583: efName = "Wm_ob_icewait"; break;
					case 584: efName = "Wm_ob_icewaitwat"; break;
					case 585: efName = "Wm_ob_icicle"; break;
					case 586: efName = "Wm_ob_itemappear"; break;
					case 587: efName = "Wm_ob_itemappear_gl"; break;
					case 588: efName = "Wm_ob_itemappear_gl_ss"; break;
					case 589: efName = "Wm_ob_itemappear_r"; break;
					case 590: efName = "Wm_ob_itemappear_r_ss"; break;
					case 591: efName = "Wm_ob_itemappear_ss"; break;
					case 592: efName = "Wm_ob_itemfall"; break;
					case 593: efName = "Wm_ob_itemfall_a"; break;
					case 594: efName = "Wm_ob_itemfall_b"; break;
					case 595: efName = "Wm_ob_itemget"; break;
					case 596: efName = "Wm_ob_itemget_hit"; break;
					case 597: efName = "Wm_ob_itemget_hitlighit"; break;
					case 598: efName = "Wm_ob_itemget_ring"; break;
					case 599: efName = "Wm_ob_itemlandsmoke"; break;
					case 600: efName = "Wm_ob_itempropeller"; break;
					case 601: efName = "Wm_ob_itemsealandsmk"; break;
					case 602: efName = "Wm_ob_itemsndlandsmk"; break;
					case 603: efName = "Wm_ob_itemteil"; break;
					case 604: efName = "Wm_ob_keyfall"; break;
					case 605: efName = "Wm_ob_keyget01"; break;
					case 606: efName = "Wm_ob_keyget01_a"; break;
					case 607: efName = "Wm_ob_keyget01_b"; break;
					case 608: efName = "Wm_ob_keyget01_c"; break;
					case 609: efName = "Wm_ob_keyget01_d"; break;
					case 610: efName = "Wm_ob_keyget02"; break;
					case 611: efName = "Wm_ob_keyget02_gl01"; break;
					case 612: efName = "Wm_ob_keyget02_gl02"; break;
					case 613: efName = "Wm_ob_keyget02_hit"; break;
					case 614: efName = "Wm_ob_keyget02_kira"; break;
					case 615: efName = "Wm_ob_keyget02_lighit"; break;
					case 616: efName = "Wm_ob_keyget02_ring01"; break;
					case 617: efName = "Wm_ob_keyget02_ring02"; break;
					case 618: efName = "Wm_ob_keyget02_str"; break;
					case 619: efName = "Wm_ob_keywait"; break;
					case 620: efName = "Wm_ob_keywait_a"; break;
					case 621: efName = "Wm_ob_keywait_b"; break;
					case 622: efName = "Wm_ob_keywait_c"; break;
					case 623: efName = "Wm_ob_magmagear"; break;
					case 624: efName = "Wm_ob_magmasign01"; break;
					case 625: efName = "Wm_ob_magmasign02"; break;
					case 626: efName = "Wm_ob_powdown"; break;
					case 627: efName = "Wm_ob_powdown_ind"; break;
					case 628: efName = "Wm_ob_powdown_ind_a"; break;
					case 629: efName = "Wm_ob_powdown_ind_b"; break;
					case 630: efName = "Wm_ob_powdown_ind_c"; break;
					case 631: efName = "Wm_ob_redcioinitem01"; break;
					case 632: efName = "Wm_ob_redcioinitem02"; break;
					case 633: efName = "Wm_ob_redcioinitem02_a"; break;
					case 634: efName = "Wm_ob_redcioinitem02_b"; break;
					case 635: efName = "Wm_ob_redcioinitem_cd"; break;
					case 636: efName = "Wm_ob_redcioinkira"; break;
					case 637: efName = "Wm_ob_redcioinkira_cd"; break;
					case 638: efName = "Wm_ob_redcoinkira"; break;
					case 639: efName = "Wm_ob_redringget"; break;
					case 640: efName = "Wm_ob_redringget_a"; break;
					case 641: efName = "Wm_ob_redringget_b"; break;
					case 642: efName = "Wm_ob_redringget_c"; break;
					case 643: efName = "Wm_ob_redringkira"; break;
					case 644: efName = "Wm_ob_sandpillar01"; break;
					case 645: efName = "Wm_ob_sandpillar02"; break;
					case 646: efName = "Wm_ob_spillarsign01"; break;
					case 647: efName = "Wm_ob_spillarsign02"; break;
					case 648: efName = "Wm_ob_starcoinget"; break;
					case 649: efName = "Wm_ob_starcoinget_gl"; break;
					case 650: efName = "Wm_ob_starcoinget_hit"; break;
					case 651: efName = "Wm_ob_starcoinget_lighit"; break;
					case 652: efName = "Wm_ob_starcoinget_ring"; break;
					case 653: efName = "Wm_ob_starcoinget_str"; break;
					case 654: efName = "Wm_ob_startail"; break;
					case 655: efName = "Wm_ob_startail_kira"; break;
					case 656: efName = "Wm_ob_startail_star"; break;
					case 657: efName = "Wm_ob_stream"; break;
					case 658: efName = "Wm_ob_switch"; break;
					case 659: efName = "Wm_ob_switch01"; break;
					case 660: efName = "Wm_ob_treasurebox"; break;
					case 661: efName = "Wm_ob_treasureboxtail"; break;
					case 662: efName = "Wm_ob_treasureboxwait"; break;
					case 663: efName = "Wm_ob_treasureboxwait_a"; break;
					case 664: efName = "Wm_ob_treasureboxwait_b"; break;
					case 665: efName = "Wm_ob_warpcannonkira"; break;
					case 666: efName = "Wm_ob_waterbreak"; break;
					case 667: efName = "Wm_ob_waterbreak_a"; break;
					case 668: efName = "Wm_ob_waterbreak_b"; break;
					case 669: efName = "Wm_ob_waterbreak_c"; break;
					case 670: efName = "Wm_ob_witchcraft"; break;
					case 671: efName = "Wm_ob_witchcraftup"; break;
					case 672: efName = "Wm_seacloudout"; break;
					case 673: efName = "Wm_shellopen"; break;
					case 674: efName = "Wm_shellopen_a"; break;
					case 675: efName = "Wm_shellopen_b"; break;
					case 676: efName = "Wm_ig_bite"; break;
					case 677: efName = "Wm_ig_bite_a"; break;
					case 678: efName = "Wm_ig_damage"; break;
					case 679: efName = "Wm_ig_damagedie"; break;
					case 680: efName = "Wm_ig_damagedie02"; break;
					case 681: efName = "Wm_ig_damagedie02_a"; break;
					case 682: efName = "Wm_ig_damagedie02_b"; break;
					case 683: efName = "Wm_ig_damagedie02_bcld"; break;
					case 684: efName = "Wm_ig_damagedie02_c"; break;
					case 685: efName = "Wm_ig_damagedie02_d"; break;
					case 686: efName = "Wm_ig_damagedie02_e"; break;
					case 687: efName = "Wm_ig_damagedie02_f"; break;
					case 688: efName = "Wm_ig_damagedie_a"; break;
					case 689: efName = "Wm_ig_damagedie_b"; break;
					case 690: efName = "Wm_ig_damagedie_bcld"; break;
					case 691: efName = "Wm_ig_damagedie_cld"; break;
					case 692: efName = "Wm_ig_damagedie_f"; break;
					case 693: efName = "Wm_ig_damagedie_g"; break;
					case 694: efName = "Wm_ig_damage_a"; break;
					case 695: efName = "Wm_ig_damage_b"; break;
					case 696: efName = "Wm_ig_damage_c"; break;
					case 697: efName = "Wm_ig_damage_d"; break;
					case 698: efName = "Wm_ig_dizzy"; break;
					case 699: efName = "Wm_ig_dizzy_a"; break;
					case 700: efName = "Wm_ig_dizzy_b"; break;
					case 701: efName = "Wm_ig_firehit01"; break;
					case 702: efName = "Wm_ig_firehit02"; break;
					case 703: efName = "Wm_ig_firehit03"; break;
					case 704: efName = "Wm_ig_jumpend"; break;
					case 705: efName = "Wm_ig_jumpstart"; break;
					case 706: efName = "Wm_ig_landsmoke"; break;
					case 707: efName = "Wm_ig_landsmoke_a"; break;
					case 708: efName = "Wm_ig_landsmoke_b"; break;
					case 709: efName = "Wm_ig_liftbrake"; break;
					case 710: efName = "Wm_ig_liftbrake_a"; break;
					case 711: efName = "Wm_ig_liftbrake_b"; break;
					case 712: efName = "Wm_ig_magicattack"; break;
					case 713: efName = "Wm_ig_magicattack_a"; break;
					case 714: efName = "Wm_ig_magicattack_b"; break;
					case 715: efName = "Wm_ig_magicattack_c"; break;
					case 716: efName = "Wm_ig_magicattack_d"; break;
					case 717: efName = "Wm_ig_magicattack_e"; break;
					case 718: efName = "Wm_ig_magicattack_st"; break;
					case 719: efName = "Wm_ig_magicattack_st_a"; break;
					case 720: efName = "Wm_ig_magicattack_st_b"; break;
					case 721: efName = "Wm_ig_magicattack_st_c"; break;
					case 722: efName = "Wm_ig_magicattack_st_d"; break;
					case 723: efName = "Wm_ig_mgcwallhit"; break;
					case 724: efName = "Wm_ig_mgcwallhit01"; break;
					case 725: efName = "Wm_ig_mgcwallhit02"; break;
					case 726: efName = "Wm_ig_mgcwallhit03"; break;
					case 727: efName = "Wm_ig_mgcwallhit04"; break;
					case 728: efName = "Wm_ig_shellchange"; break;
					case 729: efName = "Wm_ig_shelllandsmoke01"; break;
					case 730: efName = "Wm_ig_shelllandsmoke02"; break;
					case 731: efName = "Wm_ig_shelltail"; break;
					case 732: efName = "Wm_ig_tap"; break;
					case 733: efName = "Wm_ig_turn01_l"; break;
					case 734: efName = "Wm_ig_turn01_r"; break;
					case 735: efName = "Wm_ig_turn02"; break;
					case 736: efName = "Wm_ig_turnbrake01"; break;
					case 737: efName = "Wm_ig_turnbrake02"; break;
					case 738: efName = "Wm_ig_wallhit"; break;
					case 739: efName = "Wm_ig_wallhit_a"; break;
					case 740: efName = "Wm_ig_wanwanbig"; break;
					case 741: efName = "Wm_mriggyttackhit_b"; break;
					case 742: efName = "Wm_mr_iggyattackhit"; break;
					case 743: efName = "Wm_mr_iggyattackhit_a"; break;
					case 744: efName = "Wm_mr_iggyattackhit_c"; break;
					case 745: efName = "Wm_mr_iggyattackhit_d"; break;
					case 746: efName = "Wm_mr_iggyattackhit_e"; break;
					case 747: efName = "Wm_jr_bomb"; break;
					case 748: efName = "Wm_jr_bombfuse"; break;
					case 749: efName = "Wm_jr_bombfuse_a"; break;
					case 750: efName = "Wm_jr_bombfuse_b"; break;
					case 751: efName = "Wm_jr_bombfuse_c"; break;
					case 752: efName = "Wm_jr_bombhit"; break;
					case 753: efName = "Wm_jr_bombring"; break;
					case 754: efName = "Wm_jr_bombsmoke"; break;
					case 755: efName = "Wm_jr_bombspark"; break;
					case 756: efName = "Wm_jr_bombstar"; break;
					case 757: efName = "Wm_jr_breaksmoke"; break;
					case 758: efName = "Wm_jr_crumble01"; break;
					case 759: efName = "Wm_jr_crumble02"; break;
					case 760: efName = "Wm_jr_damage"; break;
					case 761: efName = "Wm_jr_damagespin01"; break;
					case 762: efName = "Wm_jr_damagespin02"; break;
					case 763: efName = "Wm_jr_damage_a"; break;
					case 764: efName = "Wm_jr_damage_b"; break;
					case 765: efName = "Wm_jr_damage_c"; break;
					case 766: efName = "Wm_jr_damage_d"; break;
					case 767: efName = "Wm_jr_electricglow"; break;
					case 768: efName = "Wm_jr_electricline"; break;
					case 769: efName = "Wm_jr_electricline_a"; break;
					case 770: efName = "Wm_jr_electricline_b"; break;
					case 771: efName = "Wm_jr_electricline_spl"; break;
					case 772: efName = "Wm_jr_electricspark"; break;
					case 773: efName = "Wm_jr_electricstart"; break;
					case 774: efName = "Wm_jr_electricstart_a"; break;
					case 775: efName = "Wm_jr_electricstart_b"; break;
					case 776: efName = "Wm_jr_fireattack"; break;
					case 777: efName = "Wm_jr_fireattack_a"; break;
					case 778: efName = "Wm_jr_fireattack_b"; break;
					case 779: efName = "Wm_jr_fireattack_d"; break;
					case 780: efName = "Wm_jr_fireattack_e"; break;
					case 781: efName = "Wm_jr_fireattack_f"; break;
					case 782: efName = "Wm_jr_firehit"; break;
					case 783: efName = "Wm_jr_firehit_a"; break;
					case 784: efName = "Wm_jr_fireplace"; break;
					case 785: efName = "Wm_jr_fireplace_a"; break;
					case 786: efName = "Wm_jr_fireplace_b"; break;
					case 787: efName = "Wm_jr_fireplace_ind"; break;
					case 788: efName = "Wm_jr_jumpend"; break;
					case 789: efName = "Wm_jr_jumpstart"; break;
					case 790: efName = "Wm_jr_kbstepon"; break;
					case 791: efName = "Wm_jr_kbstepon_a"; break;
					case 792: efName = "Wm_jr_kickhit"; break;
					case 793: efName = "Wm_jr_kickhit_glow"; break;
					case 794: efName = "Wm_jr_kystepon"; break;
					case 795: efName = "Wm_jr_kystepon_a"; break;
					case 796: efName = "Wm_jr_landsmoke"; break;
					case 797: efName = "Wm_jr_landsmoke_a"; break;
					case 798: efName = "Wm_jr_landsmoke_c"; break;
					case 799: efName = "Wm_jr_lustepon"; break;
					case 800: efName = "Wm_jr_lustepon_a"; break;
					case 801: efName = "Wm_jr_misshit"; break;
					case 802: efName = "Wm_jr_misshit_a"; break;
					case 803: efName = "Wm_jr_misshit_b"; break;
					case 804: efName = "Wm_jr_misshit_s"; break;
					case 805: efName = "Wm_jr_misshit_ss"; break;
					case 806: efName = "Wm_jr_misshit_s_a"; break;
					case 807: efName = "Wm_jr_mrstepon"; break;
					case 808: efName = "Wm_jr_mrstepon_a"; break;
					case 809: efName = "Wm_jr_mrstepon_b"; break;
					case 810: efName = "Wm_jr_playerspin"; break;
					case 811: efName = "Wm_jr_propeller"; break;
					case 812: efName = "Wm_jr_shot"; break;
					case 813: efName = "Wm_jr_shothit"; break;
					case 814: efName = "Wm_jr_shotring"; break;
					case 815: efName = "Wm_jr_shotsmoke"; break;
					case 816: efName = "Wm_jr_shotspark"; break;
					case 817: efName = "Wm_jr_shotstar"; break;
					case 818: efName = "Wm_jr_stepon"; break;
					case 819: efName = "Wm_jr_stepon_a"; break;
					case 820: efName = "Wm_jr_stepon_b"; break;
					case 821: efName = "Wm_jr_sweat"; break;
					case 822: efName = "Wm_ka_block_l"; break;
					case 823: efName = "Wm_ka_block_l_a"; break;
					case 824: efName = "Wm_ka_block_l_b"; break;
					case 825: efName = "Wm_ka_block_l_c"; break;
					case 826: efName = "Wm_ka_block_m"; break;
					case 827: efName = "Wm_ka_block_m_a"; break;
					case 828: efName = "Wm_ka_block_m_b"; break;
					case 829: efName = "Wm_ka_block_m_c"; break;
					case 830: efName = "Wm_ka_block_s"; break;
					case 831: efName = "Wm_ka_block_s_a"; break;
					case 832: efName = "Wm_ka_block_s_b"; break;
					case 833: efName = "Wm_ka_block_s_c"; break;
					case 834: efName = "Wm_ka_changesmoke"; break;
					case 835: efName = "Wm_ka_change_e"; break;
					case 836: efName = "Wm_ka_change_l"; break;
					case 837: efName = "Wm_ka_change_l_a"; break;
					case 838: efName = "Wm_ka_change_l_b"; break;
					case 839: efName = "Wm_ka_change_l_c"; break;
					case 840: efName = "Wm_ka_change_l_d"; break;
					case 841: efName = "Wm_ka_change_l_e"; break;
					case 842: efName = "Wm_ka_change_l_fa"; break;
					case 843: efName = "Wm_ka_change_l_fb"; break;
					case 844: efName = "Wm_ka_change_l_st01"; break;
					case 845: efName = "Wm_ka_change_m"; break;
					case 846: efName = "Wm_ka_change_m_a"; break;
					case 847: efName = "Wm_ka_change_m_b"; break;
					case 848: efName = "Wm_ka_change_m_c"; break;
					case 849: efName = "Wm_ka_change_m_d"; break;
					case 850: efName = "Wm_ka_change_m_e"; break;
					case 851: efName = "Wm_ka_change_m_fa"; break;
					case 852: efName = "Wm_ka_change_m_fb"; break;
					case 853: efName = "Wm_ka_change_m_st01"; break;
					case 854: efName = "Wm_ka_change_s"; break;
					case 855: efName = "Wm_ka_change_s_a"; break;
					case 856: efName = "Wm_ka_change_s_b"; break;
					case 857: efName = "Wm_ka_change_s_c"; break;
					case 858: efName = "Wm_ka_change_s_d"; break;
					case 859: efName = "Wm_ka_change_s_fa"; break;
					case 860: efName = "Wm_ka_change_s_fb"; break;
					case 861: efName = "Wm_ka_change_s_st01"; break;
					case 862: efName = "Wm_ka_coin"; break;
					case 863: efName = "Wm_ka_damage"; break;
					case 864: efName = "Wm_ka_damagedie"; break;
					case 865: efName = "Wm_ka_damagediespin"; break;
					case 866: efName = "Wm_ka_damagedie_a"; break;
					case 867: efName = "Wm_ka_damagedie_b"; break;
					case 868: efName = "Wm_ka_damagedie_bcld"; break;
					case 869: efName = "Wm_ka_damagedie_cld"; break;
					case 870: efName = "Wm_ka_damagedie_f"; break;
					case 871: efName = "Wm_ka_damagedie_g"; break;
					case 872: efName = "Wm_ka_damage_a"; break;
					case 873: efName = "Wm_ka_damage_b"; break;
					case 874: efName = "Wm_ka_damage_c"; break;
					case 875: efName = "Wm_ka_damage_d"; break;
					case 876: efName = "Wm_ka_enemychange_l"; break;
					case 877: efName = "Wm_ka_enemychange_l_a"; break;
					case 878: efName = "Wm_ka_enemychange_l_b"; break;
					case 879: efName = "Wm_ka_enemychange_s"; break;
					case 880: efName = "Wm_ka_enemychange_s_a"; break;
					case 881: efName = "Wm_ka_enemychange_s_b"; break;
					case 882: efName = "Wm_ka_fade"; break;
					case 883: efName = "Wm_ka_firehit01"; break;
					case 884: efName = "Wm_ka_firehit02"; break;
					case 885: efName = "Wm_ka_firehit03"; break;
					case 886: efName = "Wm_ka_magicattack"; break;
					case 887: efName = "Wm_ka_magicattack_a"; break;
					case 888: efName = "Wm_ka_magicattack_c"; break;
					case 889: efName = "Wm_ka_magicattack_d"; break;
					case 890: efName = "Wm_ka_magicattack_e"; break;
					case 891: efName = "Wm_ka_magicattack_st"; break;
					case 892: efName = "Wm_ka_magicattack_st_a"; break;
					case 893: efName = "Wm_ka_magicattack_st_b"; break;
					case 894: efName = "Wm_ka_magicattack_st_c"; break;
					case 895: efName = "Wm_ka_magicattack_st_d"; break;
					case 896: efName = "Wm_ka_mgcwallhit"; break;
					case 897: efName = "Wm_ka_mgcwallhit01"; break;
					case 898: efName = "Wm_ka_mgcwallhit02"; break;
					case 899: efName = "Wm_ka_mgcwallhit03"; break;
					case 900: efName = "Wm_ka_mgcwallhit04"; break;
					case 901: efName = "Wm_mr_kameattackhit"; break;
					case 902: efName = "Wm_mr_kameattackhit_a"; break;
					case 903: efName = "Wm_mr_kameattackhit_b"; break;
					case 904: efName = "Wm_mr_kameattackhit_c"; break;
					case 905: efName = "Wm_mr_kameattackhit_d"; break;
					case 906: efName = "Wm_mr_kameattackhit_e"; break;
					case 907: efName = "Wm_ko_cage"; break;
					case 908: efName = "Wm_ko_cage_a"; break;
					case 909: efName = "Wm_ko_ceilingfall"; break;
					case 910: efName = "Wm_ko_ceilingfall_a"; break;
					case 911: efName = "Wm_ko_ceilingfall_b"; break;
					case 912: efName = "Wm_ko_ceilingfall_c"; break;
					case 913: efName = "Wm_ko_crumble01"; break;
					case 914: efName = "Wm_ko_crumble02"; break;
					case 915: efName = "Wm_ko_destroy"; break;
					case 916: efName = "Wm_ko_downsmoke"; break;
					case 917: efName = "Wm_ko_downsmokebig"; break;
					case 918: efName = "Wm_ko_fireattack"; break;
					case 919: efName = "Wm_ko_fireattack_a"; break;
					case 920: efName = "Wm_ko_fireattack_b"; break;
					case 921: efName = "Wm_ko_fireattack_d"; break;
					case 922: efName = "Wm_ko_fireattack_e"; break;
					case 923: efName = "Wm_ko_fireattack_f"; break;
					case 924: efName = "Wm_ko_fireattack_g"; break;
					case 925: efName = "Wm_ko_fireattack_h"; break;
					case 926: efName = "Wm_ko_firehit"; break;
					case 927: efName = "Wm_ko_firehitdie01"; break;
					case 928: efName = "Wm_ko_firehitdie02"; break;
					case 929: efName = "Wm_ko_firehitdie03"; break;
					case 930: efName = "Wm_ko_firehit_a"; break;
					case 931: efName = "Wm_ko_firehit_b"; break;
					case 932: efName = "Wm_ko_firehit_c"; break;
					case 933: efName = "Wm_ko_flicker"; break;
					case 934: efName = "Wm_ko_footsmoke"; break;
					case 935: efName = "Wm_ko_handhit"; break;
					case 936: efName = "Wm_ko_handhit_glow"; break;
					case 937: efName = "Wm_ko_landsmoke"; break;
					case 938: efName = "Wm_ko_landsmoke_a"; break;
					case 939: efName = "Wm_ko_landsmoke_b"; break;
					case 940: efName = "Wm_ko_landsmoke_c"; break;
					case 941: efName = "Wm_ko_magmafall"; break;
					case 942: efName = "Wm_ko_magmafall02"; break;
					case 943: efName = "Wm_ko_magmafall02_a"; break;
					case 944: efName = "Wm_ko_magmafall02_b"; break;
					case 945: efName = "Wm_ko_magmafall_a"; break;
					case 946: efName = "Wm_ko_magmafall_b"; break;
					case 947: efName = "Wm_ko_magmapocha"; break;
					case 948: efName = "Wm_ko_magmapochabig"; break;
					case 949: efName = "Wm_ko_magmapochabig_a"; break;
					case 950: efName = "Wm_ko_magmapochabig_b"; break;
					case 951: efName = "Wm_ko_magmapochabig_c"; break;
					case 952: efName = "Wm_ko_magmapochabig_in"; break;
					case 953: efName = "Wm_ko_magmapochabig_ou"; break;
					case 954: efName = "Wm_ko_magmapocha_a"; break;
					case 955: efName = "Wm_ko_magmapocha_b"; break;
					case 956: efName = "Wm_ko_magmapocha_c"; break;
					case 957: efName = "Wm_ko_magmapocha_in"; break;
					case 958: efName = "Wm_ko_magmapocha_ou"; break;
					case 959: efName = "Wm_ko_magmawalk"; break;
					case 960: efName = "Wm_ko_magmawalk02"; break;
					case 961: efName = "Wm_ko_magmawalk_a"; break;
					case 962: efName = "Wm_ko_magmawalk_b"; break;
					case 963: efName = "Wm_ko_rescuekira"; break;
					case 964: efName = "Wm_ko_rescuekira_a"; break;
					case 965: efName = "Wm_ko_rescuekira_b"; break;
					case 966: efName = "Wm_ko_shout"; break;
					case 967: efName = "Wm_ko_shout02"; break;
					case 968: efName = "Wm_ko_shout02_a"; break;
					case 969: efName = "Wm_ko_shout02_b"; break;
					case 970: efName = "Wm_ko_shout02_hinoko_a"; break;
					case 971: efName = "Wm_ko_shout02_hinoko_b"; break;
					case 972: efName = "Wm_ko_shout02_ind"; break;
					case 973: efName = "Wm_ko_shout_a"; break;
					case 974: efName = "Wm_ko_shout_b"; break;
					case 975: efName = "Wm_ko_shout_hinoko_a"; break;
					case 976: efName = "Wm_ko_shout_hinoko_b"; break;
					case 977: efName = "Wm_ko_shout_ind"; break;
					case 978: efName = "Wm_ko_switch"; break;
					case 979: efName = "Wm_ko_switch_a"; break;
					case 980: efName = "Wm_ko_switch_b"; break;
					case 981: efName = "Wm_ko_switch_c"; break;
					case 982: efName = "Wm_la_anger"; break;
					case 983: efName = "Wm_la_anger_cld"; break;
					case 984: efName = "Wm_la_damage"; break;
					case 985: efName = "Wm_la_damagedi02e_d"; break;
					case 986: efName = "Wm_la_damagedi02_f"; break;
					case 987: efName = "Wm_la_damagedie"; break;
					case 988: efName = "Wm_la_damagedie02"; break;
					case 989: efName = "Wm_la_damagedie02_a"; break;
					case 990: efName = "Wm_la_damagedie02_b"; break;
					case 991: efName = "Wm_la_damagedie02_bcld"; break;
					case 992: efName = "Wm_la_damagedie02_c"; break;
					case 993: efName = "Wm_la_damagedie02_e"; break;
					case 994: efName = "Wm_la_damagedie_a"; break;
					case 995: efName = "Wm_la_damagedie_b"; break;
					case 996: efName = "Wm_la_damagedie_bcld"; break;
					case 997: efName = "Wm_la_damagedie_cld"; break;
					case 998: efName = "Wm_la_damagedie_f"; break;
					case 999: efName = "Wm_la_damagedie_g"; break;
					case 1000: efName = "Wm_la_damage_a"; break;
					case 1001: efName = "Wm_la_damage_b"; break;
					case 1002: efName = "Wm_la_damage_c"; break;
					case 1003: efName = "Wm_la_damage_d"; break;
					case 1004: efName = "Wm_la_firehit01"; break;
					case 1005: efName = "Wm_la_firehit02"; break;
					case 1006: efName = "Wm_la_firehit03"; break;
					case 1007: efName = "Wm_la_jumpend"; break;
					case 1008: efName = "Wm_la_jumpstart"; break;
					case 1009: efName = "Wm_la_landsmoke"; break;
					case 1010: efName = "Wm_la_landsmoke_a"; break;
					case 1011: efName = "Wm_la_landsmoke_b"; break;
					case 1012: efName = "Wm_la_landsmoke_c"; break;
					case 1013: efName = "Wm_la_magicattack"; break;
					case 1014: efName = "Wm_la_magicattack_a"; break;
					case 1015: efName = "Wm_la_magicattack_b"; break;
					case 1016: efName = "Wm_la_magicattack_c"; break;
					case 1017: efName = "Wm_la_magicattack_d"; break;
					case 1018: efName = "Wm_la_magicattack_e"; break;
					case 1019: efName = "Wm_la_magicattack_st"; break;
					case 1020: efName = "Wm_la_magicattack_st_a"; break;
					case 1021: efName = "Wm_la_magicattack_st_b"; break;
					case 1022: efName = "Wm_la_magicattack_st_c"; break;
					case 1023: efName = "Wm_la_magicattack_st_d"; break;
					case 1024: efName = "Wm_la_mgcwallhit"; break;
					case 1025: efName = "Wm_la_mgcwallhit01"; break;
					case 1026: efName = "Wm_la_mgcwallhit02"; break;
					case 1027: efName = "Wm_la_mgcwallhit03"; break;
					case 1028: efName = "Wm_la_mgcwallhit04"; break;
					case 1029: efName = "Wm_la_shellchange"; break;
					case 1030: efName = "Wm_la_shelllandsmoke01"; break;
					case 1031: efName = "Wm_la_shelllandsmoke02"; break;
					case 1032: efName = "Wm_la_shelltail"; break;
					case 1033: efName = "Wm_la_turn01_l"; break;
					case 1034: efName = "Wm_la_turn01_r"; break;
					case 1035: efName = "Wm_la_turn02"; break;
					case 1036: efName = "Wm_la_turnbrake01"; break;
					case 1037: efName = "Wm_la_turnbrake02"; break;
					case 1038: efName = "Wm_la_wallhit"; break;
					case 1039: efName = "Wm_la_wallhit_a"; break;
					case 1040: efName = "Wm_mr_larryattackhit"; break;
					case 1041: efName = "Wm_mr_larryattackhit_a"; break;
					case 1042: efName = "Wm_mr_larryattackhit_b"; break;
					case 1043: efName = "Wm_mr_larryattackhit_c"; break;
					case 1044: efName = "Wm_mr_larryattackhit_d"; break;
					case 1045: efName = "Wm_mr_larryattackhit_e"; break;
					case 1046: efName = "Wm_le_ballappear"; break;
					case 1047: efName = "Wm_le_ballappear_a"; break;
					case 1048: efName = "Wm_le_ballappear_b"; break;
					case 1049: efName = "Wm_le_ballappear_c"; break;
					case 1050: efName = "Wm_le_ballice"; break;
					case 1051: efName = "Wm_le_damage"; break;
					case 1052: efName = "Wm_le_damagedie"; break;
					case 1053: efName = "Wm_le_damagedie02"; break;
					case 1054: efName = "Wm_le_damagedie02_a"; break;
					case 1055: efName = "Wm_le_damagedie02_b"; break;
					case 1056: efName = "Wm_le_damagedie02_bcld"; break;
					case 1057: efName = "Wm_le_damagedie02_c"; break;
					case 1058: efName = "Wm_le_damagedie02_d"; break;
					case 1059: efName = "Wm_le_damagedie02_e"; break;
					case 1060: efName = "Wm_le_damagedie02_f"; break;
					case 1061: efName = "Wm_le_damagedie_a"; break;
					case 1062: efName = "Wm_le_damagedie_b"; break;
					case 1063: efName = "Wm_le_damagedie_bcld"; break;
					case 1064: efName = "Wm_le_damagedie_cld"; break;
					case 1065: efName = "Wm_le_damagedie_f"; break;
					case 1066: efName = "Wm_le_damagedie_g"; break;
					case 1067: efName = "Wm_le_damage_a"; break;
					case 1068: efName = "Wm_le_damage_b"; break;
					case 1069: efName = "Wm_le_damage_c"; break;
					case 1070: efName = "Wm_le_damage_d"; break;
					case 1071: efName = "Wm_le_firehit01"; break;
					case 1072: efName = "Wm_le_firehit02"; break;
					case 1073: efName = "Wm_le_firehit03"; break;
					case 1074: efName = "Wm_le_jumpend"; break;
					case 1075: efName = "Wm_le_jumpstart"; break;
					case 1076: efName = "Wm_le_landsmoke"; break;
					case 1077: efName = "Wm_le_landsmoke_a"; break;
					case 1078: efName = "Wm_le_landsmoke_b"; break;
					case 1079: efName = "Wm_le_landsmoke_c"; break;
					case 1080: efName = "Wm_le_magicattack_st"; break;
					case 1081: efName = "Wm_le_magicattack_st_a"; break;
					case 1082: efName = "Wm_le_magicattack_st_b"; break;
					case 1083: efName = "Wm_le_magicattack_st_c"; break;
					case 1084: efName = "Wm_le_magicattack_st_d"; break;
					case 1085: efName = "Wm_le_mgcball"; break;
					case 1086: efName = "Wm_le_mgcball_a"; break;
					case 1087: efName = "Wm_le_mgcball_b"; break;
					case 1088: efName = "Wm_le_mgcball_c"; break;
					case 1089: efName = "Wm_le_mgcwallhit"; break;
					case 1090: efName = "Wm_le_mgcwallhit01"; break;
					case 1091: efName = "Wm_le_mgcwallhit02"; break;
					case 1092: efName = "Wm_le_mgcwallhit03"; break;
					case 1093: efName = "Wm_le_mgcwallhit04"; break;
					case 1094: efName = "Wm_le_shellchange"; break;
					case 1095: efName = "Wm_le_shelllandsmoke01"; break;
					case 1096: efName = "Wm_le_shelllandsmoke02"; break;
					case 1097: efName = "Wm_le_shelltail"; break;
					case 1098: efName = "Wm_le_turn01_l"; break;
					case 1099: efName = "Wm_le_turn01_r"; break;
					case 1100: efName = "Wm_le_turn02"; break;
					case 1101: efName = "Wm_le_turnbrake01"; break;
					case 1102: efName = "Wm_le_turnbrake02"; break;
					case 1103: efName = "Wm_mr_lemmyattackhit"; break;
					case 1104: efName = "Wm_mr_lemmyattackhit_a"; break;
					case 1105: efName = "Wm_mr_lemmyattackhit_b"; break;
					case 1106: efName = "Wm_mr_lemmyattackhit_c"; break;
					case 1107: efName = "Wm_mr_lemmyattackhit_d"; break;
					case 1108: efName = "Wm_mr_lemmyattackhit_e"; break;
					case 1109: efName = "Wm_ob_ballgrowbig"; break;
					case 1110: efName = "Wm_lu_damage"; break;
					case 1111: efName = "Wm_lu_damagedie"; break;
					case 1112: efName = "Wm_lu_damagedie02"; break;
					case 1113: efName = "Wm_lu_damagedie02_a"; break;
					case 1114: efName = "Wm_lu_damagedie02_b"; break;
					case 1115: efName = "Wm_lu_damagedie02_bcld"; break;
					case 1116: efName = "Wm_lu_damagedie02_c"; break;
					case 1117: efName = "Wm_lu_damagedie02_d"; break;
					case 1118: efName = "Wm_lu_damagedie02_e"; break;
					case 1119: efName = "Wm_lu_damagedie02_f"; break;
					case 1120: efName = "Wm_lu_damagedie_a"; break;
					case 1121: efName = "Wm_lu_damagedie_b"; break;
					case 1122: efName = "Wm_lu_damagedie_bcld"; break;
					case 1123: efName = "Wm_lu_damagedie_cld"; break;
					case 1124: efName = "Wm_lu_damagedie_f"; break;
					case 1125: efName = "Wm_lu_damagedie_g"; break;
					case 1126: efName = "Wm_lu_damage_a"; break;
					case 1127: efName = "Wm_lu_damage_b"; break;
					case 1128: efName = "Wm_lu_damage_c"; break;
					case 1129: efName = "Wm_lu_damage_d"; break;
					case 1130: efName = "Wm_lu_firehit01"; break;
					case 1131: efName = "Wm_lu_firehit02"; break;
					case 1132: efName = "Wm_lu_firehit03"; break;
					case 1133: efName = "Wm_lu_jumpend"; break;
					case 1134: efName = "Wm_lu_jumpsmoke"; break;
					case 1135: efName = "Wm_lu_jumpstart"; break;
					case 1136: efName = "Wm_lu_landsmoke"; break;
					case 1137: efName = "Wm_lu_landsmoke_a"; break;
					case 1138: efName = "Wm_lu_landsmoke_b"; break;
					case 1139: efName = "Wm_lu_landsmoke_c"; break;
					case 1140: efName = "Wm_lu_liftspark"; break;
					case 1141: efName = "Wm_lu_liftspark_a"; break;
					case 1142: efName = "Wm_lu_liftspark_b"; break;
					case 1143: efName = "Wm_lu_magicattack"; break;
					case 1144: efName = "Wm_lu_magicattack_a"; break;
					case 1145: efName = "Wm_lu_magicattack_b"; break;
					case 1146: efName = "Wm_lu_magicattack_c"; break;
					case 1147: efName = "Wm_lu_magicattack_d"; break;
					case 1148: efName = "Wm_lu_magicattack_e"; break;
					case 1149: efName = "Wm_lu_magicattack_st"; break;
					case 1150: efName = "Wm_lu_magicattack_st_a"; break;
					case 1151: efName = "Wm_lu_magicattack_st_b"; break;
					case 1152: efName = "Wm_lu_magicattack_st_c"; break;
					case 1153: efName = "Wm_lu_magicattack_st_d"; break;
					case 1154: efName = "Wm_lu_mgcwallhit"; break;
					case 1155: efName = "Wm_lu_mgcwallhit01"; break;
					case 1156: efName = "Wm_lu_mgcwallhit02"; break;
					case 1157: efName = "Wm_lu_mgcwallhit03"; break;
					case 1158: efName = "Wm_lu_mgcwallhit04"; break;
					case 1159: efName = "Wm_lu_shellchange"; break;
					case 1160: efName = "Wm_lu_shelllandsmoke01"; break;
					case 1161: efName = "Wm_lu_shelllandsmoke02"; break;
					case 1162: efName = "Wm_lu_shelltail"; break;
					case 1163: efName = "Wm_lu_sweat"; break;
					case 1164: efName = "Wm_lu_turn01_l"; break;
					case 1165: efName = "Wm_lu_turn01_r"; break;
					case 1166: efName = "Wm_lu_turn02"; break;
					case 1167: efName = "Wm_lu_turnbrake01"; break;
					case 1168: efName = "Wm_lu_turnbrake02"; break;
					case 1169: efName = "Wm_mr_ludwigattackhit"; break;
					case 1170: efName = "Wm_mr_ludwigattackhit_a"; break;
					case 1171: efName = "Wm_mr_ludwigattackhit_b"; break;
					case 1172: efName = "Wm_mr_ludwigattackhit_c"; break;
					case 1173: efName = "Wm_mr_ludwigattackhit_d"; break;
					case 1174: efName = "Wm_mr_ludwigattackhit_e"; break;
					case 1175: efName = "Wm_mo_damage"; break;
					case 1176: efName = "Wm_mo_damagedie"; break;
					case 1177: efName = "Wm_mo_damagedie02"; break;
					case 1178: efName = "Wm_mo_damagedie02_a"; break;
					case 1179: efName = "Wm_mo_damagedie02_b"; break;
					case 1180: efName = "Wm_mo_damagedie02_bcld"; break;
					case 1181: efName = "Wm_mo_damagedie02_c"; break;
					case 1182: efName = "Wm_mo_damagedie02_d"; break;
					case 1183: efName = "Wm_mo_damagedie02_e"; break;
					case 1184: efName = "Wm_mo_damagedie02_f"; break;
					case 1185: efName = "Wm_mo_damagedie_a"; break;
					case 1186: efName = "Wm_mo_damagedie_b"; break;
					case 1187: efName = "Wm_mo_damagedie_bcld"; break;
					case 1188: efName = "Wm_mo_damagedie_cld"; break;
					case 1189: efName = "Wm_mo_damagedie_f"; break;
					case 1190: efName = "Wm_mo_damagedie_g"; break;
					case 1191: efName = "Wm_mo_damage_a"; break;
					case 1192: efName = "Wm_mo_damage_b"; break;
					case 1193: efName = "Wm_mo_damage_c"; break;
					case 1194: efName = "Wm_mo_damage_d"; break;
					case 1195: efName = "Wm_mo_drop"; break;
					case 1196: efName = "Wm_mo_firehit01"; break;
					case 1197: efName = "Wm_mo_firehit02"; break;
					case 1198: efName = "Wm_mo_firehit03"; break;
					case 1199: efName = "Wm_mo_jumpend"; break;
					case 1200: efName = "Wm_mo_jumpstart"; break;
					case 1201: efName = "Wm_mo_landsmoke"; break;
					case 1202: efName = "Wm_mo_landsmokebig"; break;
					case 1203: efName = "Wm_mo_landsmokebig_a"; break;
					case 1204: efName = "Wm_mo_landsmokebig_b"; break;
					case 1205: efName = "Wm_mo_landsmokebig_c"; break;
					case 1206: efName = "Wm_mo_landsmokebig_d"; break;
					case 1207: efName = "Wm_mo_landsmoke_a"; break;
					case 1208: efName = "Wm_mo_landsmoke_b"; break;
					case 1209: efName = "Wm_mo_landsmoke_c"; break;
					case 1210: efName = "Wm_mo_magicattack"; break;
					case 1211: efName = "Wm_mo_magicattack_a"; break;
					case 1212: efName = "Wm_mo_magicattack_b"; break;
					case 1213: efName = "Wm_mo_magicattack_c"; break;
					case 1214: efName = "Wm_mo_magicattack_d"; break;
					case 1215: efName = "Wm_mo_magicattack_e"; break;
					case 1216: efName = "Wm_mo_magicattack_st"; break;
					case 1217: efName = "Wm_mo_magicattack_st_a"; break;
					case 1218: efName = "Wm_mo_magicattack_st_b"; break;
					case 1219: efName = "Wm_mo_magicattack_st_c"; break;
					case 1220: efName = "Wm_mo_magicattack_st_d"; break;
					case 1221: efName = "Wm_mo_magmapocha"; break;
					case 1222: efName = "Wm_mo_magmapochas_a"; break;
					case 1223: efName = "Wm_mo_magmapochas_in"; break;
					case 1224: efName = "Wm_mo_magmapochas_ou"; break;
					case 1225: efName = "Wm_mo_magmapocha_a"; break;
					case 1226: efName = "Wm_mo_magmapocha_b"; break;
					case 1227: efName = "Wm_mo_magmapocha_c"; break;
					case 1228: efName = "Wm_mo_magmapocha_in"; break;
					case 1229: efName = "Wm_mo_magmapocha_ou"; break;
					case 1230: efName = "Wm_mo_magmapocha_s"; break;
					case 1231: efName = "Wm_mo_mgcwallhit"; break;
					case 1232: efName = "Wm_mo_mgcwallhit01"; break;
					case 1233: efName = "Wm_mo_mgcwallhit02"; break;
					case 1234: efName = "Wm_mo_mgcwallhit03"; break;
					case 1235: efName = "Wm_mo_mgcwallhit04"; break;
					case 1236: efName = "Wm_mo_pillarhit"; break;
					case 1237: efName = "Wm_mo_pillarhit_b"; break;
					case 1238: efName = "Wm_mo_pillarhit_c"; break;
					case 1239: efName = "Wm_mo_pillarhit_d"; break;
					case 1240: efName = "Wm_mo_pillarhi_a"; break;
					case 1241: efName = "Wm_mo_shellchange"; break;
					case 1242: efName = "Wm_mo_shelllandsmoke01"; break;
					case 1243: efName = "Wm_mo_shelllandsmoke02"; break;
					case 1244: efName = "Wm_mo_shelltail"; break;
					case 1245: efName = "Wm_mo_turn01_l"; break;
					case 1246: efName = "Wm_mo_turn01_r"; break;
					case 1247: efName = "Wm_mo_turn02"; break;
					case 1248: efName = "Wm_mo_turnbrake01"; break;
					case 1249: efName = "Wm_mo_turnbrake02"; break;
					case 1250: efName = "Wm_mo_wallhit"; break;
					case 1251: efName = "Wm_mo_wallhit_a"; break;
					case 1252: efName = "Wm_mr_moattackhit"; break;
					case 1253: efName = "Wm_mr_moattackhit_a"; break;
					case 1254: efName = "Wm_mr_moattackhit_b"; break;
					case 1255: efName = "Wm_mr_moattackhit_c"; break;
					case 1256: efName = "Wm_mr_moattackhit_d"; break;
					case 1257: efName = "Wm_mr_moattackhit_e"; break;
					case 1258: efName = "Wm_mr_quakewait"; break;
					case 1259: efName = "Wm_mr_quakewait"; break;
					case 1260: efName = "Wm_mr_royattackhit"; break;
					case 1261: efName = "Wm_mr_royattackhit_a"; break;
					case 1262: efName = "Wm_mr_royattackhit_b"; break;
					case 1263: efName = "Wm_mr_royattackhit_c"; break;
					case 1264: efName = "Wm_mr_royattackhit_d"; break;
					case 1265: efName = "Wm_mr_royattackhit_e"; break;
					case 1266: efName = "Wm_ro_damage"; break;
					case 1267: efName = "Wm_ro_damagedie"; break;
					case 1268: efName = "Wm_ro_damagedie02"; break;
					case 1269: efName = "Wm_ro_damagedie02_a"; break;
					case 1270: efName = "Wm_ro_damagedie02_b"; break;
					case 1271: efName = "Wm_ro_damagedie02_bcld"; break;
					case 1272: efName = "Wm_ro_damagedie02_c"; break;
					case 1273: efName = "Wm_ro_damagedie02_d"; break;
					case 1274: efName = "Wm_ro_damagedie02_e"; break;
					case 1275: efName = "Wm_ro_damagedie02_f"; break;
					case 1276: efName = "Wm_ro_damagedie_a"; break;
					case 1277: efName = "Wm_ro_damagedie_b"; break;
					case 1278: efName = "Wm_ro_damagedie_bcld"; break;
					case 1279: efName = "Wm_ro_damagedie_cld"; break;
					case 1280: efName = "Wm_ro_damagedie_f"; break;
					case 1281: efName = "Wm_ro_damagedie_g"; break;
					case 1282: efName = "Wm_ro_damage_a"; break;
					case 1283: efName = "Wm_ro_damage_b"; break;
					case 1284: efName = "Wm_ro_damage_c"; break;
					case 1285: efName = "Wm_ro_damage_d"; break;
					case 1286: efName = "Wm_ro_drop"; break;
					case 1287: efName = "Wm_ro_firehit01"; break;
					case 1288: efName = "Wm_ro_firehit02"; break;
					case 1289: efName = "Wm_ro_firehit03"; break;
					case 1290: efName = "Wm_ro_jumpend"; break;
					case 1291: efName = "Wm_ro_jumpstart"; break;
					case 1292: efName = "Wm_ro_landsmoke"; break;
					case 1293: efName = "Wm_ro_landsmokebig"; break;
					case 1294: efName = "Wm_ro_landsmokebig_a"; break;
					case 1295: efName = "Wm_ro_landsmokebig_b"; break;
					case 1296: efName = "Wm_ro_landsmokebig_c"; break;
					case 1297: efName = "Wm_ro_landsmokebig_d"; break;
					case 1298: efName = "Wm_ro_landsmoke_a"; break;
					case 1299: efName = "Wm_ro_landsmoke_b"; break;
					case 1300: efName = "Wm_ro_landsmoke_c"; break;
					case 1301: efName = "Wm_ro_magicattack"; break;
					case 1302: efName = "Wm_ro_magicattack_a"; break;
					case 1303: efName = "Wm_ro_magicattack_b"; break;
					case 1304: efName = "Wm_ro_magicattack_c"; break;
					case 1305: efName = "Wm_ro_magicattack_d"; break;
					case 1306: efName = "Wm_ro_magicattack_e"; break;
					case 1307: efName = "Wm_ro_magicattack_st"; break;
					case 1308: efName = "Wm_ro_magicattack_st_a"; break;
					case 1309: efName = "Wm_ro_magicattack_st_b"; break;
					case 1310: efName = "Wm_ro_magicattack_st_c"; break;
					case 1311: efName = "Wm_ro_magicattack_st_d"; break;
					case 1312: efName = "Wm_ro_mgcwallhit"; break;
					case 1313: efName = "Wm_ro_mgcwallhit01"; break;
					case 1314: efName = "Wm_ro_mgcwallhit02"; break;
					case 1315: efName = "Wm_ro_mgcwallhit03"; break;
					case 1316: efName = "Wm_ro_mgcwallhit04"; break;
					case 1317: efName = "Wm_ro_pipeappear"; break;
					case 1318: efName = "Wm_ro_pipepeep"; break;
					case 1319: efName = "Wm_ro_shellchange"; break;
					case 1320: efName = "Wm_ro_shelllandsmoke01"; break;
					case 1321: efName = "Wm_ro_shelllandsmoke02"; break;
					case 1322: efName = "Wm_ro_shelltail"; break;
					case 1323: efName = "Wm_ro_turn01_l"; break;
					case 1324: efName = "Wm_ro_turn01_r"; break;
					case 1325: efName = "Wm_ro_turn02"; break;
					case 1326: efName = "Wm_ro_turnbrake01"; break;
					case 1327: efName = "Wm_ro_turnbrake02"; break;
					case 1328: efName = "Wm_ro_wallhit"; break;
					case 1329: efName = "Wm_ro_wallhit_a"; break;
					case 1330: efName = "Wm_we_baton"; break;
					case 1331: efName = "Wm_we_damage"; break;
					case 1332: efName = "Wm_we_damagedie"; break;
					case 1333: efName = "Wm_we_damagedie02"; break;
					case 1334: efName = "Wm_we_damagedie02_a"; break;
					case 1335: efName = "Wm_we_damagedie02_b"; break;
					case 1336: efName = "Wm_we_damagedie02_bcld"; break;
					case 1337: efName = "Wm_we_damagedie02_c"; break;
					case 1338: efName = "Wm_we_damagedie02_d"; break;
					case 1339: efName = "Wm_we_damagedie02_e"; break;
					case 1340: efName = "Wm_we_damagedie02_f"; break;
					case 1341: efName = "Wm_we_damagedie_a"; break;
					case 1342: efName = "Wm_we_damagedie_b"; break;
					case 1343: efName = "Wm_we_damagedie_bcld"; break;
					case 1344: efName = "Wm_we_damagedie_cld"; break;
					case 1345: efName = "Wm_we_damagedie_f"; break;
					case 1346: efName = "Wm_we_damagedie_g"; break;
					case 1347: efName = "Wm_we_damage_a"; break;
					case 1348: efName = "Wm_we_damage_b"; break;
					case 1349: efName = "Wm_we_damage_c"; break;
					case 1350: efName = "Wm_we_damage_d"; break;
					case 1351: efName = "Wm_we_firehit01"; break;
					case 1352: efName = "Wm_we_firehit02"; break;
					case 1353: efName = "Wm_we_firehit03"; break;
					case 1354: efName = "Wm_we_jumpend"; break;
					case 1355: efName = "Wm_we_jumpstart"; break;
					case 1356: efName = "Wm_we_jumpwater"; break;
					case 1357: efName = "Wm_we_landsmoke"; break;
					case 1358: efName = "Wm_we_landsmoke_a"; break;
					case 1359: efName = "Wm_we_landsmoke_c"; break;
					case 1360: efName = "Wm_we_magicattack_st"; break;
					case 1361: efName = "Wm_we_magicattack_st_a"; break;
					case 1362: efName = "Wm_we_magicattack_st_b"; break;
					case 1363: efName = "Wm_we_magicattack_st_c"; break;
					case 1364: efName = "Wm_we_magicattack_st_d"; break;
					case 1365: efName = "Wm_we_rainbow"; break;
					case 1366: efName = "Wm_we_ringappear"; break;
					case 1367: efName = "Wm_we_ringappear_a"; break;
					case 1368: efName = "Wm_we_ringappear_b"; break;
					case 1369: efName = "Wm_we_ringappear_c"; break;
					case 1370: efName = "Wm_we_ringburst"; break;
					case 1371: efName = "Wm_we_ringburst_a"; break;
					case 1372: efName = "Wm_we_ringburst_b"; break;
					case 1373: efName = "Wm_we_ringhit"; break;
					case 1374: efName = "Wm_we_ringkira"; break;
					case 1375: efName = "Wm_we_ringtail"; break;
					case 1376: efName = "Wm_we_shellchange"; break;
					case 1377: efName = "Wm_we_shelllandsmoke01"; break;
					case 1378: efName = "Wm_we_shelllandsmoke02"; break;
					case 1379: efName = "Wm_we_shelltail"; break;
					case 1380: efName = "Wm_we_turn01_l"; break;
					case 1381: efName = "Wm_we_turn01_r"; break;
					case 1382: efName = "Wm_we_turn02"; break;
					case 1383: efName = "Wm_we_turnbrake01"; break;
					case 1384: efName = "Wm_we_turnbrake02"; break;
					case 1385: efName = "Wm_we_wallhit"; break;
					case 1386: efName = "Wm_we_wallhit_a"; break;
					case 1387: efName = "Wm_we_water"; break;
					case 1388: efName = "Wm_we_watersign"; break;
					case 1389: efName = "Wm_we_waterup"; break;
					case 1390: efName = "Wm_we_waterupsign"; break;
					case 1391: efName = "Wm_we_waterupsign_a"; break;
					case 1392: efName = "Wm_we_waterupsign_b"; break;
					case 1393: efName = "Wm_we_waterup_a"; break;
					case 1394: efName = "Wm_we_waterup_b"; break;
					case 1395: efName = "Wm_we_wlandsmoke"; break;
					case 1396: efName = "Wm_01mr_hardhit_glow"; break;
					case 1397: efName = "Wm_01mr_hardhit_grain"; break;
					case 1398: efName = "Wm_01mr_hardhit_spak"; break;
					case 1399: efName = "Wm_01mr_kick_glow"; break;
					case 1400: efName = "Wm_01mr_kick_grain"; break;
					case 1401: efName = "Wm_01mr_softhit_glow"; break;
					case 1402: efName = "Wm_01mr_softhit_spak"; break;
					case 1403: efName = "Wm_01_mr_1upkira"; break;
					case 1404: efName = "Wm_01_mr_1upkira_01"; break;
					case 1405: efName = "Wm_01_mr_1upkira_01_s"; break;
					case 1406: efName = "Wm_01_mr_1upkira_01_ss"; break;
					case 1407: efName = "Wm_01_mr_1upkira_02"; break;
					case 1408: efName = "Wm_01_mr_1upkira_s"; break;
					case 1409: efName = "Wm_01_mr_1upkira_spin"; break;
					case 1410: efName = "Wm_01_mr_1upkira_spin_s"; break;
					case 1411: efName = "Wm_01_mr_1upkira_spin_ss"; break;
					case 1412: efName = "Wm_01_mr_1upkira_ss"; break;
					case 1413: efName = "Wm_01_mr_beachbrakesmk"; break;
					case 1414: efName = "Wm_01_mr_beachbrakesmk_ss"; break;
					case 1415: efName = "Wm_01_mr_beachlandsmk"; break;
					case 1416: efName = "Wm_01_mr_beachlandsmk_s"; break;
					case 1417: efName = "Wm_01_mr_beachlandsmk_ss"; break;
					case 1418: efName = "Wm_01_mr_beachslipsmk"; break;
					case 1419: efName = "Wm_01_mr_beachslipsmk_ss"; break;
					case 1420: efName = "Wm_01_mr_brakesmoke"; break;
					case 1421: efName = "Wm_01_mr_brakesmoke_ss"; break;
					case 1422: efName = "Wm_01_mr_fireball_hit"; break;
					case 1423: efName = "Wm_01_mr_fireball_hit01"; break;
					case 1424: efName = "Wm_01_mr_hardhit"; break;
					case 1425: efName = "Wm_01_mr_icebrakesmk"; break;
					case 1426: efName = "Wm_01_mr_icebrakesmk_ss"; break;
					case 1427: efName = "Wm_01_mr_iceslipsmk"; break;
					case 1428: efName = "Wm_01_mr_iceslipsmk_ss"; break;
					case 1429: efName = "Wm_01_mr_kickhit"; break;
					case 1430: efName = "Wm_01_mr_landsmoke"; break;
					case 1431: efName = "Wm_01_mr_landsmoke_s"; break;
					case 1432: efName = "Wm_01_mr_landsmoke_ss"; break;
					case 1433: efName = "Wm_01_mr_sealandsmk"; break;
					case 1434: efName = "Wm_01_mr_sealandsmk_s"; break;
					case 1435: efName = "Wm_01_mr_sealandsmk_ss"; break;
					case 1436: efName = "Wm_01_mr_slipsmoke"; break;
					case 1437: efName = "Wm_01_mr_slipsmoke_big"; break;
					case 1438: efName = "Wm_01_mr_slipsmoke_ss"; break;
					case 1439: efName = "Wm_01_mr_sndbrakesmk"; break;
					case 1440: efName = "Wm_01_mr_sndbrakesmk_ss"; break;
					case 1441: efName = "Wm_01_mr_sndlandsmk"; break;
					case 1442: efName = "Wm_01_mr_sndlandsmk_s"; break;
					case 1443: efName = "Wm_01_mr_sndlandsmk_ss"; break;
					case 1444: efName = "Wm_01_mr_sndslipsmk"; break;
					case 1445: efName = "Wm_01_mr_sndslipsmk_ss"; break;
					case 1446: efName = "Wm_01_mr_softhit"; break;
					case 1447: efName = "Wm_01_mr_starkira"; break;
					case 1448: efName = "Wm_01_mr_starkira_a"; break;
					case 1449: efName = "Wm_01_mr_starkira_a_s"; break;
					case 1450: efName = "Wm_01_mr_starkira_b"; break;
					case 1451: efName = "Wm_01_mr_starkira_b_s"; break;
					case 1452: efName = "Wm_01_mr_starkira_s"; break;
					case 1453: efName = "Wm_01_mr_waterwave_in"; break;
					case 1454: efName = "Wm_01_mr_waterwave_in_a1"; break;
					case 1455: efName = "Wm_01_mr_waterwave_in_a2"; break;
					case 1456: efName = "Wm_01_mr_waterwave_in_a_ss"; break;
					case 1457: efName = "Wm_01_mr_waterwave_in_b"; break;
					case 1458: efName = "Wm_01_mr_waterwave_in_b_ss"; break;
					case 1459: efName = "Wm_01_mr_waterwave_in_c"; break;
					case 1460: efName = "Wm_01_mr_waterwave_in_ss"; break;
					case 1461: efName = "Wm_01_mr_waterwave_out"; break;
					case 1462: efName = "Wm_01_mr_waterwave_out_a"; break;
					case 1463: efName = "Wm_01_mr_waterwave_out_a_ss"; break;
					case 1464: efName = "Wm_01_mr_waterwave_out_b"; break;
					case 1465: efName = "Wm_01_mr_waterwave_out_b_ss"; break;
					case 1466: efName = "Wm_01_mr_waterwave_out_ss"; break;
					case 1467: efName = "Wm_01_mr_wirehit"; break;
					case 1468: efName = "Wm_01_mr_wirehit_glow"; break;
					case 1469: efName = "Wm_01_mr_wirehit_hit"; break;
					case 1470: efName = "Wm_01_mr_wirehit_line"; break;
					case 1471: efName = "Wm_01_mr_wirehit_star"; break;
					case 1472: efName = "Wm_02mr_hardhit_glow"; break;
					case 1473: efName = "Wm_02mr_hardhit_spak"; break;
					case 1474: efName = "Wm_02mr_kick_glow"; break;
					case 1475: efName = "Wm_02mr_kick_grain"; break;
					case 1476: efName = "Wm_02mr_softhit_glow"; break;
					case 1477: efName = "Wm_02mr_softhit_spak"; break;
					case 1478: efName = "Wm_02_mr_1upkira"; break;
					case 1479: efName = "Wm_02_mr_1upkira_01"; break;
					case 1480: efName = "Wm_02_mr_1upkira_01_s"; break;
					case 1481: efName = "Wm_02_mr_1upkira_01_ss"; break;
					case 1482: efName = "Wm_02_mr_1upkira_02"; break;
					case 1483: efName = "Wm_02_mr_1upkira_s"; break;
					case 1484: efName = "Wm_02_mr_1upkira_spin"; break;
					case 1485: efName = "Wm_02_mr_1upkira_spin_s"; break;
					case 1486: efName = "Wm_02_mr_1upkira_spin_ss"; break;
					case 1487: efName = "Wm_02_mr_1upkira_ss"; break;
					case 1488: efName = "Wm_02_mr_beachbrakesmk"; break;
					case 1489: efName = "Wm_02_mr_beachbrakesmk_ss"; break;
					case 1490: efName = "Wm_02_mr_beachlandsmk"; break;
					case 1491: efName = "Wm_02_mr_beachlandsmk_s"; break;
					case 1492: efName = "Wm_02_mr_beachlandsmk_ss"; break;
					case 1493: efName = "Wm_02_mr_beachslipsmk"; break;
					case 1494: efName = "Wm_02_mr_beachslipsmk_ss"; break;
					case 1495: efName = "Wm_02_mr_brakesmoke"; break;
					case 1496: efName = "Wm_02_mr_brakesmoke_ss"; break;
					case 1497: efName = "Wm_02_mr_fireball_hit"; break;
					case 1498: efName = "Wm_02_mr_hardhit"; break;
					case 1499: efName = "Wm_02_mr_icebrakesmk"; break;
					case 1500: efName = "Wm_02_mr_icebrakesmk_ss"; break;
					case 1501: efName = "Wm_02_mr_iceslipsmk"; break;
					case 1502: efName = "Wm_02_mr_iceslipsmk_ss"; break;
					case 1503: efName = "Wm_02_mr_kickhit"; break;
					case 1504: efName = "Wm_02_mr_landsmoke"; break;
					case 1505: efName = "Wm_02_mr_landsmoke_s"; break;
					case 1506: efName = "Wm_02_mr_landsmoke_ss"; break;
					case 1507: efName = "Wm_02_mr_sealandsmk"; break;
					case 1508: efName = "Wm_02_mr_sealandsmk_s"; break;
					case 1509: efName = "Wm_02_mr_sealandsmk_ss"; break;
					case 1510: efName = "Wm_02_mr_slipsmoke"; break;
					case 1511: efName = "Wm_02_mr_slipsmoke_big"; break;
					case 1512: efName = "Wm_02_mr_slipsmoke_ss"; break;
					case 1513: efName = "Wm_02_mr_sndbrakesmk"; break;
					case 1514: efName = "Wm_02_mr_sndbrakesmk_ss"; break;
					case 1515: efName = "Wm_02_mr_sndlandsmk"; break;
					case 1516: efName = "Wm_02_mr_sndlandsmk_s"; break;
					case 1517: efName = "Wm_02_mr_sndlandsmk_ss"; break;
					case 1518: efName = "Wm_02_mr_sndslipsmk"; break;
					case 1519: efName = "Wm_02_mr_sndslipsmk_ss"; break;
					case 1520: efName = "Wm_02_mr_softhit"; break;
					case 1521: efName = "Wm_02_mr_starkira"; break;
					case 1522: efName = "Wm_02_mr_starkira_a"; break;
					case 1523: efName = "Wm_02_mr_starkira_a_s"; break;
					case 1524: efName = "Wm_02_mr_starkira_b"; break;
					case 1525: efName = "Wm_02_mr_starkira_b_s"; break;
					case 1526: efName = "Wm_02_mr_starkira_s"; break;
					case 1527: efName = "Wm_02_mr_waterwave_in"; break;
					case 1528: efName = "Wm_02_mr_waterwave_in_a1"; break;
					case 1529: efName = "Wm_02_mr_waterwave_in_a2"; break;
					case 1530: efName = "Wm_02_mr_waterwave_in_a_ss"; break;
					case 1531: efName = "Wm_02_mr_waterwave_in_b"; break;
					case 1532: efName = "Wm_02_mr_waterwave_in_b_ss"; break;
					case 1533: efName = "Wm_02_mr_waterwave_in_c"; break;
					case 1534: efName = "Wm_02_mr_waterwave_in_ss"; break;
					case 1535: efName = "Wm_02_mr_waterwave_out"; break;
					case 1536: efName = "Wm_02_mr_waterwave_out_a"; break;
					case 1537: efName = "Wm_02_mr_waterwave_out_a_ss"; break;
					case 1538: efName = "Wm_02_mr_waterwave_out_b"; break;
					case 1539: efName = "Wm_02_mr_waterwave_out_b_ss"; break;
					case 1540: efName = "Wm_02_mr_waterwave_out_ss"; break;
					case 1541: efName = "Wm_02_mr_wirehit"; break;
					case 1542: efName = "Wm_02_mr_wirehit_glow"; break;
					case 1543: efName = "Wm_02_mr_wirehit_hit"; break;
					case 1544: efName = "Wm_02_mr_wirehit_line"; break;
					case 1545: efName = "Wm_02_mr_wirehit_star"; break;
					case 1546: efName = "Wm_03mr_hardhit_glow"; break;
					case 1547: efName = "Wm_03mr_hardhit_spak"; break;
					case 1548: efName = "Wm_03mr_kick_glow"; break;
					case 1549: efName = "Wm_03mr_softhit_glow"; break;
					case 1550: efName = "Wm_03mr_softhit_spak"; break;
					case 1551: efName = "Wm_03_mr_1upkira"; break;
					case 1552: efName = "Wm_03_mr_1upkira_01_s"; break;
					case 1553: efName = "Wm_03_mr_1upkira_01_ss"; break;
					case 1554: efName = "Wm_03_mr_1upkira_s"; break;
					case 1555: efName = "Wm_03_mr_1upkira_spin_s"; break;
					case 1556: efName = "Wm_03_mr_1upkira_spin_ss"; break;
					case 1557: efName = "Wm_03_mr_1upkira_ss"; break;
					case 1558: efName = "Wm_03_mr_beachbrakesmk"; break;
					case 1559: efName = "Wm_03_mr_beachbrakesmk_ss"; break;
					case 1560: efName = "Wm_03_mr_beachlandsmk"; break;
					case 1561: efName = "Wm_03_mr_beachlandsmk_s"; break;
					case 1562: efName = "Wm_03_mr_beachlandsmk_ss"; break;
					case 1563: efName = "Wm_03_mr_beachslipsmk"; break;
					case 1564: efName = "Wm_03_mr_beachslipsmk_ss"; break;
					case 1565: efName = "Wm_03_mr_brakesmoke"; break;
					case 1566: efName = "Wm_03_mr_brakesmoke_ss"; break;
					case 1567: efName = "Wm_03_mr_fireball_hit"; break;
					case 1568: efName = "Wm_03_mr_hardhit"; break;
					case 1569: efName = "Wm_03_mr_icebrakesmk"; break;
					case 1570: efName = "Wm_03_mr_icebrakesmk_ss"; break;
					case 1571: efName = "Wm_03_mr_iceslipsmk"; break;
					case 1572: efName = "Wm_03_mr_iceslipsmk_ss"; break;
					case 1573: efName = "Wm_03_mr_kickhit"; break;
					case 1574: efName = "Wm_03_mr_landsmoke"; break;
					case 1575: efName = "Wm_03_mr_landsmoke_s"; break;
					case 1576: efName = "Wm_03_mr_landsmoke_ss"; break;
					case 1577: efName = "Wm_03_mr_sealandsmk"; break;
					case 1578: efName = "Wm_03_mr_sealandsmk_s"; break;
					case 1579: efName = "Wm_03_mr_sealandsmk_ss"; break;
					case 1580: efName = "Wm_03_mr_slipsmoke"; break;
					case 1581: efName = "Wm_03_mr_slipsmoke_big"; break;
					case 1582: efName = "Wm_03_mr_slipsmoke_ss"; break;
					case 1583: efName = "Wm_03_mr_sndbrakesmk"; break;
					case 1584: efName = "Wm_03_mr_sndbrakesmk_ss"; break;
					case 1585: efName = "Wm_03_mr_sndlandsmk"; break;
					case 1586: efName = "Wm_03_mr_sndlandsmk_s"; break;
					case 1587: efName = "Wm_03_mr_sndlandsmk_ss"; break;
					case 1588: efName = "Wm_03_mr_sndslipsmk"; break;
					case 1589: efName = "Wm_03_mr_sndslipsmk_ss"; break;
					case 1590: efName = "Wm_03_mr_softhit"; break;
					case 1591: efName = "Wm_03_mr_starkira"; break;
					case 1592: efName = "Wm_03_mr_starkira_a"; break;
					case 1593: efName = "Wm_03_mr_starkira_a_s"; break;
					case 1594: efName = "Wm_03_mr_starkira_b"; break;
					case 1595: efName = "Wm_03_mr_starkira_b_s"; break;
					case 1596: efName = "Wm_03_mr_starkira_s"; break;
					case 1597: efName = "Wm_03_mr_waterwave_in"; break;
					case 1598: efName = "Wm_03_mr_waterwave_in_a1"; break;
					case 1599: efName = "Wm_03_mr_waterwave_in_a2"; break;
					case 1600: efName = "Wm_03_mr_waterwave_in_b"; break;
					case 1601: efName = "Wm_03_mr_waterwave_in_ss"; break;
					case 1602: efName = "Wm_03_mr_waterwave_out"; break;
					case 1603: efName = "Wm_03_mr_waterwave_out_ss"; break;
					case 1604: efName = "Wm_03_mr_wirehit"; break;
					case 1605: efName = "Wm_03_mr_wirehit_glow"; break;
					case 1606: efName = "Wm_03_mr_wirehit_hit"; break;
					case 1607: efName = "Wm_03_mr_wirehit_line"; break;
					case 1608: efName = "Wm_03_mr_wirehit_star"; break;
					case 1609: efName = "Wm_mg_balloonburst"; break;
					case 1610: efName = "Wm_mg_balloonburst_a"; break;
					case 1611: efName = "Wm_mg_balloonget_a"; break;
					case 1612: efName = "Wm_mg_balloonget_b"; break;
					case 1613: efName = "Wm_mg_balloonget_cld"; break;
					case 1614: efName = "Wm_mg_balloonget_g"; break;
					case 1615: efName = "Wm_mg_balloonget_r"; break;
					case 1616: efName = "Wm_mg_balloonget_y"; break;
					case 1617: efName = "Wm_mg_cursor"; break;
					case 1618: efName = "Wm_mg_cursor_2d"; break;
					case 1619: efName = "Wm_mg_cursor_st"; break;
					case 1620: efName = "Wm_mg_discharge01"; break;
					case 1621: efName = "Wm_mg_discharge02"; break;
					case 1622: efName = "Wm_mg_discharge03_a01"; break;
					case 1623: efName = "Wm_mg_discharge03_b"; break;
					case 1624: efName = "Wm_mg_discharge03_b01"; break;
					case 1625: efName = "Wm_mg_discharge03_g"; break;
					case 1626: efName = "Wm_mg_discharge03_mago"; break;
					case 1627: efName = "Wm_mg_discharge03_r"; break;
					case 1628: efName = "Wm_mg_discharge03_y"; break;
					case 1629: efName = "Wm_mg_dischargetail01"; break;
					case 1630: efName = "Wm_mg_dischargetail01b"; break;
					case 1631: efName = "Wm_mg_dischargetail01c"; break;
					case 1632: efName = "Wm_mg_dischargetail02"; break;
					case 1633: efName = "Wm_mg_itemget_cld"; break;
					case 1634: efName = "Wm_mg_itemget_fl"; break;
					case 1635: efName = "Wm_mg_itemget_fl_ok"; break;
					case 1636: efName = "Wm_mg_itemget_if"; break;
					case 1637: efName = "Wm_mg_itemget_kn"; break;
					case 1638: efName = "Wm_mg_itemget_mm"; break;
					case 1639: efName = "Wm_mg_itemget_pn"; break;
					case 1640: efName = "Wm_mg_itemget_pr"; break;
					case 1641: efName = "Wm_mg_itemget_st"; break;
					case 1642: efName = "Wm_mg_panelmiss"; break;
					case 1643: efName = "Wm_mg_panelmiss02"; break;
					case 1644: efName = "Wm_mg_panelmiss02_a"; break;
					case 1645: efName = "Wm_mg_panelmiss02_b"; break;
					case 1646: efName = "Wm_mg_panelmiss02_c"; break;
					case 1647: efName = "Wm_mg_panelmiss02_d"; break;
					case 1648: efName = "Wm_mg_panelmiss02_s"; break;
					case 1649: efName = "Wm_mg_panelmiss02_s_a"; break;
					case 1650: efName = "Wm_mg_panelmiss02_s_b"; break;
					case 1651: efName = "Wm_mg_panelmiss02_s_c"; break;
					case 1652: efName = "Wm_mg_panelmiss_a"; break;
					case 1653: efName = "Wm_mg_panelmiss_b"; break;
					case 1654: efName = "Wm_mg_panelmiss_c"; break;
					case 1655: efName = "Wm_mg_panelmiss_d"; break;
					case 1656: efName = "Wm_mg_panelmiss_s"; break;
					case 1657: efName = "Wm_mg_panelmiss_s_a"; break;
					case 1658: efName = "Wm_mg_panelmiss_s_b"; break;
					case 1659: efName = "Wm_mg_panelmiss_s_c"; break;
					case 1660: efName = "Wm_mg_panelopen"; break;
					case 1661: efName = "Wm_mg_panelperfect"; break;
				}

				if (efName != 0) {
					S16Vec zero = {0, 0, 0};
					Vec3 scale_vec = {this->effect_scale, this->effect_scale, this->effect_scale};
					SpawnEffect(efName, 0, &this->pos, &zero, &scale_vec);
				}
			}
	
			this->timer = 0;
			if (this->delay == 0) { this->delay = -1; }
		}
		
		this->timer += 1;
	}
	return true;
}

//
// processed\../src/shyguy.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include <profile.h>

const char* SGarcNameList [] = {
	"shyguy",
	"iron_ball",
	NULL	
};

// Shy Guy Settings
// 
// Nybble 5: Shy Guy Types
// 		0 - Walker
// 		1 - Pacing Walker
// 		2 - Sleeper
// 		3 - Jumper
// 		4 - Judo Master
// 		5 - Spike Thrower
// 		6 - Ballooneer Horizontal
// 		7 - Ballooneer Vertical
// 		8 - Ballooneer Circular
// 		9 - Walking Giant
// 		10 - Pacing Giant
//
// Nybble 9: Distance Moved
// 		# - Distance for Pacing Walker, Pacing Giants, and Ballooneers
//
// If I add items in the balloons....
// I_kinoko, I_fireflower, I_propeller_model, I_iceflower, I_star, I_penguin - model names
// anmChr - wait2

void shyCollisionCallback(ActivePhysics *apThis, ActivePhysics *apOther);	
void ChucklesAndKnuckles(ActivePhysics *apThis, ActivePhysics *apOther);
void balloonSmack(ActivePhysics *apThis, ActivePhysics *apOther);

class daShyGuy : public dEn_c {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile anmFile;
	nw4r::g3d::ResFile balloonFile;
	// nw4r::g3d::ResFile carryFile;

	m3d::mdl_c bodyModel;
	m3d::mdl_c balloonModel;
	m3d::mdl_c balloonModelB;
	// m3d::mdl_c carryModel;1

	m3d::anmChr_c chrAnimation;
	// m3d::anmChr_c carryAnm;

	mEf::es2 effect;

	int timer;
	int jumpCounter;
	int baln;
	float dying;
	float Baseline;
	char damage;
	char isDown;
	char renderBalloon;
	Vec initialPos;
	int distance;
	float XSpeed;
	u32 cmgr_returnValue;
	bool isBouncing;
	float balloonSize;
	char backFire;
	char spikeTurn;
	int directionStore;
	dStageActor_c *spikeA;
	dStageActor_c *spikeB;
	bool stillFalling;

	StandOnTopCollider giantRider;
	ActivePhysics Chuckles;
	ActivePhysics Knuckles;
	ActivePhysics balloonPhysics;

	public: static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();
	bool calculateTileCollisions();

	void spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	// bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);

	void _vf148();
	void _vf14C();
	bool CreateIceActors();

	bool willWalkOntoSuitableGround();

	USING_STATES(daShyGuy);
	DECLARE_STATE(Walk);
	DECLARE_STATE(Turn);
	DECLARE_STATE(RealWalk);
	DECLARE_STATE(RealTurn);
	DECLARE_STATE(Jump);
	DECLARE_STATE(Sleep);
	DECLARE_STATE(Balloon_H);
	DECLARE_STATE(Balloon_V);
	DECLARE_STATE(Balloon_C);
	DECLARE_STATE(Judo);
	DECLARE_STATE(Spike);

	DECLARE_STATE(GoDizzy);
	DECLARE_STATE(BalloonDrop);
	DECLARE_STATE(FireKnockBack);
	DECLARE_STATE(FlameHit);
	DECLARE_STATE(Recover);

	DECLARE_STATE(Die);

	public: void popBalloon();
	int type;
};


const SpriteData ShyGuySpriteData = {ProfileId::ShyGuy, 0x5, -0x31, 0, 0x10, 0x10, 0x40, 0x40, 0x40, 0, 0, 0};
// #      -ID- ----  -X Offs- -Y Offs-  -RectX1- -RectY1- -RectX2- -RectY2-  -1C- -1E- -20- -22-  Flag ----
Profile ShyGuyProfile(&daShyGuy::build, SpriteId::ShyGuy, ShyGuySpriteData, ProfileId::DUMMY_DOOR_CHILD, ProfileId::ShyGuy, "ShyGuy", SGarcNameList);


dActor_c *daShyGuy::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daShyGuy));
	return new(buffer) daShyGuy;
}



///////////////////////
// Externs and States
///////////////////////
	extern "C" bool SpawnEffect(const char*, int, Vec*, S16Vec*, Vec*);

	//FIXME make this dEn_c->used...
	extern "C" char usedForDeterminingStatePress_or_playerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther, int unk1);
	extern "C" int SomeStrangeModification(dStageActor_c* actor);
	extern "C" void DoStuffAndMarkDead(dStageActor_c *actor, Vec vector, float unk);
	extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);
	// extern "C" void addToList(StandOnTopCollider *self);

	extern "C" bool HandlesEdgeTurns(dEn_c* actor);


	CREATE_STATE(daShyGuy, Walk);
	CREATE_STATE(daShyGuy, Turn);
	CREATE_STATE(daShyGuy, RealWalk);
	CREATE_STATE(daShyGuy, RealTurn);
	CREATE_STATE(daShyGuy, Jump);
	CREATE_STATE(daShyGuy, Sleep);
	CREATE_STATE(daShyGuy, Balloon_H);
	CREATE_STATE(daShyGuy, Balloon_V);
	CREATE_STATE(daShyGuy, Balloon_C);
	CREATE_STATE(daShyGuy, Judo);
	CREATE_STATE(daShyGuy, Spike);

	CREATE_STATE(daShyGuy, GoDizzy);
	CREATE_STATE(daShyGuy, BalloonDrop);
	CREATE_STATE(daShyGuy, FireKnockBack);
	CREATE_STATE(daShyGuy, FlameHit);
	CREATE_STATE(daShyGuy, Recover);

	CREATE_STATE(daShyGuy, Die);

////////////////////////
// Collision Functions
////////////////////////

	bool actorCanPopBalloon(dStageActor_c *ac) {
		int n = ac->name;
		return n == PLAYER || n == YOSHI ||
			n == PL_FIREBALL || n == ICEBALL ||
			n == YOSHI_FIRE || n == HAMMER;
	}
	// Collision callback to help shy guy not die at inappropriate times and ruin the dinner

	void shyCollisionCallback(ActivePhysics *apThis, ActivePhysics *apOther) {
		int t = ((daShyGuy*)apThis->owner)->type;
		if (t == 6 || t == 7 || t == 8) {
			// Should I do something about ice blocks here?
			if (actorCanPopBalloon(apOther->owner))
				((daShyGuy*)apThis->owner)->popBalloon();
		}

		if ((apOther->owner->name == 89) && (t == 5)) { return; }
			
		dEn_c::collisionCallback(apThis, apOther); 
	}

	void ChucklesAndKnuckles(ActivePhysics *apThis, ActivePhysics *apOther) {
		if (apOther->owner->name != PLAYER) { return; }
		((dEn_c*)apThis->owner)->_vf220(apOther->owner);
	}

	void balloonSmack(ActivePhysics *apThis, ActivePhysics *apOther) {
		if (((daShyGuy*)apThis->owner)->frzMgr._mstate == 0) {
			if (actorCanPopBalloon(apOther->owner))
				((daShyGuy*)apThis->owner)->popBalloon();
		}
	}

	void daShyGuy::spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		u16 name = ((dEn_c*)apOther->owner)->name;

		if (name == EN_COIN || name == EN_EATCOIN || name == AC_BLOCK_COIN || name == EN_COIN_JUGEM || name == EN_COIN_ANGLE
			|| name == EN_COIN_JUMP || name == EN_COIN_FLOOR || name == EN_COIN_VOLT || name == EN_COIN_WIND 
			|| name == EN_BLUE_COIN || name == EN_COIN_WATER || name == EN_REDCOIN || name == EN_GREENCOIN
			|| name == EN_JUMPDAI || name == EN_ITEM) 
			{ return; }

		if (acState.getCurrentState() == &StateID_RealWalk) {

			pos.x = ((pos.x - ((dEn_c*)apOther->owner)->pos.x) > 0) ? pos.x + 1.5 : pos.x - 1.5;
			// pos.x = direction ? pos.x + 1.5 : pos.x - 1.5;
			doStateChange(&StateID_RealTurn); }

		if (acState.getCurrentState() == &StateID_FireKnockBack) {
			float distance = pos.x - ((dEn_c*)apOther->owner)->pos.x;
			pos.x = pos.x + (distance / 4.0);
		}

		dEn_c::spriteCollision(apThis, apOther); 
	}

	void daShyGuy::popBalloon() {
		doStateChange(&StateID_BalloonDrop);
	}

	void daShyGuy::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		dStateBase_c *stateVar;
		dStateBase_c *deathState;
		
		char hitType;
		if (this->type < 6) {  // Regular Shy Guys
			stateVar = &StateID_GoDizzy;
			deathState = &StateID_Die;
		}
		else { // Ballooneers
			stateVar = &StateID_BalloonDrop;
			deathState = &StateID_Die;
		}


		if (this->isDown == 0) { 
			hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 2);
		}
		else { // Shy Guy is in downed mode
			hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);
		}

		if(hitType == 1) {	// regular jump
			apOther->someFlagByte |= 2;
			if (this->isDown == 0) { 
				this->playEnemyDownSound1();
				if (damage >= 1) {
					doStateChange(deathState); }
				else {
					doStateChange(stateVar); }
				damage++;
			}
			else { // Shy Guy is in downed mode - kill it with fire
				this->playEnemyDownSound1();
				doStateChange(deathState);
			}				
		} 
		else if(hitType == 3) {	// spinning jump or whatever?
			apOther->someFlagByte |= 2;
			if (this->isDown == 0) { 
				this->playEnemyDownSound1();
				if (damage >= 1) {
					doStateChange(deathState); }
				else {
					doStateChange(stateVar); }
				damage++;
			}
			else { // Shy Guy is in downed mode - kill it with fire
				this->playEnemyDownSound1();
				doStateChange(deathState);
			}				
		} 
		else if(hitType == 0) {
			this->dEn_c::playerCollision(apThis, apOther);
			this->_vf220(apOther->owner);
		} 
		// else if(hitType == 2) { \\ Minimario? } 
	}

	void daShyGuy::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->playerCollision(apThis, apOther);
	}
	bool daShyGuy::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) { 
		PlaySound(this, SE_EMY_DOWN); 
		SpawnEffect("Wm_mr_hardhit", 0, &pos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		//addScoreWhenHit accepts a player parameter.
		//DON'T DO THIS:
		// this->addScoreWhenHit(this);
		doStateChange(&StateID_Die); 
		return true;
	}
	bool daShyGuy::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
		return this->collisionCatD_Drill(apThis, apOther);
	}
	bool daShyGuy::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
		return this->collisionCatD_Drill(apThis, apOther);
	}
	bool daShyGuy::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
		return this->collisionCatD_Drill(apThis, apOther);
	}
	bool daShyGuy::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){
		return this->collisionCatD_Drill(apThis, apOther);
	}
	bool daShyGuy::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther){
		return this->collisionCatD_Drill(apThis, apOther);
	}
	bool daShyGuy::collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther){
		return this->collisionCatD_Drill(apThis, apOther);
	}
	bool daShyGuy::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
		StageE4::instance->spawnCoinJump(pos, 0, 2, 0);
		return this->collisionCatD_Drill(apThis, apOther);
	}

	bool daShyGuy::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){
		bool wut = dEn_c::collisionCat3_StarPower(apThis, apOther);
		doStateChange(&StateID_Die);
		return wut;
	}

	bool daShyGuy::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){
		doStateChange(&StateID_DieSmoke);
		return true;
	}
	bool daShyGuy::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->damage += 1;

		dStateBase_c *stateVar;
		stateVar = &StateID_DieSmoke;
		
		if (this->type < 6) {  // Regular Shy Guys Except Jumper

			backFire = apOther->owner->direction ^ 1;
			
			// if (this->isDown == 0) {
			// 	stateVar = &StateID_FireKnockBack;
			// }
			// else {
				StageE4::instance->spawnCoinJump(pos, 0, 1, 0);
				doStateChange(&StateID_DieSmoke);
			// }
		}
		else { // Ballooneers
			stateVar = &StateID_FlameHit;
		}

		if (this->damage > 1) {
			nw4r::snd::SoundHandle handle;
			PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_EMY_DOWN, 1);
			StageE4::instance->spawnCoinJump(pos, 0, 1, 0);
			doStateChange(&StateID_DieSmoke);
		}
		else {
			nw4r::snd::SoundHandle handle;
			PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_EMY_KURIBO_L_DAMAGE_01, 1);
			doStateChange(stateVar);
		}
		return true;
	}

	// void daShyGuy::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {
		
	// 	dEn_C::collisionCat2_IceBall_15_YoshiIce(apThis, apOther);
	// }

	// These handle the ice crap
	void daShyGuy::_vf148() {
		dEn_c::_vf148();
		doStateChange(&StateID_Die);
	}
	void daShyGuy::_vf14C() {
		dEn_c::_vf14C();
		doStateChange(&StateID_Die);
	}

	extern "C" void sub_80024C20(void);
	extern "C" void __destroy_arr(void*, void(*)(void), int, int);
	//extern "C" __destroy_arr(struct DoSomethingCool, void(*)(void), int cnt, int bar);

	bool daShyGuy::CreateIceActors() {
		struct DoSomethingCool my_struct = { 0, this->pos, {1.2, 1.5, 1.5}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	    this->frzMgr.Create_ICEACTORs( (void*)&my_struct, 1 );
	    __destroy_arr( (void*)&my_struct, sub_80024C20, 0x3C, 1 );
	    chrAnimation.setUpdateRate(0.0f);
	    return true;
	}

bool daShyGuy::calculateTileCollisions() {
	// Returns true if sprite should turn, false if not.

	HandleXSpeed();
	HandleYSpeed();
	doSpriteMovement();

	cmgr_returnValue = collMgr.isOnTopOfTile();
	collMgr.calculateBelowCollisionWithSmokeEffect();

	if (isBouncing) {
		stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);
		if (speed.y != 0.0f)
			isBouncing = false;
	}

	float xDelta = pos.x - last_pos.x;
	if (xDelta >= 0.0f)
		direction = 0;
	else
		direction = 1;

	if (collMgr.isOnTopOfTile()) {
		// Walking into a tile branch

		if (cmgr_returnValue == 0)
			isBouncing = true;

		if (speed.x != 0.0f) {
			//playWmEnIronEffect();
		}

		speed.y = 0.0f;

		// u32 blah = collMgr.s_80070760();
		// u8 one = (blah & 0xFF);
		// static const float incs[5] = {0.00390625f, 0.0078125f, 0.015625f, 0.0234375f, 0.03125f};
		// x_speed_inc = incs[one];
		max_speed.x = (direction == 1) ? -XSpeed : XSpeed;
	} else {
		x_speed_inc = 0.0f;
	}

	// Bouncing checks
	if (_34A & 4) {
		Vec v = (Vec){0.0f, 1.0f, 0.0f};
		collMgr.pSpeed = &v;

		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;

		collMgr.pSpeed = &speed;

	} else {
		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;
	}

	collMgr.calculateAdjacentCollision(0);

	// Switch Direction
	if (collMgr.outputMaybe & (0x15 << direction)) {
		if (collMgr.isOnTopOfTile()) {
			isBouncing = true;
		}
		return true;
	}
	return false;
}

void daShyGuy::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->anmFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daShyGuy::onCreate() {

	this->type = this->settings >> 28 & 0xF;
	int baln = this->settings >> 24 & 0xF;
	this->distance = this->settings >> 12 & 0xF;

	stillFalling = 0;

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->deleteForever = 1;

	// Balloon Specifics
	if (type == 6 || type == 7 || type == 8) {
		this->renderBalloon = 1;

		this->balloonFile.data = getResource("shyguy", "g3d/balloon.brres");
		nw4r::g3d::ResMdl mdlB = this->balloonFile.GetResMdl("ballon");
		balloonModel.setup(mdlB, &allocator, 0x224, 1, 0);
		balloonModelB.setup(mdlB, &allocator, 0x224, 1, 0);

		ActivePhysics::Info iballoonPhysics;

		iballoonPhysics.xDistToCenter = 0.0;
		iballoonPhysics.yDistToCenter = -18.0;
		iballoonPhysics.xDistToEdge   = 13.0;
		iballoonPhysics.yDistToEdge   = 12.0;

		iballoonPhysics.category1  = 0x3;
		iballoonPhysics.category2  = 0x0;
		iballoonPhysics.bitfield1  = 0x4f;
		iballoonPhysics.bitfield2  = 0xffbafffe;
		iballoonPhysics.unkShort1C = 0x0;
		iballoonPhysics.callback   = balloonSmack;

		balloonPhysics.initWithStruct(this, &iballoonPhysics);
		balloonPhysics.addToList();


		// if (baln != 0) {
		// 	char *itemArc;
		// 	char *itemBrres;
		// 	char *itemMdl;

		// 	if (baln == 1) { 
		// 		itemArc		= "I_kinoko";
		// 		itemBrres	= "g3d/I_kinoko.brres";
		// 		itemMdl		= "I_kinoko";
		// 	}
		// 	else if (baln == 2) { 
		// 		itemArc		= "I_fireflower";
		// 		itemBrres	= "g3d/I_fireflower.brres";
		// 		itemMdl		= "I_fireflower";
		// 	}
		// 	else if (baln == 3) { 
		// 		itemArc		= "I_propeller";
		// 		itemBrres	= "g3d/I_propeller.brres";
		// 		itemMdl		= "I_propeller_model";
		// 	}
		// 	else if (baln == 4) { 
		// 		itemArc		= "I_iceflower";
		// 		itemBrres	= "g3d/I_iceflower.brres";
		// 		itemMdl		= "I_iceflower";
		// 	}
		// 	else if (baln == 5) { 
		// 		itemArc		= "I_star";
		// 		itemBrres	= "g3d/I_star.brres";
		// 		itemMdl		= "I_star";
		// 	}
		// 	else if (baln == 6) { 
		// 		itemArc		= "I_penguin";
		// 		itemBrres	= "g3d/I_penguin.brres";
		// 		itemMdl		= "I_penguin";
		// 	}

		// 	this->carryFile.data = getResource(itemArc, itemBrres);
		// 	nw4r::g3d::ResMdl mdlC = this->carryFile.GetResMdl(itemMdl);
		// 	carryModel.setup(mdlC, &allocator, 0x224, 1, 0);

		// 	nw4r::g3d::ResAnmChr anmChrC = this->carryFile.GetResAnmChr("wait2");
		// 	this->carryAnm.setup(mdlC, anmChrC, &this->allocator, 0);

		// 	this->carryAnm.bind(&this->carryModel, anmChrC, 1);
		// 	this->carryModel.bindAnim(&this->carryAnm, 0.0);
		// 	this->carryAnm.setUpdateRate(1.0);
		// }
	}
	else {this->renderBalloon = 0;}


	// Shy Guy Colours
	if (type == 1 || type == 8 || type == 10) {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyBlue.brres");
		distance = 1;
	}
	else if (type == 5) {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyGreen.brres");
	}
	else if (type == 3) {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyCyan.brres");
	}
	else if (type == 4) {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyPurple.brres");
	}
	else {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyRed.brres");
	}
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("body_h");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);


	// Animations start here
	this->anmFile.data = getResource("shyguy", "g3d/ShyGuyAnimations.brres");
	nw4r::g3d::ResAnmChr anmChr = this->anmFile.GetResAnmChr("c18_IDLE_R");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	// Stuff I do understand

	this->scale = (Vec){20.0, 20.0, 20.0};

	this->pos.y += 36.0;
	this->rot.x = 0; // X is vertical axis
	this->rot.y = 0xD800; // Y is horizontal axis
	this->rot.z = 0; // Z is ... an axis >.>
	this->direction = 1; // Heading left.
	
	this->speed.x = 0.0;
	this->speed.y = 0.0;
	this->max_speed.x = 0.6;
	this->x_speed_inc = 0.15;
	this->Baseline = this->pos.y;
	this->XSpeed = 0.6;
	this->balloonSize = 1.5;


	ActivePhysics::Info HitMeBaby;

	// Note: if this gets changed, also change the point where the default
	// values are assigned after de-ballooning
	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 12.0;
	HitMeBaby.xDistToEdge = 8.0;
	HitMeBaby.yDistToEdge = 12.0;
	if (renderBalloon) {
		HitMeBaby.yDistToCenter = 9.0f;
		HitMeBaby.yDistToEdge = 9.0f;
	}

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &shyCollisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	// Tile collider

	// These fucking rects do something for the tile rect
	spriteSomeRectX = 28.0f;
	spriteSomeRectY = 32.0f;
	_320 = 0.0f;
	_324 = 16.0f;

	// These structs tell stupid collider what to collide with - these are from koopa troopa
	static const lineSensor_s below(-5<<12, 5<<12, 0<<12);
	static const pointSensor_s above(0<<12, 12<<12);
	static const lineSensor_s adjacent(6<<12, 9<<12, 6<<12);

	collMgr.init(this, &below, &above, &adjacent);
	collMgr.calculateBelowCollisionWithSmokeEffect();

	cmgr_returnValue = collMgr.isOnTopOfTile();

	if (collMgr.isOnTopOfTile())
		isBouncing = false;
	else
		isBouncing = true;


	// State Changers
	
	if (type == 0) {
		bindAnimChr_and_setUpdateRate("c18_EV_WIN_2_R", 1, 0.0, 1.5); 
		doStateChange(&StateID_RealWalk);
	}		
	else if (type == 1) {
		bindAnimChr_and_setUpdateRate("c18_EV_WIN_2_R", 1, 0.0, 1.5); 
		doStateChange(&StateID_RealWalk);
	}		
	else if (type == 2) {
		doStateChange(&StateID_Sleep);
	}		
	else if (type == 3) {
		doStateChange(&StateID_Jump);
	}		
	else if (type == 4) {
		// Chuckles is left, Knuckles is Right
		ActivePhysics::Info iChuckles;
		ActivePhysics::Info iKnuckles;

		iChuckles.xDistToCenter = -27.0;
		iChuckles.yDistToCenter = 12.0;
		iChuckles.xDistToEdge   = 27.0;
		iChuckles.yDistToEdge   = 10.0;

		iKnuckles.xDistToCenter = 27.0;
		iKnuckles.yDistToCenter = 12.0;
		iKnuckles.xDistToEdge   = 27.0;
		iKnuckles.yDistToEdge   = 10.0;

		iKnuckles.category1  = iChuckles.category1  = 0x3;
		iKnuckles.category2  = iChuckles.category2  = 0x0;
		iKnuckles.bitfield1  = iChuckles.bitfield1  = 0x4F;
		iKnuckles.bitfield2  = iChuckles.bitfield2  = 0x0;
		iKnuckles.unkShort1C = iChuckles.unkShort1C = 0x0;
		iKnuckles.callback   = iChuckles.callback   = ChucklesAndKnuckles;

		Chuckles.initWithStruct(this, &iChuckles);
		Knuckles.initWithStruct(this, &iKnuckles);

		doStateChange(&StateID_Judo);
	}		
	else if (type == 5) {
		doStateChange(&StateID_Spike);
	}		
	else if (type == 6) {
		doStateChange(&StateID_Balloon_H);
	}		
	else if (type == 7) {
		doStateChange(&StateID_Balloon_V);
	}		
	else if (type == 8) {
		doStateChange(&StateID_Balloon_C);
	}		

	this->onExecute();
	return true;
}

int daShyGuy::onDelete() {
	return true;
}

int daShyGuy::onExecute() {
	acState.execute();
	updateModelMatrices();
	bodyModel._vf1C();

	return true;
}

int daShyGuy::onDraw() {
	bodyModel.scheduleForDrawing();

	if (this->renderBalloon == 1) {
		balloonModel.scheduleForDrawing();
		balloonModelB.scheduleForDrawing();
	}

	// if (this->baln > 0) {
	// 	carryModel.scheduleForDrawing();
	// 	carryModel._vf1C();

	// 	if(this->carryAnm.isAnimationDone())
	// 		this->carryAnm.setCurrentFrame(0.0);
	// }

	return true;
}

void daShyGuy::updateModelMatrices() {
	// This won't work with wrap because I'm lazy.

	if (this->frzMgr._mstate == 1)
		matrix.translation(pos.x, pos.y, pos.z);
	else
		matrix.translation(pos.x, pos.y - 2.0, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);

	if (this->renderBalloon == 1) {
		matrix.translation(pos.x, pos.y - 32.0, pos.z);

		balloonModel.setDrawMatrix(matrix);
		balloonModel.setScale(balloonSize, balloonSize, balloonSize);
		balloonModel.calcWorld(false);

		balloonModelB.setDrawMatrix(matrix);
		balloonModelB.setScale(balloonSize, balloonSize, balloonSize);
		balloonModelB.calcWorld(false);
	}

	// if (this->baln > 0) {
	// 	matrix.applyRotationYXZ(0,0,0);
	// 	matrix.translation(pos.x+40.0, pos.y - 28.0, pos.z + 1000.0);

	// 	carryModel.setDrawMatrix(matrix);
	// 	carryModel.setScale(21.0, 21.0, 21.0);
	// 	carryModel.calcWorld(false);
	// }

}

///////////////
// Walk State
///////////////
	void daShyGuy::beginState_Walk() { 
		this->timer = 0;
		this->rot.y = (direction) ? 0xD800 : 0x2800;

		this->max_speed.x = 0.0;
		this->speed.x = 0.0;
		this->x_speed_inc = 0.0;
	}
	void daShyGuy::executeState_Walk() { 
		chrAnimation.setUpdateRate(1.5f);

		this->pos.x += (direction) ? -0.4 : 0.4;

		if (this->timer > (this->distance * 32)) {
			doStateChange(&StateID_Turn);
		}

		if(this->chrAnimation.isAnimationDone())
			this->chrAnimation.setCurrentFrame(0.0);

		this->timer = this->timer + 1;
	}
	void daShyGuy::endState_Walk() { 
	}

///////////////
// Turn State
///////////////
	void daShyGuy::beginState_Turn() { 
		// bindAnimChr_and_setUpdateRate("c18_IDLE_R", 1, 0.0, 1.0);
		this->direction ^= 1;
		this->speed.x = 0.0;
	}
	void daShyGuy::executeState_Turn() { 

		if(this->chrAnimation.isAnimationDone())
			this->chrAnimation.setCurrentFrame(0.0);

		u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
		int done = SmoothRotation(&this->rot.y, amt, 0x800);

		if(done) {
			this->doStateChange(&StateID_Walk);
		}
	}
	void daShyGuy::endState_Turn() { 
	}

///////////////
// Jump State
///////////////
	void daShyGuy::beginState_Jump() { 
		this->max_speed.x = 0.0;
		this->speed.x = 0.0;
		this->x_speed_inc = 0.0;

		this->timer = 0;
		this->jumpCounter = 0;
	}
	void daShyGuy::executeState_Jump() { 

		// Always face Mario
		u8 facing = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);

		if (facing != this->direction) {
			this->direction = facing;
			this->rot.y = (direction) ? 0xD800 : 0x2800;
		}

		// Shy Guy is on ground
		if (this->pos.y < this->Baseline) {

			bindAnimChr_and_setUpdateRate("c18_IDLE_R", 1, 0.0, 1.0);
			
			this->timer = this->timer + 1;

			// Make him wait for 0.5 seconds
			if (this->timer > 30) {

				if(this->chrAnimation.isAnimationDone())
					this->chrAnimation.setCurrentFrame(0.0);

				this->speed.x = 0;
				this->speed.y = 0;	
			}

			// Then Jump!
			else { 
				if (this->jumpCounter == 3) { this->jumpCounter = 0; }

				this->pos.y = this->Baseline + 1;
				this->timer = 0;
				this->jumpCounter = this->jumpCounter + 1;


				if (this->jumpCounter == 3) {
					bindAnimChr_and_setUpdateRate("c18_NORMAL_STEAL_R", 1, 0.0, 1.0);
					this->speed.y = 8.0;
					PlaySoundAsync(this, SE_PLY_JUMPDAI_HIGH);
				}
				else {
					bindAnimChr_and_setUpdateRate("c18_EV_WIN_1_R", 1, 0.0, 1.0);
					this->speed.y = 6.0;
					PlaySoundAsync(this, SE_PLY_JUMPDAI);
				}

			}
		}

		// While he's jumping, it's time for gravity.
		else { 

			this->speed.y = this->speed.y - 0.15; 

			if (this->jumpCounter == 3) {
				if(this->chrAnimation.isAnimationDone())
					this->chrAnimation.setCurrentFrame(0.0);
			}
			else {
				if(this->chrAnimation.isAnimationDone())
					this->chrAnimation.setCurrentFrame(0.0);
			}
		}

		this->HandleXSpeed();
		this->HandleYSpeed();
		this->UpdateObjectPosBasedOnSpeedValuesReal();
	}
	void daShyGuy::endState_Jump() { 
	}

///////////////
// Sleep State
///////////////
	void daShyGuy::beginState_Sleep() { 
		bindAnimChr_and_setUpdateRate("c18_EV_LOSE_2_R", 1, 0.0, 1.0);
		this->rot.y = 0x0000;
	}
	void daShyGuy::executeState_Sleep() { 
		if(this->chrAnimation.isAnimationDone())
			this->chrAnimation.setCurrentFrame(0.0);
	}
	void daShyGuy::endState_Sleep() { 
	}

///////////////
// Balloon H State
///////////////
	void daShyGuy::beginState_Balloon_H() { 
		bindAnimChr_and_setUpdateRate("c18_L_DMG_F_3_R", 1, 0.0, 1.0);
		this->timer = 0;
		this->initialPos = this->pos;
		this->rot.x = 0xFE00;
		this->rot.y = 0;
	}
	void daShyGuy::executeState_Balloon_H() { 

		// Makes him bob up and down
		this->pos.y = this->initialPos.y + ( sin(this->timer * 3.14 / 60.0) * 6.0 );

		// Makes him move side to side
		this->pos.x = this->initialPos.x + ( sin(this->timer * 3.14 / 600.0) * (float)this->distance * 8.0);

		this->timer = this->timer + 1;

		if(this->chrAnimation.isAnimationDone())
			this->chrAnimation.setCurrentFrame(0.0);

	}
	void daShyGuy::endState_Balloon_H() { 
	}

///////////////
// Balloon V State
///////////////
	void daShyGuy::beginState_Balloon_V() { 
		bindAnimChr_and_setUpdateRate("c18_L_DMG_F_3_R", 1, 0.0, 1.0);
		this->timer = 0;
		this->initialPos = this->pos;
		this->rot.x = 0xFE00;
		this->rot.y = 0;
	}
	void daShyGuy::executeState_Balloon_V() { 
		// Makes him bob up and down
		this->pos.x = this->initialPos.x + ( sin(this->timer * 3.14 / 60.0) * 6.0 );

		// Makes him move side to side
		this->pos.y = this->initialPos.y + ( sin(this->timer * 3.14 / 600.0) * (float)this->distance * 8.0 );

		this->timer = this->timer + 1;

		if(this->chrAnimation.isAnimationDone())
			this->chrAnimation.setCurrentFrame(0.0);
	}
	void daShyGuy::endState_Balloon_V() { 
	}

///////////////
// Balloon C State
///////////////
	void daShyGuy::beginState_Balloon_C() { 
		bindAnimChr_and_setUpdateRate("c18_L_DMG_F_3_R", 1, 0.0, 1.0);
		this->timer = 0;
		this->initialPos = this->pos;
		this->rot.x = 0xFE00;
		this->rot.y = 0;
	}
	void daShyGuy::executeState_Balloon_C() { 
		// Makes him bob up and down
		this->pos.x = this->initialPos.x + ( sin(this->timer * 3.14 / 600.0) * (float)this->distance * 8.0 );

		// Makes him move side to side
		this->pos.y = this->initialPos.y + ( cos(this->timer * 3.14 / 600.0) * (float)this->distance * 8.0 );

		this->timer = this->timer + 1;

		if(this->chrAnimation.isAnimationDone())
			this->chrAnimation.setCurrentFrame(0.0);
	}
	void daShyGuy::endState_Balloon_C() { 
	}

///////////////
// Judo State
///////////////
	void daShyGuy::beginState_Judo() { 
		this->max_speed.x = 0.0;
		this->speed.x = 0.0;
		this->x_speed_inc = 0.0;
		this->pos.y -= 4.0;

		this->timer = 0;
	}
	void daShyGuy::executeState_Judo() { 

	// chargin 476? 673? 760? 768? 808? 966?
		if (this->timer == 0) { bindAnimChr_and_setUpdateRate("c18_OB_IDLE_R", 1, 0.0, 1.0); }

		this->timer = this->timer + 1;

		if (this->timer == 80) { 
			if (this->direction == 1) { 
				SpawnEffect("Wm_ob_keyget02_lighit", 0, &(Vec){this->pos.x + 7.0, this->pos.y + 14.0, this->pos.z - 5500.0}, &(S16Vec){0,0,0}, &(Vec){0.8, 0.8, 0.8});
			}
			else {
				SpawnEffect("Wm_ob_keyget02_lighit", 0, &(Vec){this->pos.x - 7.0, this->pos.y + 14.0, this->pos.z + 5500.0}, &(S16Vec){0,0,0}, &(Vec){0.8, 0.8, 0.8});
			}	
		}

		if (this->timer < 120) {
			// Always face Mario
			u8 facing = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);

			if (facing != this->direction) {
				this->direction = facing;
				if (this->direction == 1) {
					this->rot.y = 0xD800;
				}
				else {
					this->rot.y = 0x2800;
				}
			}


			if(this->chrAnimation.isAnimationDone())
				this->chrAnimation.setCurrentFrame(0.0);
		}

		else if (this->timer == 120) {
			bindAnimChr_and_setUpdateRate("c18_H_CUT_R", 1, 0.0, 1.0);
			
		}

		else if (this->timer == 132) {
			PlaySoundAsync(this, SE_EMY_CRASHER_PUNCH);

			if (this->direction == 1) { 
				SpawnEffect("Wm_mr_wallkick_b_l", 0, &(Vec){this->pos.x - 18.0, this->pos.y + 16.0, this->pos.z}, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});
				Chuckles.addToList();
			}
			else {
				SpawnEffect("Wm_mr_wallkick_s_r", 0, &(Vec){this->pos.x + 18.0, this->pos.y + 16.0, this->pos.z}, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});
				Knuckles.addToList();
			}	
		}

		else {

			if(this->chrAnimation.isAnimationDone()) {
				if (this->direction == 1) { 
					SpawnEffect("Wm_mr_wirehit_hit", 0, &(Vec){this->pos.x - 38.0, this->pos.y + 16.0, this->pos.z}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
					Chuckles.removeFromList();
				}
				else {
					SpawnEffect("Wm_mr_wirehit_hit", 0, &(Vec){this->pos.x + 38.0, this->pos.y + 16.0, this->pos.z}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
					Knuckles.removeFromList();	
				}

				this->timer = 0;
				PlaySoundAsync(this, SE_EMY_BIG_PAKKUN_DAMAGE_1);
			}
		}
	}
	void daShyGuy::endState_Judo() { 
	}

///////////////
// Spike State
///////////////
	void daShyGuy::beginState_Spike() { 
		this->timer = 80;
		spikeTurn = 0;

		this->max_speed.x = 0.0;
		this->speed.x = 0.0;
		this->x_speed_inc = 0.0;
		this->pos.y -= 4.0;
	}
	void daShyGuy::executeState_Spike() {

		if (this->timer == 0) { bindAnimChr_and_setUpdateRate("c18_OB_IDLE_R", 1, 0.0, 1.0); }

		if (this->timer < 120) {
			// Always face Mario
			u8 facing = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);

			if (facing != this->direction) {
				this->direction = facing;
				if (this->direction == 1) {
					this->rot.y = 0xD800;
				}
				else {
					this->rot.y = 0x2800;
				}
			}

			if(this->chrAnimation.isAnimationDone())
				this->chrAnimation.setCurrentFrame(0.0);
		}

		else if (this->timer == 120) {
			bindAnimChr_and_setUpdateRate("c18_H_SHOT_R", 1, 0.0, 1.0);			
		}

		else if (this->timer == 160) {
			PlaySound(this, SE_EMY_KANIBO_THROW);

			Vec pos;
			pos.x = this->pos.x;
			pos.y = this->pos.y;
			pos.z = this->pos.z;
			dStageActor_c *spawned;

			if (this->direction == 1) { 
				spawned = CreateActor(89, 0x2, pos, 0, 0);
				spawned->scale.x = 0.9;
				spawned->scale.y = 0.9;
				spawned->scale.z = 0.9;

				spawned->speed.x = -2.0;
				spawned->speed.y = 2.0;
			}
			else {
				spawned = CreateActor(89, 0x12, pos, 0, 0);
				spawned->scale.x = 0.9;
				spawned->scale.y = 0.9;
				spawned->scale.z = 0.9;

				spawned->speed.x = 2.0;
				spawned->speed.y = 2.0;
			}
		}

		else {

			if(this->chrAnimation.isAnimationDone()) {
				this->timer = 0;
				return;
			}
		}

		this->timer = this->timer + 1;

	}
	void daShyGuy::endState_Spike() { 
	}

///////////////
// Real Walk State
///////////////
bool daShyGuy::willWalkOntoSuitableGround() {
	static const float deltas[] = {2.5f, -2.5f};
	VEC3 checkWhere = {
			pos.x + deltas[direction],
			4.0f + pos.y,
			pos.z};

	u32 props = collMgr.getTileBehaviour2At(checkWhere.x, checkWhere.y, currentLayerID);

	//if (getSubType(props) == B_SUB_LEDGE)
	if (((props >> 16) & 0xFF) == 8)
		return false;

	float someFloat = 0.0f;
	if (collMgr.sub_800757B0(&checkWhere, &someFloat, currentLayerID, 1, -1)) {
		if (someFloat < checkWhere.y && someFloat > (pos.y - 5.0f))
			return true;
	}

	return false;
}


	void daShyGuy::beginState_RealWalk() {
		//inline this piece of code
		this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
		this->speed.x = (direction) ? -0.6f : 0.6f;

		this->max_speed.y = -4.0;
		this->speed.y = -4.0;
		this->y_speed_inc = -0.1875;
	}
	void daShyGuy::executeState_RealWalk() { 
		chrAnimation.setUpdateRate(1.5f);

		// if (distance) {
		// 	// What the fuck. Somehow, having this code makes the shyguy not
		// 	// fall through solid-on-top platforms...
		// 	bool turn = collMgr.isOnTopOfTile();
		// 	if (!turn) {
		// 		if (!stillFalling) {
		// 			stillFalling = true;
		// 			pos.x = direction ? pos.x + 1.5 : pos.x - 1.5;
		// 			doStateChange(&StateID_RealTurn);
		// 		}
		// 	} else 
		// }


		if (distance) {
			if (collMgr.isOnTopOfTile()) {
				stillFalling = false;

				if (!willWalkOntoSuitableGround()) {
					pos.x = direction ? pos.x + 1.5 : pos.x - 1.5;
					doStateChange(&StateID_RealTurn);
				}
			}
			else {
				if (!stillFalling) {
					stillFalling = true;
					pos.x = direction ? pos.x + 1.5 : pos.x - 1.5;
					doStateChange(&StateID_RealTurn);
				}
			}
		}

		bool ret = calculateTileCollisions();
		if (ret) {
			doStateChange(&StateID_RealTurn);
		}

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}
	}
	void daShyGuy::endState_RealWalk() { }

///////////////
// Real Turn State
///////////////
	void daShyGuy::beginState_RealTurn() {

		this->direction ^= 1;
		this->speed.x = 0.0;
	}
	void daShyGuy::executeState_RealTurn() { 

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
		int done = SmoothRotation(&this->rot.y, amt, 0x800);

		if(done) {
			this->doStateChange(&StateID_RealWalk);
		}
	}
	void daShyGuy::endState_RealTurn() {
	}

///////////////
// GoDizzy State
///////////////
	void daShyGuy::beginState_GoDizzy() {
		bindAnimChr_and_setUpdateRate("c18_L_DMG_F_1_R", 1, 0.0, 1.0); 

		// SpawnEffect("Wm_en_spindamage", 0, &(Vec){this->pos.x, this->pos.y + 24.0, 0}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});

		this->max_speed.x = 0;
		this->speed.x = 0;
		this->x_speed_inc = 0;

		this->max_speed.y = -4.0;
		this->speed.y = -4.0;
		this->y_speed_inc = -0.1875;

		this->timer = 0;
		this->jumpCounter = 0;
		this->isDown = 1;
	}
	void daShyGuy::executeState_GoDizzy() { 
		calculateTileCollisions();
	
		effect.spawn("Wm_en_spindamage", 0, &(Vec){this->pos.x, this->pos.y + 24.0, 0}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});

		if (this->jumpCounter == 0) {
			if(this->chrAnimation.isAnimationDone()) {
				this->jumpCounter = 1;
				bindAnimChr_and_setUpdateRate("c18_L_DMG_F_3_R", 1, 0.0, 1.0); 
			}
		}

		else {
			if(this->chrAnimation.isAnimationDone()) {
				this->chrAnimation.setCurrentFrame(0.0);
			}

			if (this->timer > 600) {
				doStateChange(&StateID_Recover);
				damage = 0;
			}

			this->timer += 1;
		}
	}
	void daShyGuy::endState_GoDizzy() {}

///////////////
// BalloonDrop State
///////////////
	void daShyGuy::beginState_BalloonDrop() {
		bindAnimChr_and_setUpdateRate("c18_C_BLOCK_BREAK_R", 1, 0.0, 2.0); 

		this->max_speed.x = 0.0;
		this->speed.x = 0.0;
		this->x_speed_inc = 0.0;

		this->max_speed.y = -2.0;
		this->speed.y = -2.0;
		this->y_speed_inc = -0.1875;

		this->isDown = 1;
		this->renderBalloon = 0;

		// char powerup;

		// if (baln == 1) { 
		// 	powerup		= 0x0B000007;
		// }
		// else if (baln == 2) { 
		// 	powerup		= 0x0B000009;
		// }
		// else if (baln == 3) { 
		// 	powerup		= 0x0B000001;
		// }
		// else if (baln == 4) { 
		// 	powerup		= 0x0C00000E;
		// }
		// else if (baln == 5) { 
		// 	powerup		= 0x0C000015;
		// }
		// else if (baln == 6) { 
		// 	powerup		= 0x0C000011;
		// }
		// CreateActor(60, powerup, (Vec){pos.x, pos.y - 28.0, pos.z}, 0, 0);
		// this->baln = 0;

		balloonPhysics.removeFromList();
		SpawnEffect("Wm_en_explosion_ln", 0, &(Vec){this->pos.x, this->pos.y - 32.0, 0}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		PlaySound(this, SE_PLY_BALLOON_BRAKE); 

		if (this->type != 8)
			this-distance == 0;

		type = 0;
	}
	void daShyGuy::executeState_BalloonDrop() { 

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		bool ret = calculateTileCollisions();

		if (speed.y == 0.0) { 
			SpawnEffect("Wm_en_sndlandsmk_s", 0, &(Vec){this->pos.x, this->pos.y, 0}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
			doStateChange(&StateID_GoDizzy);

			aPhysics.info.yDistToCenter = 12.0f;
			aPhysics.info.yDistToEdge = 12.0f;
		}
	}
	void daShyGuy::endState_BalloonDrop() {
	}

///////////////
// FireKnockBack State
///////////////
	void daShyGuy::beginState_FireKnockBack() {
		bindAnimChr_and_setUpdateRate("c18_C_BLOCK_BREAK_R", 1, 0.0, 1.0); 

		// Backfire 0 == Fireball to the right
		// Backfire 1 == Fireball to the left

		directionStore = this->direction;
		speed.x = (this->backFire) ? this->XSpeed : -this->XSpeed;
		speed.x *= 1.2f;
		max_speed.x = speed.x;
		x_speed_inc = 0.0f;
	}
	void daShyGuy::executeState_FireKnockBack() { 

		calculateTileCollisions();
		// move backwards here
		this->speed.x = this->speed.x / 1.02f;

		if(this->chrAnimation.isAnimationDone()) {
			if (aPhysics.result1 == 0 && aPhysics.result2 == 0 && aPhysics.result3 == 0) {
				bindAnimChr_and_setUpdateRate("c18_EV_WIN_2_R", 1, 0.0, 1.5); 
				doStateChange(&StateID_RealWalk);
			}
		}
	}
	void daShyGuy::endState_FireKnockBack() {
		this->direction = directionStore;		
	}

///////////////
// FlameHit State
///////////////
	void daShyGuy::beginState_FlameHit() {
		bindAnimChr_and_setUpdateRate("c18_C_BLOCK_BREAK_R", 1, 0.0, 1.0); 
	}
	void daShyGuy::executeState_FlameHit() { 

		if(this->chrAnimation.isAnimationDone()) {
			if (type == 6) {
				doStateChange(&StateID_Balloon_H);
			}		
			else if (type == 7) {
				doStateChange(&StateID_Balloon_V);
			}		
			else if (type == 8) {
				doStateChange(&StateID_Balloon_C);
			}		
		}
	}
	void daShyGuy::endState_FlameHit() {}

///////////////
// Recover State
///////////////
	void daShyGuy::beginState_Recover() {
		bindAnimChr_and_setUpdateRate("c18_L_DMG_F_4_R", 1, 0.0, 1.0); 
	}
	void daShyGuy::executeState_Recover() { 

		calculateTileCollisions();

		if(this->chrAnimation.isAnimationDone()) {
			if (type == 3) {
				doStateChange(&StateID_Jump);
			}		
			else {
				bindAnimChr_and_setUpdateRate("c18_EV_WIN_2_R", 1, 0.0, 1.5); 
				doStateChange(&StateID_RealWalk);
			}
		}
	}
	void daShyGuy::endState_Recover() {
		this->isDown = 0;		
		this->rot.y = (direction) ? 0xD800 : 0x2800;
	}

///////////////
// Die State
///////////////
	void daShyGuy::beginState_Die() {
		// dEn_c::dieFall_Begin();
		this->removeMyActivePhysics();

		bindAnimChr_and_setUpdateRate("c18_C_BLOCK_BREAK_R", 1, 0.0, 2.0); 
		this->timer = 0;
		this->dying = -10.0;
		this->Baseline = this->pos.y;
		this->rot.y = 0;
		this->rot.x = 0;

		if (type > 5 && type < 9) {
			this->renderBalloon = 0;
			SpawnEffect("Wm_en_explosion_ln", 0, &(Vec){this->pos.x, this->pos.y - 32.0, 0}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		}
	}
	void daShyGuy::executeState_Die() { 

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		this->timer += 1;
		 		
		// this->pos.x += 0.5; 
		this->pos.y = Baseline + (-0.2 * dying * dying) + 20.0;
		
		this->dying += 0.5;
			
		if (this->timer > 450) {
			OSReport("Killing");
			this->kill();
			this->Delete(this->deleteForever);
		}

		// dEn_c::dieFall_Execute();

	}
	void daShyGuy::endState_Die() {
	}


//
// processed\../src/shyguyGiants.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include <profile.h>

extern void shyCollisionCallback(ActivePhysics *apThis, ActivePhysics *apOther);
const char* SGGarcNameList [] = {
	"shyguy",
	NULL	
};

// Shy Guy Settings
// 
// Nybble 5: Size
//		0 - Big 	
//		1 - Mega
//		2 - Giga
// 
// Nybble 6: Colour
//		0 - Red 
//		1 - Blue
//		2 - Green
//		3 - Cyan
//		4 - Magenta
//


class daShyGuyGiant : public dEn_c {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile anmFile;

	m3d::mdl_c bodyModel;
	m3d::anmChr_c chrAnimation;
	mEf::es2 effect;

	int timer;
	int type;
	float dying;
	float Baseline;
	char damage;
	char isDown;
	Vec initialPos;
	int distance;
	float XSpeed;
	u32 cmgr_returnValue;
	bool isBouncing;
	int directionStore;

	public: static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();
	bool calculateTileCollisions();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);

	void powBlockActivated(bool isNotMPGP);

	void _vf148();
	void _vf14C();
	bool CreateIceActors();
	void addScoreWhenHit(void *other);
	void bouncePlayerWhenJumpedOn(void *player);

	void spawnHitEffectAtPosition(Vec2 pos);
	void doSomethingWithHardHitAndSoftHitEffects(Vec pos);
	void playEnemyDownSound2();
	void playHpdpSound1(); // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
	void playEnemyDownSound1();
	void playEnemyDownComboSound(void *player); // AcPy_c/daPlBase_c?
	void playHpdpSound2(); // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
	void _vf260(void *other); // AcPy/PlBase? plays the SE_EMY_FUMU_%d sounds based on some value
	void _vf264(dStageActor_c *other); // if other is player or yoshi, do Wm_en_hit and a few other things
	void _vf268(void *other); // AcPy/PlBase? plays the SE_EMY_DOWN_SPIN_%d sounds based on some value
	void _vf278(void *other); // AcPy/PlBase? plays the SE_EMY_YOSHI_FUMU_%d sounds based on some value

	USING_STATES(daShyGuyGiant);
	DECLARE_STATE(RealWalk);
	DECLARE_STATE(RealTurn);
	DECLARE_STATE(Die);
};

const SpriteData ShyGuyGiantSpriteData = {ProfileId::ShyGuyGiant, 0x5, -0x31, 0, 0x10, 0x10, 0x40, 0x40, 0x40, 0, 0, 0};
// #      -ID- ----  -X Offs- -Y Offs-  -RectX1- -RectY1- -RectX2- -RectY2-  -1C- -1E- -20- -22-  Flag ----
Profile ShyGuyGiantsProfile(&daShyGuyGiant::build, SpriteId::ShyGuyGiant, ShyGuyGiantSpriteData, ProfileId::WM_TREASURESHIP, ProfileId::ShyGuyGiant, "ShyGuyGiant", SGGarcNameList);

dActor_c *daShyGuyGiant::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daShyGuyGiant));
	OSReport("Building Shy Guy");
	return new(buffer) daShyGuyGiant;
}

///////////////////////
// Externs and States
///////////////////////
	extern "C" bool SpawnEffect(const char*, int, Vec*, S16Vec*, Vec*);

	//FIXME make this dEn_c->used...
	extern "C" char usedForDeterminingStatePress_or_playerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther, int unk1);
	extern "C" int SomeStrangeModification(dStageActor_c* actor);
	extern "C" void DoStuffAndMarkDead(dStageActor_c *actor, Vec vector, float unk);
	extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);

	// Collision related
	extern "C" void BigHanaPlayer(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
	extern "C" void BigHanaYoshi(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
	extern "C" bool BigHanaWeirdGP(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
	extern "C" bool BigHanaGroundPound(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
	extern "C" bool BigHanaFireball(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
	extern "C" bool BigHanaIceball(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);

	extern "C" void dAcPy_vf3F8(void* player, dEn_c* monster, int t);

	CREATE_STATE(daShyGuyGiant, RealWalk);
	CREATE_STATE(daShyGuyGiant, RealTurn);
	CREATE_STATE(daShyGuyGiant, Die);

////////////////////////
// Collision Functions
////////////////////////

	void daShyGuyGiant::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) { 
		apOther->someFlagByte |= 2;

		dStageActor_c *player = apOther->owner;

		char hitType;
		hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);
		if (hitType > 0) {
			PlaySound(this, SE_EMY_CMN_STEP);
			this->counter_504[apOther->owner->which_player] = 0xA;
		} else {
			this->dEn_c::playerCollision(apThis, apOther);
			this->_vf220(apOther->owner);
			if (Player_VF3D4(player)) {
				// WE'VE GOT A STAR, FOLKS
				if (apThis->_18 == 1 && !player->collMgr.isOnTopOfTile() && player->pos.y > apThis->bottom()) {
					bouncePlayer(player, 3.0f);
					PlaySound(this, SE_EMY_CMN_STEP);
				} else {
					dAcPy_vf3F8(player, this, 3);
				}
				this->counter_504[apOther->owner->which_player] = 0xA;

			}
		} 
	}			
	void daShyGuyGiant::_vf278(void *other) {
		PlaySound(this, SE_EMY_HANACHAN_STOMP);
}

	void daShyGuyGiant::bouncePlayerWhenJumpedOn(void *player) {
		bouncePlayer(player, 5.0f);
	}

	void daShyGuyGiant::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->playerCollision(apThis, apOther);
	}
	bool daShyGuyGiant::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
		return BigHanaWeirdGP(this, apThis, apOther);
	}
	bool daShyGuyGiant::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
		return BigHanaGroundPound(this, apThis, apOther);
	}
	bool daShyGuyGiant::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
		return BigHanaGroundPound(this, apThis, apOther);
	}

	bool daShyGuyGiant::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
		apOther->owner->kill();
		return true;
	}
	bool daShyGuyGiant::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){
		dAcPy_vf3F8(apOther->owner, this, 3);
		this->counter_504[apOther->owner->which_player] = 0xA;
		return true;
	}
	bool daShyGuyGiant::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther){
		return true;
	}
	bool daShyGuyGiant::collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther){
		return true;
	}
	bool daShyGuyGiant::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
		return true;
	}
	bool daShyGuyGiant::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){
		/*int hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);
		if (hitType == 1 || hitType == 3) {
			PlaySound(this, SE_EMY_CMN_STEP);
			bouncePlayerWhenJumpedOn(apOther->owner);
		} else {
			dAcPy_vf3F8(apOther->owner, this, 3);
		}

		this->counter_504[apOther->owner->which_player] = 0xA;
		return true;*/
		return false;
	}

	bool daShyGuyGiant::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){
		return BigHanaFireball(this, apThis, apOther);
	}
	bool daShyGuyGiant::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
		return BigHanaFireball(this, apThis, apOther);
	}
	bool daShyGuyGiant::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {
		return BigHanaIceball(this, apThis, apOther);
	}

	// These handle the ice crap
	void daShyGuyGiant::_vf148() {
		dEn_c::_vf148();
		doStateChange(&StateID_Die);
	}
	void daShyGuyGiant::_vf14C() {
		dEn_c::_vf14C();
		doStateChange(&StateID_Die);
	}

	extern "C" void sub_80024C20(void);
	extern "C" void __destroy_arr(void*, void(*)(void), int, int);

	bool daShyGuyGiant::CreateIceActors() {
		struct DoSomethingCool my_struct = { 0, this->pos, {2.4, 3.0, 3.0}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
		if (type == 1) { my_struct.scale = (Vec3){4.8, 6.0, 6.0}; }
		if (type == 2) { my_struct.scale = (Vec3){7.2, 9.0, 9.0}; }
	    this->frzMgr.Create_ICEACTORs( (void*)&my_struct, 1 );
	    __destroy_arr( (void*)&my_struct, sub_80024C20, 0x3C, 1 );
	    return true;
	}

	void daShyGuyGiant::addScoreWhenHit(void *other) { }

	void daShyGuyGiant::spawnHitEffectAtPosition(Vec2 pos) { }
	void daShyGuyGiant::doSomethingWithHardHitAndSoftHitEffects(Vec pos) { }
	void daShyGuyGiant::playEnemyDownSound2() { }
	void daShyGuyGiant::playHpdpSound1() { } // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
	void daShyGuyGiant::playEnemyDownSound1() { }
	void daShyGuyGiant::playEnemyDownComboSound(void *player) { } // AcPy_c/daPlBase_c?
	void daShyGuyGiant::playHpdpSound2() { } // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
	void daShyGuyGiant::_vf260(void *other) { } // AcPy/PlBase? plays the SE_EMY_FUMU_%d sounds based on some value
	void daShyGuyGiant::_vf264(dStageActor_c *other) { } // if other is player or yoshi, do Wm_en_hit and a few other things
	void daShyGuyGiant::_vf268(void *other) { } // AcPy/PlBase? plays the SE_EMY_DOWN_SPIN_%d sounds based on some value

	void daShyGuyGiant::powBlockActivated(bool isNotMPGP) {
	}

bool daShyGuyGiant::calculateTileCollisions() {
	// Returns true if sprite should turn, false if not.

	HandleXSpeed();
	HandleYSpeed();
	doSpriteMovement();

	cmgr_returnValue = collMgr.isOnTopOfTile();
	collMgr.calculateBelowCollisionWithSmokeEffect();

	if (isBouncing) {
		stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);
		if (speed.y != 0.0f)
			isBouncing = false;
	}

	float xDelta = pos.x - last_pos.x;
	if (xDelta >= 0.0f)
		direction = 0;
	else
		direction = 1;

	if (collMgr.isOnTopOfTile()) {
		// Walking into a tile branch

		if (cmgr_returnValue == 0)
			isBouncing = true;

		if (speed.x != 0.0f) {
			//playWmEnIronEffect();
		}

		speed.y = 0.0f;

		// u32 blah = collMgr.s_80070760();
		// u8 one = (blah & 0xFF);
		// static const float incs[5] = {0.00390625f, 0.0078125f, 0.015625f, 0.0234375f, 0.03125f};
		// x_speed_inc = incs[one];
		max_speed.x = (direction == 1) ? -this->XSpeed : this->XSpeed;
	} else {
		x_speed_inc = 0.0f;
	}

	// Bouncing checks
	if (_34A & 4) {
		Vec v = (Vec){0.0f, 1.0f, 0.0f};
		collMgr.pSpeed = &v;

		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;

		collMgr.pSpeed = &speed;

	} else {
		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;
	}

	collMgr.calculateAdjacentCollision(0);

	// Switch Direction
	if (collMgr.outputMaybe & (0x15 << direction)) {
		if (collMgr.isOnTopOfTile()) {
			isBouncing = true;
		}
		return true;
	}
	return false;
}

void daShyGuyGiant::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->anmFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daShyGuyGiant::onCreate() {
	OSReport("Spawning Shy Guy");
	this->type = (this->settings >> 28) & 0xF;

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	u32 colour = (this->settings >> 24) & 0xF;

	// Shy Guy Colours
	if (colour == 1) {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyBlue.brres");
	}
	else if (colour == 2) {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyGreen.brres");
	}
	else if (colour == 3) {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyCyan.brres");
	}
	else if (colour == 4) {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyPurple.brres");
	}
	else {
		this->resFile.data = getResource("shyguy", "g3d/ShyGuyRed.brres");
	}
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("body_h");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);


	// Animations start here
	this->anmFile.data = getResource("shyguy", "g3d/ShyGuyAnimations.brres");
	nw4r::g3d::ResAnmChr anmChr = this->anmFile.GetResAnmChr("c18_IDLE_R");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	// Stuff I do understand

	this->pos.y += 32.0;
	this->rot.x = 0; // X is vertical axis
	this->rot.y = 0xD800; // Y is horizontal axis
	this->rot.z = 0; // Z is ... an axis >.>
	this->direction = 1; // Heading left.
	
	this->speed.x = 0.0;
	this->speed.y = 0.0;
	this->Baseline = this->pos.y;

	ActivePhysics::Info HitMeBaby;
	float anmSpeed;

	if (type == 0) {
		this->scale = (Vec){40.0f, 40.0f, 40.0f};

		HitMeBaby.xDistToCenter = 0.0;
		HitMeBaby.yDistToCenter = 20.0;

		HitMeBaby.xDistToEdge = 14.0;
		HitMeBaby.yDistToEdge = 20.0;

		this->XSpeed = 0.4;
		anmSpeed = 1.0;

		static const lineSensor_s below(12<<12, 4<<12, 0<<12);
		static const lineSensor_s adjacent(14<<12, 9<<12, 14<<12);
		collMgr.init(this, &below, 0, &adjacent);
	}
	else if (type == 1) {
		this->scale = (Vec){80.0f, 80.0f, 80.0f};

		HitMeBaby.xDistToCenter = 0.0;
		HitMeBaby.yDistToCenter = 40.0;

		HitMeBaby.xDistToEdge = 28.0;
		HitMeBaby.yDistToEdge = 40.0;

		this->XSpeed = 0.4;
		anmSpeed = 0.5;

		static const lineSensor_s below(12<<12, 4<<12, 0<<12);
		static const lineSensor_s adjacent(28<<12, 9<<12, 28<<12);
		collMgr.init(this, &below, 0, &adjacent);
	}
	else {
		this->scale = (Vec){120.0f, 120.0f, 120.0f};

		HitMeBaby.xDistToCenter = 0.0;
		HitMeBaby.yDistToCenter = 60.0;

		HitMeBaby.xDistToEdge = 42.0;
		HitMeBaby.yDistToEdge = 60.0;

		this->XSpeed = 0.4;
		anmSpeed = 0.25;	

		static const lineSensor_s below(12<<12, 4<<12, 0<<12);
		static const lineSensor_s adjacent(42<<12, 9<<12, 42<<12);
		collMgr.init(this, &below, 0, &adjacent);
	}

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x9;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0xffba7ffe;
	HitMeBaby.unkShort1C = 0x20000;
	HitMeBaby.callback = &shyCollisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	collMgr.calculateBelowCollisionWithSmokeEffect();

	cmgr_returnValue = collMgr.isOnTopOfTile();

	if (collMgr.isOnTopOfTile())
		isBouncing = false;
	else
		isBouncing = true;

	// State Changer
	bindAnimChr_and_setUpdateRate("c18_EV_WIN_2_R", 1, 0.0, anmSpeed); 
	doStateChange(&StateID_RealWalk);

	this->onExecute();
	return true;
}

int daShyGuyGiant::onDelete() {
	return true;
}

int daShyGuyGiant::onExecute() {
	acState.execute();
	updateModelMatrices();

	return true;
}

int daShyGuyGiant::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}

void daShyGuyGiant::updateModelMatrices() {
	float yoff;

	if (type == 0) 		{ yoff = -5.0; }
	else if (type == 1) { yoff = -10.0; }
	else 				{ yoff = -15.0; }

	matrix.translation(pos.x, pos.y + yoff, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


///////////////
// Real Walk State
///////////////
	void daShyGuyGiant::beginState_RealWalk() {
		//inline this piece of code
		this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
		this->speed.x = (direction) ? -this->XSpeed : this->XSpeed;

		this->max_speed.y = -4.0;
		this->speed.y = -4.0;
		this->y_speed_inc = -0.1875;
	}
	void daShyGuyGiant::executeState_RealWalk() { 
		bodyModel._vf1C();

		bool ret = calculateTileCollisions();
		if (ret) {
			doStateChange(&StateID_RealTurn);
		}

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}
	}
	void daShyGuyGiant::endState_RealWalk() { }

///////////////
// Real Turn State
///////////////
	void daShyGuyGiant::beginState_RealTurn() {

		this->direction ^= 1;
		this->speed.x = 0.0;
	}
	void daShyGuyGiant::executeState_RealTurn() { 
		bodyModel._vf1C();

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
		int done = SmoothRotation(&this->rot.y, amt, 0x800);

		if(done) {
			this->doStateChange(&StateID_RealWalk);
		}
	}
	void daShyGuyGiant::endState_RealTurn() {
	}

///////////////
// Die State
///////////////
	void daShyGuyGiant::beginState_Die() {
		// dEn_c::dieFall_Begin();
		this->removeMyActivePhysics();

		bindAnimChr_and_setUpdateRate("c18_C_BLOCK_BREAK_R", 1, 0.0, 2.0); 
		this->timer = 0;
		this->dying = -10.0;
		this->Baseline = this->pos.y;
		this->rot.y = 0;
		this->rot.x = 0;
	}
	void daShyGuyGiant::executeState_Die() { 
		bodyModel._vf1C();

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}

		this->timer += 1;
		 		
		// this->pos.x += 0.5; 
		this->pos.y = Baseline + (-0.2 * dying * dying) + 20.0;
		
		this->dying += 0.5;
			
		if (this->timer > 450) {
			this->kill();
			this->Delete(this->deleteForever);
		}

		// dEn_c::dieFall_Execute();

	}
	void daShyGuyGiant::endState_Die() {
	}


//
// processed\../src/meteor.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include "boss.h"

class dMeteor : public dEn_c {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	static dMeteor *build();

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	nw4r::g3d::ResFile resFile;
	mEf::es2 effect;

	int timer;
	int spinSpeed;
	char spinDir;
	char isElectric;

	Physics MakeItRound;

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);

	public:
		void kill();
};

dMeteor *dMeteor::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dMeteor));
	return new(buffer) dMeteor;
}

const char* MEarcNameList [] = {
	"kazan_rock",
	NULL	
};

// extern "C" dStageActor_c *GetSpecificPlayerActor(int num);
// extern "C" void *modifyPlayerPropertiesWithRollingObject(dStageActor_c *Player, float _52C);


void dMeteor::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) { 
	DamagePlayer(this, apThis, apOther);
}

void MeteorPhysicsCallback(dMeteor *self, dEn_c *other) {
	if (other->name == 657) {
		OSReport("CANNON COLLISION");

		SpawnEffect("Wm_en_explosion", 0, &other->pos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		SpawnEffect("Wm_en_explosion_smk", 0, &other->pos, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});
		PlaySound(other, SE_OBJ_TARU_BREAK);
		other->Delete(1);

		switch ((self->settings >> 24) & 3) {
			case 1:
				dStageActor_c::create(EN_HATENA_BALLOON, 0x100, &self->pos, 0, self->currentLayerID);
				break;
			case 2:
				VEC3 coinPos = {self->pos.x - 16.0f, self->pos.y, self->pos.z};
				dStageActor_c::create(EN_COIN, 9, &coinPos, 0, self->currentLayerID);
				break;
		}

		self->kill();
	}
}

bool dMeteor::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) { 
	DamagePlayer(this, apThis, apOther);
	return true;
}


int dMeteor::onCreate() {

	// Setup Model
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("kazan_rock", "g3d/kazan_rock.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("kazan_rock");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);

	allocator.unlink();


	// Retrieve Scale and set it up
	float sca = (float)((this->settings >> 8) & 0xFF);
	sca = (sca/5.0) + 0.2;

	this->scale = (Vec){sca,sca,sca};

	// Other settings
	this->spinDir = this->settings & 0x1;
	this->spinSpeed = ((this->settings >> 16) & 0xFF) * 20;
	this->isElectric = (this->settings >> 4) & 0x1;


	// Setup Physics
	if (isElectric) {
		ActivePhysics::Info elec;
		elec.xDistToCenter = 0.0;
		elec.yDistToCenter = 0.0;

		elec.xDistToEdge = 13.0 * sca;
		elec.yDistToEdge = 13.0 * sca;

		elec.category1 = 0x3;
		elec.category2 = 0x0;
		elec.bitfield1 = 0x4F;
		elec.bitfield2 = 0x200;
		elec.unkShort1C = 0;
		elec.callback = &dEn_c::collisionCallback;

		this->aPhysics.initWithStruct(this, &elec);
		this->aPhysics.addToList();	
	}

	MakeItRound.baseSetup(this, &MeteorPhysicsCallback, &MeteorPhysicsCallback, &MeteorPhysicsCallback, 1, 0);

	MakeItRound.x = 0.0;
	MakeItRound.y = 0.0;

	MakeItRound.diameter = 13.0 * sca;
	MakeItRound.isRound = 1;

	MakeItRound.update();

	MakeItRound.addToList();

	this->pos.z = (settings & 0x1000000) ? -2000.0f : 3458.0f;
		
	this->onExecute();
	return true;
}

int dMeteor::onDelete() {
	return true;
}

int dMeteor::onExecute() {

	if (spinDir == 0) 	{ rot.z -= spinSpeed; }
	else 				{ rot.z += spinSpeed; }

	MakeItRound.update();
	updateModelMatrices();

	if (isElectric) {
		effect.spawn("Wm_en_birikyu_biri", 0, &(Vec){pos.x, pos.y, pos.z+500.0}, &rot, &(Vec){scale.x*0.8, scale.y*0.8, scale.z*0.8});
		PlaySound(this, SE_EMY_BIRIKYU_SPARK);
	}

	// for (i=0; i<4; i++) {
	// 	dStageActor_c *player = GetSpecificPlayerActor(i);
	// 	modifyPlayerPropertiesWithRollingObject(player, );
	// }

	return true;
}

int dMeteor::onDraw() {

	bodyModel.scheduleForDrawing();
	bodyModel._vf1C();
	return true;
}

void dMeteor::updateModelMatrices() {
	// This won't work with wrap because I'm lazy.
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

void dMeteor::kill() {
	PlaySound(this, SE_OBJ_ROCK_LAND);
	SpawnEffect("Wm_ob_cmnboxsmoke", 0, &pos, &rot, &scale);
	SpawnEffect("Wm_ob_cmnboxgrain", 0, &pos, &rot, &scale);

	this->Delete(1);
}



//
// processed\../src/electricLine.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include <profile.h>

class daElectricLine : public dEn_c {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;

	dEn_c *Needles;
	u32 delay;
	u32 timer;
	char loops;

	public: static dActor_c *build();

	USING_STATES(daElectricLine);
	DECLARE_STATE(Activate);
	DECLARE_STATE(Deactivate);
	DECLARE_STATE(Die);
};

const char *ElectricLineFileList[] = {0};
const SpriteData ElectricLineSpriteData = { ProfileId::ElectricLine, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile ElectricLineProfile(&daElectricLine::build, SpriteId::ElectricLine, ElectricLineSpriteData, ProfileId::KAWANAGARE, ProfileId::ElectricLine, "ElectricLine", ElectricLineFileList);

dActor_c *daElectricLine::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daElectricLine));
	return new(buffer) daElectricLine;
}

///////////////////////
// Externs and States
///////////////////////


	CREATE_STATE(daElectricLine, Activate);
	CREATE_STATE(daElectricLine, Deactivate);
	CREATE_STATE(daElectricLine, Die);



int daElectricLine::onCreate() {

	Vec temppos = this->pos;
	temppos.x += 24.0;

	// Settings for rotation: 0 = facing right, 1 = facing left, 2 = facing up, 3 = facing down
	char settings = 0;
	if (this->settings & 0x1) {
		settings = 1;
		temppos.x -= 32.0;
	}


	Needles = (daNeedles*)create(NEEDLE_FOR_KOOPA_JR_B, settings, &temppos, &this->rot, 0);
	Needles->doStateChange(&daNeedles::StateID_DemoWait);
	
	// Needles->aPhysics.info.category1 = 0x3;
	// Needles->aPhysics.info.bitfield1 = 0x4F;
	// Needles->aPhysics.info.bitfield2 = 0xffbafffe;

	// Delay in 1/6ths of a second
	this->delay = (this->settings >> 16) * 10;
	this->loops = (this->settings >> 4);

	// State Changers
	doStateChange(&StateID_Activate);

	this->onExecute();
	return true;
}

int daElectricLine::onDelete() {
	return true;
}

int daElectricLine::onExecute() {
	acState.execute();
	return true;
}

int daElectricLine::onDraw() {
	return true;
}


// States:
//
// DemoWait - all nullsubs, does nothing
// DemoAwake - moves the spikes in their respective directions
// Idle - Fires off an infinity of effects for some reason.
// Die - removes physics, then nullsubs


///////////////
// Activate State
///////////////
	void daElectricLine::beginState_Activate() { 
		this->timer = this->delay;
		Needles->doStateChange(&daNeedles::StateID_Idle);
	}
	void daElectricLine::executeState_Activate() { 
		if (this->loops) {
			this->timer--;
			if (this->timer == 0) {
				this->loops += 1;
				doStateChange(&StateID_Deactivate);
			}
		}
	}
	void daElectricLine::endState_Activate() { }

///////////////
// Deactivate State
///////////////
	void daElectricLine::beginState_Deactivate() { 
		this->timer = this->delay; 
		Needles->removeMyActivePhysics();
		Needles->doStateChange(&daNeedles::StateID_DemoWait);
	}
	void daElectricLine::executeState_Deactivate() { 

		this->timer--;
		if (this->timer == 0) {
			doStateChange(&StateID_Activate);
		}
	}
	void daElectricLine::endState_Deactivate() { 
		Needles->addMyActivePhysics();
	}


///////////////
// Die State
///////////////
	void daElectricLine::beginState_Die() { Needles->doStateChange(&daNeedles::StateID_Die); }
	void daElectricLine::executeState_Die() { }
	void daElectricLine::endState_Die() { }


//
// processed\../src/thundercloud.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>

#include "boss.h"

const char* TLCarcNameList [] = {
	"tcloud",
	NULL	
};

class dThunderCloud : public dEn_c {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	nw4r::g3d::ResFile resFile;
	m3d::anmChr_c anm;

	mEf::es2 bolt;
	mEf::es2 charge;

	float Baseline;
	u32 timer;
	int dying;
	char killFlag;
	bool stationary;
	float leader;
	pointSensor_s below;

	bool usingEvents;
	u64 eventFlag;

	ActivePhysics Lightning;

	void dieFall_Begin();
	void dieFall_Execute();
	static dThunderCloud *build();

	void updateModelMatrices();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	void powBlockActivated(bool isNotMPGP);

	void _vf148();
	void _vf14C();
	bool CreateIceActors();

	void lightningStrike();

	USING_STATES(dThunderCloud);
	DECLARE_STATE(Follow);
	DECLARE_STATE(Lightning);
	DECLARE_STATE(Wait);
};

dThunderCloud *dThunderCloud::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dThunderCloud));
	return new(buffer) dThunderCloud;
}


CREATE_STATE(dThunderCloud, Follow);
CREATE_STATE(dThunderCloud, Lightning);
CREATE_STATE(dThunderCloud, Wait);

void dThunderCloud::powBlockActivated(bool isNotMPGP) { }


// Collision Callbacks
	extern "C" void dAcPy_vf3F4(void* mario, void* other, int t);
	extern "C" bool BigHanaFireball(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
	extern "C" void *dAcPy_c__ChangePowerupWithAnimation(void * Player, int powerup);
	extern "C" int CheckExistingPowerup(void * Player);

	void dThunderCloud::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) { 

		if (this->counter_504[apOther->owner->which_player]) {
			if (apThis->info.category2 == 0x9) {
				int p = CheckExistingPowerup(apOther->owner);
				if (p != 3) {	// Powerups - 0 = small; 1 = big; 2 = fire; 3 = mini; 4 = prop; 5 = peng; 6 = ice; 7 = hammer
					dAcPy_c__ChangePowerupWithAnimation(apOther->owner, 3);
				}
				else { dAcPy_vf3F4(apOther->owner, this, 9); }
			}

			else { dAcPy_vf3F4(apOther->owner, this, 9); }
		}

		this->counter_504[apOther->owner->which_player] = 0x20;
	}

	void dThunderCloud::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) { this->playerCollision(apThis, apOther); }
	bool dThunderCloud::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) { this->playerCollision(apThis, apOther); return true; }
	bool dThunderCloud::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) { this->playerCollision(apThis, apOther); return true; }
	bool dThunderCloud::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) { this->playerCollision(apThis, apOther); return true; }
	bool dThunderCloud::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther) { this->playerCollision(apThis, apOther); return true; }
	bool dThunderCloud::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther) { this->playerCollision(apThis, apOther); return true; }
	bool dThunderCloud::collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther) { this->playerCollision(apThis, apOther); return true; }

	bool dThunderCloud::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) { return BigHanaFireball(this, apThis, apOther); }
	bool dThunderCloud::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther) { return BigHanaFireball(this, apThis, apOther); }

	bool dThunderCloud::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) { 
		if (apThis->info.category2 == 0x9) { return true; }
		PlaySound(this, SE_EMY_DOWN);
		doStateChange(&StateID_DieFall);
		return true;
	}
	bool dThunderCloud::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->collisionCat13_Hammer(apThis, apOther);
		return true;
	}
	bool dThunderCloud::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther) { 
		if (apThis->info.category2 == 0x9) { return true; }
		dEn_c::collisionCat3_StarPower(apThis, apOther);
		this->collisionCat13_Hammer(apThis, apOther);
		return true;
	}


	// These handle the ice crap
	void dThunderCloud::_vf148() {
		dEn_c::_vf148();
		doStateChange(&StateID_DieFall);
	}
	void dThunderCloud::_vf14C() {
		dEn_c::_vf14C();
		doStateChange(&StateID_DieFall);
	}

	extern "C" void sub_80024C20(void);
	extern "C" void __destroy_arr(void*, void(*)(void), int, int);
	//extern "C" __destroy_arr(struct DoSomethingCool, void(*)(void), int cnt, int bar);

	bool dThunderCloud::CreateIceActors() {
		this->Lightning.removeFromList();

		struct DoSomethingCool my_struct = { 0, (Vec){pos.x, pos.y - 16.0, pos.z}, {1.75, 1.4, 1.5}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	    this->frzMgr.Create_ICEACTORs( (void*)&my_struct, 1 );
	    __destroy_arr( (void*)&my_struct, sub_80024C20, 0x3C, 1 );
	    return true;
	}


void dThunderCloud::dieFall_Begin() {
	this->Lightning.removeFromList();
	this->timer = 0; 
	this->dEn_c::dieFall_Begin();
}
void dThunderCloud::dieFall_Execute() {	
	if (this->killFlag == 1) { return; }

	this->timer = this->timer + 1;
	 
	this->dying = this->dying + 0.15;
	
	this->pos.x = this->pos.x + 0.15;
	this->pos.y = this->pos.y - ((-0.2 * (this->dying*this->dying)) + 5);
	
	this->dEn_c::dieFall_Execute();
		
	if (this->timer > 450) {
		
		if (((this->settings >> 28) > 0) || (stationary)) { 		
			this->Delete(1);
			this->killFlag = 1;
			return;
		}
		
		dStageActor_c *Player = GetSpecificPlayerActor(0);
		if (Player == 0) { Player = GetSpecificPlayerActor(1); }
		if (Player == 0) { Player = GetSpecificPlayerActor(2); }
		if (Player == 0) { Player = GetSpecificPlayerActor(3); }
		

		if (Player == 0) { 
			this->pos.x = 0;
		} else {
			this->pos.x = Player->pos.x - 300;
		}
				
		this->pos.y = this->Baseline; 

		SpawnEffect("Wm_en_blockcloud", 0, &pos, &(const S16Vec){0,0,0}, &(const Vec){1.0f,1.0f,1.0f});
		
		scale.x = scale.y = scale.z = 0.0f;
		this->aPhysics.addToList();
		doStateChange(&StateID_Follow);
	}
}


void dThunderCloud::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->anm.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->anm, unk2);
	this->anm.setUpdateRate(rate);
}

int dThunderCloud::onCreate() {

	// Setup the model
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("tcloud", "g3d/tcloud.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("cloud");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);

	bool ret;
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("cloud_wait");
	ret = this->anm.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();



	scale = (Vec){1.2f, 1.2f, 1.2f};

	// Scale and Physics
	ActivePhysics::Info Cloud;
	Cloud.xDistToCenter = 0.0;
	Cloud.yDistToCenter = 0.0;
	Cloud.category1 = 0x3;
	Cloud.category2 = 0x0;
	Cloud.bitfield1 = 0x4F;

	Cloud.bitfield2 = 0xffba7ffe; 
	Cloud.xDistToEdge = 18.0f * scale.x;
	Cloud.yDistToEdge = 12.0f * scale.y;

	Cloud.unkShort1C = 0;
	Cloud.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &Cloud);
	this->aPhysics.addToList();

	below.x = 0;
	below.y = 0;
	collMgr.init(this, &below, 0, 0);

	// Some Settings
	this->Baseline = this->pos.y;
	this->dying = -5;
	this->killFlag = 0;
	this->pos.z = 5750.0f; // sun

	stationary 		= this->settings & 0xF;
	
	char eventNum	= (this->settings >> 16) & 0xFF;
	usingEvents = (stationary != 0) && (eventNum != 0);

	this->eventFlag = (u64)1 << (eventNum - 1);


	// State Change!
	if (stationary) { doStateChange(&StateID_Wait); }
	else 			{ doStateChange(&StateID_Follow); }

	this->onExecute();
	return true;
}

int dThunderCloud::onDelete() {
	return true;
}

int dThunderCloud::onExecute() {
	if (scale.x < 1.0f)
		scale.x = scale.y = scale.z = scale.x + 0.0375f;
	else
		scale.x = scale.y = scale.z = 1.0f;

	acState.execute();
	updateModelMatrices();
	bodyModel._vf1C();

	if ((dFlagMgr_c::instance->flags & this->eventFlag) && (!stationary)) {
		if (this->killFlag == 0 && acState.getCurrentState()->isNotEqual(&StateID_DieFall)) {
			this->kill();
			this->pos.y = this->pos.y + 800.0; 
			this->killFlag = 1;
			doStateChange(&StateID_DieFall);
		}
	}
		
	return true;
}

int dThunderCloud::onDraw() {
	bodyModel.scheduleForDrawing();

	return true;
}


void dThunderCloud::updateModelMatrices() {
	// This won't work with wrap because I'm lazy.
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


// Follow State

void dThunderCloud::beginState_Follow() { 
	this->timer = 0;
	this->bindAnimChr_and_setUpdateRate("cloud_wait", 1, 0.0, 1.0);
	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;
	PlaySound(this, SE_AMB_THUNDER_CLOUD);
}
void dThunderCloud::executeState_Follow() {

	charge.spawn("Wm_mr_electricshock_biri02_s", 0, &pos, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});

	if(this->anm.isAnimationDone()) {
		this->anm.setCurrentFrame(0.0); }

	if (this->timer > 200) { this->doStateChange(&StateID_Lightning); }

	this->direction = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
	
	float speedDelta;
	speedDelta = 0.05;

	if (this->direction == 0) { // Going Left
		this->speed.x = this->speed.x + speedDelta; // 
		
		if (this->speed.x < 0) { this->speed.x += (speedDelta / 1.5); }
		if (this->speed.x < -6.0) { this->speed.x += (speedDelta * 2.0); }
	}
	else { // Going Right
		this->speed.x = this->speed.x - speedDelta;

		if (this->speed.x > 0) { this->speed.x -= (speedDelta / 1.5); }
		if (this->speed.x > 6.0) { this->speed.x -= (speedDelta * 2.0); }
	}
	
	this->HandleXSpeed();
	
	float yDiff;
	yDiff = (this->Baseline - this->pos.y) / 8;
	this->speed.y = yDiff;
		
	this->HandleYSpeed();

	this->UpdateObjectPosBasedOnSpeedValuesReal();

	this->timer = this->timer + 1;
}
void dThunderCloud::endState_Follow() { 
	this->speed.y = 0;
}


// Wait State

void dThunderCloud::beginState_Wait() { 
	this->timer = 0;
	this->bindAnimChr_and_setUpdateRate("cloud_wait", 1, 0.0, 1.0);
	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;
	PlaySound(this, SE_AMB_THUNDER_CLOUD);
}
void dThunderCloud::executeState_Wait() {

	charge.spawn("Wm_mr_electricshock_biri02_s", 0, &pos, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});

	if(this->anm.isAnimationDone()) {
		this->anm.setCurrentFrame(0.0); }

	if ((this->settings >> 16) & 0xFF) {
		if (dFlagMgr_c::instance->flags & this->eventFlag) {
			this->doStateChange(&StateID_Lightning);
		}
	}
	else {
		if (this->timer > 200) { this->doStateChange(&StateID_Lightning); }
		timer += 1;
	}
}
void dThunderCloud::endState_Wait() { }


// Lightning State
static void lightningCallback(ActivePhysics *one, ActivePhysics *two) {
	if (one->owner->name == WM_BUBBLE && two->owner->name == WM_BUBBLE)
		return;
	dEn_c::collisionCallback(one, two);
}

void dThunderCloud::lightningStrike() {
	PlaySound(this, SE_OBJ_KAZAN_ERUPTION); 

	float boltsize = (leader-14.0)/2;
	float boltpos = -boltsize - 14.0;

	ActivePhysics::Info Shock;
	Shock.xDistToCenter = 0.0;
	Shock.yDistToCenter = boltpos;
	Shock.category1 = 0x3;
	Shock.category2 = 0x9;
	Shock.bitfield1 = 0x4D;

	Shock.bitfield2 = 0x420; 
	Shock.xDistToEdge = 12.0;
	Shock.yDistToEdge = boltsize;

	Shock.unkShort1C = 0;
	Shock.callback = &dEn_c::collisionCallback;

	this->Lightning.initWithStruct(this, &Shock);
	this->Lightning.addToList();
}

void dThunderCloud::beginState_Lightning() {
	float backupY = pos.y, backupYSpeed = speed.y;

	speed.x = 0.0;
	speed.y = -1.0f;

	u32 result = 0;
	while (result == 0 && below.y > (-30 << 16)) {
		pos.y = backupY;
		below.y -= 0x4000;
		//OSReport("Sending out leader to %d", below.y>>12);

		result = collMgr.calculateBelowCollisionWithSmokeEffect();
		if (result == 0) {
			u32 tb1 = collMgr.getTileBehaviour1At(pos.x, pos.y + (below.y >> 12), 0);
			if (tb1 & 0x8000 && !(tb1 & 0x20))
				result = 1;
		}
		//OSReport("Result %d", result);
	}

	if (result == 0) {
		OSReport("Couldn't find any ground, falling back to 13 tiles distance");

		leader = 13 * 16;
	} else {
		OSReport("Lightning strikes at %d", below.y>>12);

		leader = -(below.y >> 12);
	}
	below.y = 0;

	pos.y = backupY;
	speed.y = backupYSpeed;

	if (usingEvents) {
		timer = 2;
		this->bindAnimChr_and_setUpdateRate("thundershoot", 1, 0.0, 1.0); 
		lightningStrike();
	} else {
		timer = 0;
	}
}
void dThunderCloud::executeState_Lightning() { 

	switch (timer) {
		case 0:
			charge.spawn("Wm_en_birikyu", 0, &(Vec){pos.x, pos.y, pos.z}, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});
			break;
		case 1:
			charge.spawn("Wm_en_birikyu", 0, &(Vec){pos.x, pos.y, pos.z}, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});
			break;
		case 2:		
			PlaySound(this, SE_BOSS_JR_ELEC_APP); 
			PlaySound(this, SE_BOSS_JR_DAMAGE_ELEC); 

			float boltsize = (leader-14.0)/2;
			float boltpos = -boltsize - 14.0;

			bolt.spawn("Wm_jr_electricline", 0, &(Vec){pos.x, pos.y + boltpos, pos.z}, &(S16Vec){0,0,0}, &(Vec){1.0, boltsize/36.0, 1.0});
			break;
		case 3:
			this->Lightning.removeFromList();
			charge.spawn("Wm_mr_electricshock_biri02_s", 0, &pos, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});
			break;
		case 4:
			charge.spawn("Wm_mr_electricshock_biri02_s", 0, &pos, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});
			break;
		case 5:
			if (stationary) { doStateChange(&StateID_Wait); }
			else 			{ doStateChange(&StateID_Follow); }
			break;
		default:
			charge.spawn("Wm_mr_electricshock_biri02_s", 0, &pos, &(S16Vec){0,0,0}, &(Vec){1.5, 1.5, 1.5});
			break;
	}

	if(this->anm.isAnimationDone() && this->anm.getCurrentFrame() != 0.0) {
		if (timer == 2 && usingEvents) {
			if (dFlagMgr_c::instance->flags & eventFlag) {
			} else {
				this->Lightning.removeFromList();
				doStateChange(&StateID_Wait);
			}
		} else {
			timer++;
			if (timer == 2) { 
				this->bindAnimChr_and_setUpdateRate("thundershoot", 1, 0.0, 1.0); 
				lightningStrike();
			} else if (timer == 3) {
				this->bindAnimChr_and_setUpdateRate("cloud_wait", 1, 0.0, 1.0);
			}
		}
		this->anm.setCurrentFrame(0.0);
	}
}

void dThunderCloud::endState_Lightning() {
	this->timer = 0;
}


// Thundercloud center = 0
// Thundercloud bottom = -12
// Thundercloud boltpos = -boltsize/2 - 14.0
// Thundercloud boltsize = (leader-14.0)/2
// Thundercloud effSize = 36.0 [*2]
// Thundercloud effScale = boltsize / effSize
// Thundercloud effPos = -boltsize/2 - 14.0



//
// processed\../src/makeYourOwnModelSprite.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>


//////////////////////////////////////////////////////////
//
//	How it works:
//
//		1) Skip down to line 70 - read the comments along the way if you like
//		2) Change the stuff inside " " to be what you want.
//		3) Copy paste an entire 'case' section of code, and change the number to change the setting it uses
//		4) give it back to Tempus to compile in
//



// This is the class allocator, you don't need to touch this
class dMakeYourOwn : public dStageActor_c {
	// Let's give ourselves a few functions
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	static dMakeYourOwn *build();

	// And a model and an anmChr
	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	nw4r::g3d::ResFile resFile;
	m3d::anmChr_c chrAnimation;

	nw4r::g3d::ResMdl mdl;

	// Some variables to use
	int model;
	bool isAnimating;
	float size;
	float zOrder;
	bool customZ;

	void setupAnim(const char* name, float rate);
	void setupModel(const char* arcName, const char* brresName, const char* mdlName);
};

// This sets up how much space we have in memory
dMakeYourOwn *dMakeYourOwn::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dMakeYourOwn));
	return new(buffer) dMakeYourOwn;
}


// Saves space when we do it like this
void dMakeYourOwn::setupAnim(const char* name, float rate) {
	if (isAnimating) {
		nw4r::g3d::ResAnmChr anmChr;

		anmChr = this->resFile.GetResAnmChr(name);
		this->chrAnimation.setup(this->mdl, anmChr, &this->allocator, 0);
		this->chrAnimation.bind(&this->bodyModel, anmChr, 1);
		this->bodyModel.bindAnim(&this->chrAnimation, 0.0);
		this->chrAnimation.setUpdateRate(rate);
	}
}

void dMakeYourOwn::setupModel(const char* arcName, const char* brresName, const char* mdlName) {
	this->resFile.data = getResource(arcName, brresName);
	this->mdl = this->resFile.GetResMdl(mdlName);

	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
}


// This gets run when the sprite spawns!
int dMakeYourOwn::onCreate() {

	// Settings for your sprite!

	this->model = this->settings & 0xFF; 						// Sets nubble 12 to choose the model you want
	this->isAnimating = this->settings & 0x100;					// Sets nybble 11 to a checkbox for whether or not the model has an anmChr to use
	this->size = (float)((this->settings >> 24) & 0xFF) / 4.0; 	// Sets nybbles 5-6 to size. Size equals value / 4.


	float zLevels[16] = {-6500.0, -5000.0, -4500.0, -2000.0, 
						 -1000.0, 300.0, 800.0, 1600.0, 
						  2000.0, 3600.0, 4000.0, 4500.0, 
						  6000.0, 6500.0, 7000.0, 7500.0 };

	this->zOrder = zLevels[(this->settings >> 16) & 0xF];

	this->customZ = (((this->settings >> 16) & 0xF) != 0);

	// Setup the models inside an allocator
	allocator.link(-1, GameHeaps[0], 0, 0x20);


	// Makes the code shorter and clearer to put these up here

	// A switch case, add extra models in here
	switch (this->model) {

		// TITLESCREEN STUFF
		// DEFAULT 

		case 0:		//Red ballon, bobs

			setupModel("arrow", "g3d/bre0.brres", "ballon_red"); 
			SetupTextures_Item(&bodyModel, 0);
			this->pos.z = -3300.0;

			setupAnim("anim00", 1.0); 

			break;	

		case 1:		//Green ballon, bobs

			setupModel("arrow", "g3d/bre1.brres", "ballon_green"); 
			SetupTextures_Item(&bodyModel, 0);
			this->pos.z = 3300.0;

			setupAnim("anim01", 1.0); 
			break;	
			
		case 2:		// Mario, using "wait" with mouth open

			setupModel("arrow", "g3d/bre2.brres", "mario_ts"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = -3000.0;

			setupAnim("anim02", 1.0); 
			break;	
						
		case 3:		// Peach, custom anim, bobs

			setupModel("arrow", "g3d/bre3.brres", "peach_ts"); 
			SetupTextures_Enemy(&bodyModel, 0);
			this->pos.z = -3000.0;

			setupAnim("anim03", 1.0); 
			break;	

		case 4:		// Luigi with mouth open using "wait", bobs

			setupModel("arrow", "g3d/bre4.brres", "luigi_ts"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim04", 1.0); 
			break;	
			
		case 5:	 // Yellow Toad with mouth open, does wait, bobs

			setupModel("arrow", "g3d/bre5.brres", "toady_ts"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim05", 1.0); 
			break;	

		case 6:		// Blue Toad with mouth open, bobs head and himself

			setupModel("arrow", "g3d/bre6.brres", "toadb_ts"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim06", 1.0); 
			break;	
			
		// BOWSER BEAT TS
		
		case 7:		// Mario's clowncar, bobs, animates propeller

			setupModel("block_arrow", "g3d/bre7.brres", "clowncar_mario"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 3300.0;

			setupAnim("anim07", 1.0); 
			break;	
			
		case 8:		// Weegee clowncar, bobs, animates propeller, spins

			setupModel("block_arrow", "g3d/bre8.brres", "clowncar_luigi"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 3300.0;

			setupAnim("anim08", 2.0); 
			break;	
			
		case 9:		// Toad Yellow clowncar, bobs, animates propeller

			setupModel("block_arrow", "g3d/bre9.brres", "clowncar_toady"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 3300.0;

			setupAnim("anim09", 1.0); 
			break;	
			
		case 10:	// Toad Blue, bobs, animates propeller

			setupModel("block_arrow", "g3d/bre10.brres", "clowncar_toadb"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 3300.0;

			setupAnim("anim10", 1.0); 
			break;	
		
		case 11:	// Peach clowncar, bobs, animates propeller

			setupModel("block_arrow", "g3d/bre11.brres", "clowncar_peach"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 3300.0;

			setupAnim("anim11", 1.0); 
			break;	
	
		case 12:	// Mario in a clowncar, bobbing, with fist outstretched.
		
			setupModel("block_arrow", "g3d/bre12.brres", "mario_end"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim12", 1.0); 
			break;	
			
		case 13:	// Weegee failing

			setupModel("block_arrow", "g3d/bre13.brres", "luigi_end"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim13", 2.0); 
			break;	
			
		case 14:		// Toad Yellow, bobs head, bobs

			setupModel("block_arrow", "g3d/bre14.brres", "toady_end"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim14", 1.0);
			break;	
			
		case 15:		// Blue Toad, bobs head, bobs

			setupModel("block_arrow", "g3d/bre15.brres", "toadb_end"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim15", 1.0); 
			break;	
			
		case 16:		// Peach laughing, bobbing

			setupModel("block_arrow", "g3d/bre16.brres", "peach_end"); 
			SetupTextures_Enemy(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim16", 1.0); 
			break;	
			
	//PERFECT FILE TS
			
		case 17:		// This is the peach castle backdrop

			setupModel("arrow", "g3d/bre17.brres", "ground_perfect"); 
			SetupTextures_Map(&bodyModel, 0);
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 3300.0;

			setupAnim("anim17", 1.0); 
			break;	
			
		case 18:		// Mario very small, looking up.

			setupModel("arrow", "g3d/bre18.brres", "mario_perfect"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3300.0;

			setupAnim("anim18", 1.0);
			break;	
			
		case 19:		// Weegee very small, looking up.

			setupModel("arrow", "g3d/bre19.brres", "luigi_perfect"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim19", 1.0); 
			break;	
			
		case 20:		// Yellow Toad, very small, looking up.

			setupModel("arrow", "g3d/bre16.brres", "toady_perfect"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim20", 1.0); 
			break;	
			
		case 21:		// Blue Toad, very small, looking up.

			setupModel("arrow", "g3d/bre16.brres", "toadb_perfect"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim21", 1.0); 
			break;	
			
		case 22:		// I don't think this is used, actually :|

			setupModel("arrow", "g3d/bre22.brres", "peach_perfect"); 
			SetupTextures_Enemy(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim22", 1.0); 
			break;	
			
		case 23:		// I don't think this is used, actually :|

			setupModel("arrow", "g3d/bre23.brres", "backdrop"); 
			SetupTextures_Map(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("anim23", 1.0); 
			break;	
			
	// A level thing
			
		case 24:		// Small cloud, bobs up and down

			setupModel("arrow", "g3d/bre24.brres", "cloud"); 
			SetupTextures_Item(&bodyModel, 0);
			this->pos.z = -3300.0;

			setupAnim("anim24", 1.0); 

			break;	
	
	// Here begins the ending crap 
	
		case 25:		// Ship fallen, with broken propellers and cannons.

			setupModel("cage_boss_koopa", "g3d/ShipFallen.brres", "KoopaShip"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("animation", 1.0);

			break;	
			
		case 26:		// A tree. From the ghost bg.

			setupModel("cage_boss_koopa", "g3d/tree_end.brres", "tree"); 
			SetupTextures_Map(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("animation", 1.0); 
			
			break;	
			
		case 27:		// Bowser, laying down, eyes closed. Medic? Medic!

			setupModel("cage_boss_koopa", "g3d/bowser_dead.brres", "koopa"); 
			SetupTextures_Boss(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("animation", 1.0);

			break;	
		
		case 28:		// A car. The animation has it tilted slightly. It's a bit darker than usual.

			setupModel("cage_boss_koopa", "g3d/clown_car_end.brres", "car"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 3000.0;

			setupAnim("animation", 1.0); 

			break;	
	//CREDITS SHIT
		case 29:		// Mario's clowncar, bobs, animates propeller

			setupModel("kameck_princess", "g3d/bre29.brres", "clowncar_mario"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim29", 1.0); 
			break;	
			
		case 30:		// Weegee clowncar, bobs, animates propeller

			setupModel("kameck_princess", "g3d/bre30.brres", "clowncar_luigi"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim30", 1.0); 
			break;	
			
		case 31:		// Toad Yellow clowncar, bobs, animates propeller

			setupModel("kameck_princess", "g3d/bre31.brres", "clowncar_toady"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim31", 1.0); 
			break;	
			
		case 32:	// Toad Blue, bobs, animates propeller

			setupModel("kameck_princess", "g3d/bre32.brres", "clowncar_toadb"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim32", 1.0); 
			break;	
		
		case 33:	// Peach clowncar, bobs, animates propeller

			setupModel("kameck_princess", "g3d/bre33.brres", "clowncar_peach"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim33", 1.0); 
			break;	
	
		case 34:	// Mario in a clowncar, bobbing, with fist outstretched.
		
			setupModel("kameck_princess", "g3d/bre34.brres", "mario_end"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 0;

			setupAnim("anim34", 1.0); 
			break;	
			
		case 35:	// Weegee 

			setupModel("kameck_princess", "g3d/bre35.brres", "luigi_end"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim35", 1.0); 
			break;	
			
		case 36:		// Toad Yellow, bobs head, bobs

			setupModel("kameck_princess", "g3d/bre36.brres", "toady_end"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim36", 1.0);
			break;	
			
		case 37:		// Blue Toad, bobs head, bobs

			setupModel("kameck_princess", "g3d/bre37.brres", "toadb_end"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim37", 1.0); 
			break;	
			
		case 38:		// Peach laughing, bobbing

			setupModel("kameck_princess", "g3d/bre38.brres", "peach_end"); 
			SetupTextures_Enemy(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim38", 1.0); 
			break;	
			
		case 39:		// PC Backdrop again

			setupModel("CreditsBG", "g3d/dupa.brres", "ground_perfect"); 
			SetupTextures_Map(&bodyModel, 0);
			this->pos.z = 0.0;

			setupAnim("anim38", 1.0); 
			break;	

		case 40:		// Chestnut Canopy

			setupModel("chestnut", "g3d/canopy.brres", "canopy"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 0.0;

			// setupAnim("anim38", 1.0); 
			break;	

		case 41:		// Chestnut Canopy

			setupModel("chestnut", "g3d/canopy_1.brres", "canopy_1"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 0.0;

			// setupAnim("anim38", 1.0); 
			break;	

		case 42:		// Chestnut Canopy

			setupModel("chestnut", "g3d/canopy_2.brres", "canopy_2"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 0.0;

			// setupAnim("anim38", 1.0); 
			break;	
		
		case 43:		// BallonR

			setupModel("OpeningScene", "g3d/ballon.brres", "ballon_red"); 
			SetupTextures_Item(&bodyModel, 0);
			this->pos.z = 0.0;

				setupAnim("anim", 1.0); 
			break;	
			
		case 44:		// BallonG

			setupModel("OpeningScene", "g3d/ballon2.brres", "ballon_green"); 
			SetupTextures_Item(&bodyModel, 0);
			this->pos.z = 0.0;

				setupAnim("anim", 1.0); 
			break;	
			
		case 45:		// Luigi Opening

			setupModel("OpeningScene", "g3d/weeg.brres", "weeg"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 0.0;

				setupAnim("anim", 1.0); 
			break;	
			
		case 46:		// Mario Opening

			setupModel("OpeningScene", "g3d/maleo.brres", "maleo"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 0.0;

				setupAnim("anim", 1.0); 
			break;	
			
		case 47:		// ToaB

			setupModel("OpeningScene", "g3d/todb.brres", "todb"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 0.0;

				setupAnim("anim", 1.0); 
			break;	

		case 48:		// ToaY

			setupModel("OpeningScene", "g3d/tody.brres", "tody"); 
			SetupTextures_Player(&bodyModel, 0);
			this->pos.z = 0.0;

				setupAnim("anim", 1.0); 
			break;	

		case 49:		// Chestnut Canopy

			setupModel("chestnut", "g3d/canopy_3.brres", "canopy_3"); 
			SetupTextures_MapObj(&bodyModel, 0);
			this->pos.z = 0.0;

			// setupAnim("anim38", 1.0); 
			break;	
	}

	allocator.unlink();

	if (size == 0.0) {	// If the person has the size nybble at zero, make it normal sized
		this->scale = (Vec){1.0,1.0,1.0};	
	}
	else {				// Else, use our size
		this->scale = (Vec){size,size,size};	
	}
		
	this->onExecute();
	return true;
}


// YOU'RE DONE, no need to do anything below here.


int dMakeYourOwn::onDelete() {
	return true;
}

int dMakeYourOwn::onExecute() {
	if (isAnimating) {
		bodyModel._vf1C();	// Advances the animation one update

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);	// Resets the animation when it's done
		}
	}

	return true;
}

int dMakeYourOwn::onDraw() {
	if (customZ) {
		matrix.translation(pos.x, pos.y, this->zOrder); }	// Set where to draw the model : -5500.0 is the official behind layer 2, while 5500.0 is in front of layer 0.
	else {
		matrix.translation(pos.x, pos.y, pos.z - 6500.0); }	// Set where to draw the model : -5500.0 is the official behind layer 2, while 5500.0 is in front of layer 0.

	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);	// Set how to rotate the drawn model 

	bodyModel.setDrawMatrix(matrix);	// Apply matrix
	bodyModel.setScale(&scale);			// Apply scale
	bodyModel.calcWorld(true);			// Do some shit

	bodyModel.scheduleForDrawing();		// Add it to the draw list for the game
	return true;
}

//
// processed\../src/pumpkinGoomba.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>

const char* PumpkinGoombaFileList [] = {
	"kuribo",
	"pumpkin",
	"wing",
	NULL	
};

class dGoombaPie : public dEn_c {
public:
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;
	m3d::mdl_c burstModel;

	dStageActor_c *Goomber;
	u32 timer;
	bool isBursting;
	bool invisible;


	static dActor_c *build();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	void _vf148();
	void _vf14C();
	bool CreateIceActors();
	void addScoreWhenHit(void *other);

	USING_STATES(dGoombaPie);
	DECLARE_STATE(Follow);
	DECLARE_STATE(Burst);
};

const SpriteData PumpkinGoombaSpriteData = { ProfileId::PumpkinGoomba, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile PumpkinGoombaProfile(&dGoombaPie::build, SpriteId::PumpkinGoomba, PumpkinGoombaSpriteData, ProfileId::PumpkinGoomba, ProfileId::PumpkinGoomba, "PumpkinGoomba", PumpkinGoombaFileList);

dActor_c *dGoombaPie::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dGoombaPie));
	return new(buffer) dGoombaPie;
}

///////////////////////
// Externs and States
///////////////////////
	extern "C" void *EN_LandbarrelPlayerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
	extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);
	extern "C" char usedForDeterminingStatePress_or_playerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther, int unk1);
	extern "C" bool SpawnEffect(const char*, int, Vec*, S16Vec*, Vec*);

	CREATE_STATE(dGoombaPie, Follow);
	CREATE_STATE(dGoombaPie, Burst);


////////////////////////
// Collision Functions
////////////////////////

	void pieCollisionCallback(ActivePhysics *one, ActivePhysics *two) {
		if (two->owner->name == (Actors)(one->owner->settings & 0xFFFF)) { return; }
		dEn_c::collisionCallback(one, two);
	}

	void dGoombaPie::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {

		char hitType;
		hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);

		if(hitType == 1) {	// regular jump
			apOther->someFlagByte |= 2;
			doStateChange(&StateID_Burst);
		} 
		else if(hitType == 3) {	// spinning jump or whatever?
			apOther->someFlagByte |= 2;
			doStateChange(&StateID_Burst);
		} 
		else if(hitType == 0) {
			EN_LandbarrelPlayerCollision(this, apThis, apOther);
			if (this->pos.x > apOther->owner->pos.x) {
				this->direction = 1;
			}
			else {
				this->direction = 0;
			}
			doStateChange(&StateID_Burst);
		} 

		// fix multiple player collisions via megazig
		deathInfo.isDead = 0;
		this->flags_4FC |= (1<<(31-7));
		this->counter_504[apOther->owner->which_player] = 0;
	}

	void dGoombaPie::spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther) {}
	void dGoombaPie::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) { this->playerCollision(apThis, apOther); }
	bool dGoombaPie::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) { doStateChange(&StateID_Burst); return true; }
	bool dGoombaPie::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) { doStateChange(&StateID_Burst); return true; }
	bool dGoombaPie::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) { doStateChange(&StateID_Burst); return true; }
	bool dGoombaPie::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) { doStateChange(&StateID_Burst); return true; }
	bool dGoombaPie::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){ doStateChange(&StateID_Burst); return true; }
	bool dGoombaPie::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) { doStateChange(&StateID_Burst); return true; }
	bool dGoombaPie::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){ doStateChange(&StateID_Burst); return true; }
	bool dGoombaPie::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){ doStateChange(&StateID_DieSmoke); return true; }
	bool dGoombaPie::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) { doStateChange(&StateID_DieSmoke); return true; }

	// These handle the ice crap
	void dGoombaPie::_vf148() {
		dEn_c::_vf148();
		doStateChange(&StateID_Burst);
	}
	void dGoombaPie::_vf14C() {
		dEn_c::_vf14C();
		doStateChange(&StateID_Burst);
	}

	DoSomethingCool goombIceBlock;

	extern "C" void sub_80024C20(void);
	extern "C" void __destroy_arr(void*, void(*)(void), int, int);

	bool dGoombaPie::CreateIceActors()
	{
	    struct DoSomethingCool goombIceBlock = { 0, this->pos, {2.5, 2.5, 2.5}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	    this->frzMgr.Create_ICEACTORs( (void*)&goombIceBlock, 1 );
	    __destroy_arr( (void*)&goombIceBlock, sub_80024C20, 0x3C, 1 );
	    return true;
	}

	void dGoombaPie::addScoreWhenHit(void *other) {}


int dGoombaPie::onCreate() {
	this->deleteForever = false;
	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("pumpkin", "g3d/model.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("Pumpkin");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	// SetupTextures_Map(&bodyModel, 0);

	mdl = this->resFile.GetResMdl("FX_Pumpkin");
	burstModel.setup(mdl, &allocator, 0x224, 1, 0);
	// SetupTextures_Map(&burstModel, 0);

	allocator.unlink();


	// Other shit
	isBursting = false;
	this->scale = (Vec){0.39, 0.39, 0.39};
	this->invisible = true;

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 12.0;

	HitMeBaby.xDistToEdge = 8.0;
	HitMeBaby.yDistToEdge = 14.0;		

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x01;
	HitMeBaby.bitfield2 = 0x820A0;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &pieCollisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	// Remember to follow a goomba
	u16 type = this->settings & 0xFFFF;
	Goomber = (dStageActor_c*)create((Actors)type, 0, &pos, &rot, 0);

	// State Changers
	doStateChange(&StateID_Follow);

	this->onExecute();
	return true;
}

int dGoombaPie::onDelete() {
	return true;
}

int dGoombaPie::onExecute() {
	acState.execute();
	this->pos = Goomber->pos;
	this->rot = Goomber->rot;
	OSReport("Goomber: %x\n", Goomber->currentProcessID);
	OSReport("Goomber: %x\n", Goomber->currentProcessID);
	if(Goomber->currentProcessID & 4)
		this->invisible = false;
	else
		this->invisible = true;
	return true;
}

int dGoombaPie::onDraw() {
	matrix.translation(pos.x, pos.y + 4.0, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	if (isBursting) {
		burstModel.setDrawMatrix(matrix);
		burstModel.setScale(&scale);
		burstModel.calcWorld(false);
		burstModel.scheduleForDrawing();
	} else {
		if(true) {
			bodyModel.setDrawMatrix(matrix);
			bodyModel.setScale(&scale);
			bodyModel.calcWorld(false);
			bodyModel.scheduleForDrawing();
		}
	}

	return true;
}



///////////////
// Follow State
///////////////
	void dGoombaPie::beginState_Follow() { }
	void dGoombaPie::executeState_Follow() { }
	void dGoombaPie::endState_Follow() { }

///////////////
// Burst State
///////////////
	void dGoombaPie::beginState_Burst() { 
		this->timer = 0; 
		isBursting = true;
		this->removeMyActivePhysics();
		SpawnEffect("Wm_ob_eggbreak_yw", 0, &pos, &(S16Vec){0,0,0}, &(Vec){2.0, 2.0, 2.0});
	}
	void dGoombaPie::executeState_Burst() { 
		//this->Delete(1);
	}
	void dGoombaPie::endState_Burst() { }


//
// processed\../src/trapblock.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
extern "C" void PlaySoundWithFunctionB4(void *spc, nw4r::snd::SoundHandle *handle, int id, int unk);

//Wrote by RedStoneMatt because CLF78 isn't able to do it :p


/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
// Trap Block

class daTrapBlock_c : public daEnBlockMain_c {
public:
	TileRenderer tile;
	Physics::Info physicsInfo;

	int wasIHit;
	int doOneTime;

	int onCreate();
	int onDelete();
	int onExecute();

	void calledWhenUpMoveExecutes();
	void calledWhenDownMoveExecutes();

	void blockWasHit(bool isDown);

	USING_STATES(daTrapBlock_c);
	DECLARE_STATE(Wait);

	static daTrapBlock_c *build();
};


CREATE_STATE(daTrapBlock_c, Wait);


int daTrapBlock_c::onCreate() {
	blockInit(pos.y);

	physicsInfo.x1 = -8;
	physicsInfo.y1 = 16;
	physicsInfo.x2 = 8;
	physicsInfo.y2 = 0;

	physicsInfo.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.flagsMaybe = 0x260;
	physics.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics.addToList();

	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->add(&tile);

	tile.x = pos.x - 8;
	tile.y = -(16 + pos.y);
	if((this->settings >> 24 & 0xF) == 0) {
		tile.tileNumber = 0x0; //0x0 is invisible, 0x30 is brick and 0x31 is question
	}
	if((this->settings >> 24 & 0xF) == 1) {
		tile.tileNumber = 0x30; //0x0 is invisible, 0x30 is brick and 0x31 is question
	}
	if((this->settings >> 24 & 0xF) == 2) {
		tile.tileNumber = 0x31; //0x0 is invisible, 0x30 is brick and 0x31 is question
	}

	this->spriteSomeRectX = 6000.0f;

	doStateChange(&daTrapBlock_c::StateID_Wait);

	return true;
}


int daTrapBlock_c::onDelete() {
	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->remove(&tile);

	physics.removeFromList();

	return true;
}


int daTrapBlock_c::onExecute() {
	acState.execute();
	physics.update();
	blockUpdate();

	tile.setPosition(pos.x-8, -(16+pos.y), pos.z);
	tile.setVars(scale.x);

	return true;
}


daTrapBlock_c *daTrapBlock_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daTrapBlock_c));
	return new(buffer) daTrapBlock_c;
}


void daTrapBlock_c::blockWasHit(bool isDown) {
	pos.y = initialY;
	int shroomSettings = isGroundPound ? 1 : 0;
	dStageActor_c *PoisonMushroom = dStageActor_c::create(PoisonShroom, shroomSettings, &this->pos, 0, 0); //Creating Poison Mushroom
	PoisonMushroom->pos.z = this->pos.z - 200;
	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_OBJ_ITEM_APPEAR, 1);
	this->wasIHit = 1;


	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.addToList();
	
	doStateChange(&StateID_Wait);
}



void daTrapBlock_c::calledWhenUpMoveExecutes() {
	if (initialY >= pos.y)
		blockWasHit(false);
}

void daTrapBlock_c::calledWhenDownMoveExecutes() {
	if (initialY <= pos.y)
		blockWasHit(true);
}



void daTrapBlock_c::beginState_Wait() {
}

void daTrapBlock_c::endState_Wait() {
}

void daTrapBlock_c::executeState_Wait() {
	if(this->wasIHit == 0) {
		int result = blockResult();

		if (result == 0)
			return;

		if (result == 1) {
			if((this->settings >> 24 & 0xF) == 0) { tile.tileNumber = 0x31; }
			doStateChange(&daEnBlockMain_c::StateID_UpMove);
			anotherFlag = 2;
			isGroundPound = false;
		} else {
			if((this->settings >> 24 & 0xF) != 0) {
				doStateChange(&daEnBlockMain_c::StateID_DownMove);
				anotherFlag = 1;
				isGroundPound = true;
			}
		}
	}
	if(this->wasIHit == 1 && this->doOneTime == 0) { //Was already hit ? Change the tiles.
		tile.tileNumber = 0x32; //Brown Block
		this->doOneTime++;
	}
}
//
// processed\../src/poisonmushroom.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>

//Wrote by RedStoneMatt because CLF78 isn't able to do it :p


/*****************************************************************************/
/*****************************************************************************/
/*****************************************************************************/
// Poison Mushroom

const char* PMarcNameList [] = {
	"PoisonMushroom",
	NULL	
};


class daPoisonShroom_c : public dEn_c {
public:
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;

	m3d::mdl_c bodyModel;

	m3d::anmChr_c chrAnimation;

	float XSpeed;
	u32 cmgr_returnValue;
	bool isOnTopOfTile;

	static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();
	bool calculateTileCollisions();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	// bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	USING_STATES(daPoisonShroom_c);
	DECLARE_STATE(Out);
	DECLARE_STATE(Walk);
	DECLARE_STATE(Turn);
	DECLARE_STATE(Die);
};

dActor_c *daPoisonShroom_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daPoisonShroom_c));
	return new(buffer) daPoisonShroom_c;
}

const SpriteData PoisonShroomSpriteData = { ProfileId::PoisonShroom, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile PoisonShroomProfile(&daPoisonShroom_c::build, SpriteId::PoisonShroom, PoisonShroomSpriteData, ProfileId::PoisonShroom, ProfileId::PoisonShroom, "PoisonShroom", PMarcNameList);

///////////////////////
// States
///////////////////////


	CREATE_STATE(daPoisonShroom_c, Out);
	CREATE_STATE(daPoisonShroom_c, Walk);
	CREATE_STATE(daPoisonShroom_c, Turn);
	CREATE_STATE(daPoisonShroom_c, Die);


////////////////////////
// Collision Functions
////////////////////////

	void daPoisonShroom_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->_vf220(apOther->owner);
		doStateChange(&StateID_Die);
	}

	void daPoisonShroom_c::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
		return this->playerCollision(apThis, apOther);
	}

	bool daPoisonShroom_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
		doStateChange(&StateID_Die);
		return true;
	}

	bool daPoisonShroom_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
		this->_vf220(apOther->owner);
		doStateChange(&StateID_Die);
		return true;
	}

	bool daPoisonShroom_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
		return this->collisionCatD_Drill(apThis, apOther);
	}

	bool daPoisonShroom_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
		return this->collisionCatD_Drill(apThis, apOther);
	}

	bool daPoisonShroom_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){
		return this->collisionCatD_Drill(apThis, apOther);
	}

	bool daPoisonShroom_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
		return this->collisionCatD_Drill(apThis, apOther);
	}

	bool daPoisonShroom_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){
		return this->collisionCatD_Drill(apThis, apOther);
	}

	bool daPoisonShroom_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){
		return this->collisionCatD_Drill(apThis, apOther);
	}

	bool daPoisonShroom_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
		return this->collisionCatD_Drill(apThis, apOther);
	}


bool daPoisonShroom_c::calculateTileCollisions() {
	// Returns true if sprite should turn, false if not.

	HandleXSpeed();
	HandleYSpeed();
	doSpriteMovement();

	cmgr_returnValue = collMgr.isOnTopOfTile();
	collMgr.calculateBelowCollisionWithSmokeEffect();

	stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);

	float xDelta = pos.x - last_pos.x;
	if (xDelta >= 0.0f)
		direction = 0;
	else
		direction = 1;

	if (collMgr.isOnTopOfTile()) {
		// Walking into a tile branch

		if (cmgr_returnValue == 0)
			isOnTopOfTile = true;

		speed.y = 0.0f;
		max_speed.x = (direction == 1) ? -0.8f : 0.8f;
	}

	collMgr.calculateAdjacentCollision(0);

	// Switch Direction
	if (collMgr.outputMaybe & (0x15 << direction)) {
		if (collMgr.isOnTopOfTile()) {
			isOnTopOfTile = true;
		}
		return true;
	}
	return false;
}

void daPoisonShroom_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daPoisonShroom_c::onCreate() {

	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("PoisonMushroom", "g3d/PoisonMushroom.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("PoisonMushroom");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_MapObj(&bodyModel, 0);

	// Animations start here
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr((this->settings == 0) ? "outup" : "outdown");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);


	allocator.unlink();

	// Stuff I do understand
	this->scale = (Vec){1.0, 1.0, 1.0};

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;
	this->direction = 0; // Heading right.
	
	this->speed.x = 0.0;
	this->speed.y = 0.0;
	this->max_speed.x = -0.8;
	this->x_speed_inc = 0.0;
	this->XSpeed = 0.8;

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 4.5;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;		

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	// Tile collider

	// These fucking rects do something for the tile rect
	spriteSomeRectX = 28.0f;
	spriteSomeRectY = 32.0f;
	_320 = 0.0f;
	_324 = 16.0f;

	static const lineSensor_s below(-5<<12, 5<<12, 0<<12);
	static const pointSensor_s above(0<<12, 12<<12);
	static const lineSensor_s adjacent(3<<12, 6<<12, 6<<12);

	collMgr.init(this, &below, &above, &adjacent);
	collMgr.calculateBelowCollisionWithSmokeEffect();

	cmgr_returnValue = collMgr.isOnTopOfTile();

	if (collMgr.isOnTopOfTile())
		isOnTopOfTile = false;
	else
		isOnTopOfTile = true;

	this->pos.y += (this->settings == 0) ? 16 : -18;

	// State Changers
	bindAnimChr_and_setUpdateRate((this->settings == 0) ? "outup" : "outdown", 1, 0.0, 1.0);

	doStateChange(&StateID_Out); 

	this->onExecute();
	return true;
}

int daPoisonShroom_c::onDelete() {
	return true;
}

int daPoisonShroom_c::onExecute() {
	acState.execute();
	updateModelMatrices();

	bodyModel._vf1C();
	
	return true;
}

int daPoisonShroom_c::onDraw() {
	bodyModel.scheduleForDrawing();

	return true;
}

void daPoisonShroom_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y - 2.0, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


///////////////
// Out State
///////////////
	void daPoisonShroom_c::beginState_Out() {
	}
	void daPoisonShroom_c::executeState_Out() {	
		this->speed.x = 0.0;
		this->speed.y = 0.0;
		this->max_speed.x = 0.0;
		this->max_speed.y = 0.0;

		if(this->chrAnimation.isAnimationDone()) {
			bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);
			doStateChange(&StateID_Walk);
		}
	}
	void daPoisonShroom_c::endState_Out() { }


///////////////
// Walk State
///////////////
	void daPoisonShroom_c::beginState_Walk() {
		this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
		this->speed.x = (this->direction) ? -0.0 : 0.0;
		this->x_speed_inc = 0.1;

		this->max_speed.y = -2;
		this->speed.y = 0.0;
		this->y_speed_inc = -0.15;
	}
	void daPoisonShroom_c::executeState_Walk() {	
		bool ret = calculateTileCollisions();
		if (ret) {
			doStateChange(&StateID_Turn);
		}

		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}
	}
	void daPoisonShroom_c::endState_Walk() { }


///////////////
// Turn State
///////////////
	void daPoisonShroom_c::beginState_Turn() {
		this->direction ^= 1;
		this->speed.x *= -1;
	}
	void daPoisonShroom_c::executeState_Turn() {
		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
		}
		this->doStateChange(&StateID_Walk);
	}
	void daPoisonShroom_c::endState_Turn() { }


///////////////
// Die State
///////////////
	void daPoisonShroom_c::beginState_Die() {
		this->removeMyActivePhysics();
	}
	void daPoisonShroom_c::executeState_Die() {
		S16Vec nullRot = {0,0,0};
		Vec oneVec = {1.0f, 1.0f, 1.0f};
		SpawnEffect("Wm_en_obakedoor_sm", 0, &this->pos, &nullRot, &oneVec);
				
		PlaySound(this, SE_EMY_MECHAKOOPA_DAMAGE);
		this->kill();
		this->Delete(this->deleteForever);
	}
	void daPoisonShroom_c::endState_Die() { }
//
// processed\../src/purplecoin.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "boomeranghax.h"

const char *PurpleCoinFileList[] = {"purplecoin", 0};


class daEnPurpleCoin_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;

	bool type8fastJump;
	int type8timer;
	int type8timer2;

	static dActor_c *build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
};

const SpriteData PurpleCoinSpriteData = { ProfileId::PurpleCoin, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile PurpleCoinProfile(&daEnPurpleCoin_c::build, SpriteId::PurpleCoin, PurpleCoinSpriteData, ProfileId::PurpleCoin, ProfileId::PurpleCoin, "PurpleCoin", PurpleCoinFileList);



u8 hijackMusicWithSongName(const char *songName, int themeID, bool hasFast, int channelCount, int trackCount, int *wantRealStreamID);

void daEnPurpleCoin_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->type8fastJump = true;
}
void daEnPurpleCoin_c::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->type8fastJump = true;
}
bool daEnPurpleCoin_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->type8fastJump = true;
	return false;
}
bool daEnPurpleCoin_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->type8fastJump = true;
	return false;
}
bool daEnPurpleCoin_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnPurpleCoin_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}

bool daEnPurpleCoin_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnPurpleCoin_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {

	return false;
}
bool daEnPurpleCoin_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {

	return false;
}
bool daEnPurpleCoin_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnPurpleCoin_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}

bool daEnPurpleCoin_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}


dActor_c *daEnPurpleCoin_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daEnPurpleCoin_c));
	daEnPurpleCoin_c *c = new(buffer) daEnPurpleCoin_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

int daEnPurpleCoin_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("purplecoin", "g3d/purplecoin.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("PurpleCoin");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	// Stuff I do understand
	this->scale = (Vec){0.2, 0.2, 0.2};

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;

	this->pos.z = 4000;


	this->onExecute();
	return true;
}


int daEnPurpleCoin_c::onDelete() {
	return true;
}

int daEnPurpleCoin_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnPurpleCoin_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y - 14, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnPurpleCoin_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();
	if(!this->type8fastJump) {
		this->rot.y += 0x300;
	}
	else {
		this->rot.y += 0x2000;
		this->type8timer++;
		if(this->type8timer == 1) {
			nw4r::snd::StrmSoundHandle purpleHandle;
			//int sID;
			//hijackMusicWithSongName("sfx/PURPLECOIN", -1, false, 2, 1, &sID);
			//PlaySoundWithFunctionB4(SoundRelatedClass, &purpleHandle, sID, 1);
			dGameDisplay_c::instance->purplecoins++;
			dGameDisplay_c::instance->refreshPurpleCoins();
			this->removeMyActivePhysics();
		}
		if(this->type8timer < 6) {
			this->pos.y += 4;
			// this->scale.x -= 0.05;
			// this->scale.y -= 0.05;
			// this->scale.z -= 0.05;
		}
		if(this->type8timer > 5 && this->type8timer < 11) {
			this->pos.y -= 4;
			// this->scale.x -= 0.1;
			// this->scale.y -= 0.1;
			// this->scale.z -= 0.1;
		}
		if(this->type8timer == 11) {
			this->Delete(1);
		}
	}

	return true;
}
//
// processed\../src/playerNumberEvent.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>


class playerNumberEvent : public dStageActor_c {
public:
	u8 eventNums[4];

	bool useTriggerEvent;
	bool repeat;
	bool toggelEvent;
	int interval;
	int timer;

	void tryToTrigger();

	int onCreate();
	int onExecute();

	static dActor_c *build();
};

const char *PlayerNumberEventFileList[] = {0};
const SpriteData playerNumberEventSpriteData = { ProfileId::PlayerNumberEvent, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile playerNumberEventProfile(&playerNumberEvent::build, SpriteId::PlayerNumberEvent, playerNumberEventSpriteData, ProfileId::PlayerNumberEvent, ProfileId::PlayerNumberEvent, "PlayerNumberEvent", PlayerNumberEventFileList);


dActor_c  *playerNumberEvent::build() {
	void *buffer = AllocFromGameHeap1(sizeof(playerNumberEvent));
	playerNumberEvent *c = new(buffer) playerNumberEvent;

	return c;
}


int playerNumberEvent::onCreate() {
	this->eventNums[0] = (this->settings >> 26 & 0b111111) - 1;
	this->eventNums[1] = (this->settings >> 20 & 0b111111) - 1;
	this->eventNums[2] = (this->settings >> 14 & 0b111111) - 1;
	this->eventNums[3] = (this->settings >> 8 & 0b111111) - 1;

	this->useTriggerEvent = this->settings >> 7 & 0b1;
	this->repeat = this->settings >> 6 & 0b1;
	this->toggelEvent = this->settings >> 5 & 0b1;
	this->interval = (this->settings & 0b11111) + 1;
	this->timer = 0;

	/*OSReport("useTriggerEvent: %s\n", useTriggerEvent ? "true" : "false");
	OSReport("repeat: %s\n", repeat ? "true" : "false");
	OSReport("toggelEvent: %s\n", toggelEvent ? "true" : "false");
	OSReport("interval: %d\n", interval);
	OSReport("eventNums: %d\n", eventNums[0]);
	OSReport("eventNums: %d\n", eventNums[1]);
	OSReport("eventNums: %d\n", eventNums[2]);
	OSReport("eventNums: %d\n", eventNums[3]);*/

	this->onExecute();
	return true;
}


int playerNumberEvent::onExecute() {
	//OSReport("spriteFlagArray: %s\n", this->spriteFlagArray[5] ? "true" : "false");
	
	//OSReport("playerNumber: %d\n", GetActivePlayerCount());
	if(this->timer == 0) {
		if(this->useTriggerEvent) {
			bool flagOn = ((dFlagMgr_c::instance->flags & spriteFlagMask) != 0);
			//OSReport("Is flag on: %s\n", flagOn ? "true" : "false");
			if(flagOn) {
				this->tryToTrigger();
				if(!this->repeat) {
					dFlagMgr_c::instance->flags &= ~spriteFlagMask;		//deactivate triggering event after being done!
					return true;
				}
			} else {
				return true;
			}
		} else {
			this->tryToTrigger();
			if(!this->repeat) {
				this->Delete(1);
				return true;
			}
		}
		this->timer = this->interval*60;
	} else {
		this->timer--;
	}

	return true;
}


void playerNumberEvent::tryToTrigger() {
	//OSReport("tryToTrigger: %d\n", eventNums[GetActivePlayerCount()-1]);
	if(this->toggelEvent) {
		dFlagMgr_c::instance->set(eventNums[GetActivePlayerCount()-1], 0, !dFlagMgr_c::instance->active(eventNums[GetActivePlayerCount()-1]), false, false);
	} else {
		dFlagMgr_c::instance->set(eventNums[GetActivePlayerCount()-1], 0, true, false, false);
	}
}
//
// processed\../src/gameStateEvent.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>


class gameStateEvent : public dStageActor_c {
public:
	u8 targetEvent;
	bool toggelEvent;
	bool useTriggerEvent;
	u8 type;

	bool starcoin1;
	bool starcoin2;
	bool starcoin3;
	u8 world;
	u8 level;

	bool exitOrCheckpointTaken;
	bool secretExit;

	bool hardmodeHasToBeOff;

	bool useGeqInsteadOfLeq;
	int time;
	u8 livesType; //0=avg, 1=min, 2=max
	u8 lives;

	void tryToTrigger();

	int onCreate();
	int onExecute();

	static dActor_c *build();
};

const char *GameStateEventFileList[] = {0};
const SpriteData gameStateEventSpriteData = { ProfileId::GameStateEvent, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile gameStateEventProfile(&gameStateEvent::build, SpriteId::GameStateEvent, gameStateEventSpriteData, ProfileId::GameStateEvent, ProfileId::GameStateEvent, "GameStateEvent", GameStateEventFileList);


dActor_c  *gameStateEvent::build() {
	void *buffer = AllocFromGameHeap1(sizeof(gameStateEvent));
	gameStateEvent *c = new(buffer) gameStateEvent;

	return c;
}


int gameStateEvent::onCreate() {
	this->targetEvent = (this->settings & 0b111111) - 1;
	this->toggelEvent = this->settings >> 6 & 0b1;
	this->useTriggerEvent = this->settings >> 7 & 0b1;

	this->type = this->settings >> 28 & 0xF;

	switch(this->type) {
		case 0:
			this->starcoin1 = this->settings >> 27 & 0b1;
			this->starcoin2 = this->settings >> 26 & 0b1;
			this->starcoin3 = this->settings >> 25 & 0b1;
			this->world = this->settings >> 20 & 0xF;
			this->level = this->settings >> 14 & 0b111111;
			break;
		case 1:
			this->exitOrCheckpointTaken = this->settings >> 27 & 0b1;
			this->secretExit = this->settings >> 26 & 0b1;
			this->world = this->settings >> 20 & 0xF;
			this->level = this->settings >> 14 & 0b111111;
			break;
		case 2:
			this->exitOrCheckpointTaken = this->settings >> 27 & 0b1;
			break;
		case 3:
			this->hardmodeHasToBeOff = this->settings >> 27 & 0b1;
			break;
		case 4:
			this->useGeqInsteadOfLeq = this->settings >> 27 & 0b1;
			this->time = this->settings >> 17 & 0b1111111111;
			break;
		case 5:
			this->useGeqInsteadOfLeq = this->settings >> 27 & 0b1;
			this->livesType = this->settings >> 25 & 0b11;
			this->lives = this->settings >> 18 & 0b1111111;
			break;
		default:
			OSReport("Wrong sprite settings!\n");
	}

	OSReport("useTriggerEvent: %s\n", useTriggerEvent ? "true" : "false");
	OSReport("toggelEvent: %s\n", toggelEvent ? "true" : "false");
	OSReport("targetEvent: %d\n", targetEvent);
	OSReport("type: %d\n", type);
	OSReport("starcoin1: %s\n", starcoin1 ? "true" : "false");
	OSReport("starcoin2: %s\n", starcoin2 ? "true" : "false");
	OSReport("starcoin3: %s\n", starcoin3 ? "true" : "false");
	OSReport("world: %d\n", type);
	OSReport("level: %d\n", type);
	OSReport("exitOrCheckpointTaken: %s\n", exitOrCheckpointTaken ? "true" : "false");
	OSReport("secretExit: %s\n", secretExit ? "true" : "false");
	OSReport("hardmodeHasToBeOff: %s\n", hardmodeHasToBeOff ? "true" : "false");
	OSReport("useGeqInsteadOfLeq: %s\n", useGeqInsteadOfLeq ? "true" : "false");
	OSReport("time: %d\n", time);
	OSReport("livesType: %d\n", livesType);
	OSReport("lives: %d\n\n", lives);

	this->onExecute();
	return true;
}


int gameStateEvent::onExecute() {
	if(this->useTriggerEvent) {
		bool flagOn = ((dFlagMgr_c::instance->flags & spriteFlagMask) != 0);
		OSReport("Is flag on: %s\n", flagOn ? "true" : "false");
		if(flagOn) {
			this->tryToTrigger();
			dFlagMgr_c::instance->flags &= ~spriteFlagMask;		//deactivate triggering event after being done!
		}
	} else {
		this->tryToTrigger();
		this->Delete(1);
	}

	return true;
}

extern bool enableHardMode;
extern u32 GameTimerB;
void gameStateEvent::tryToTrigger() {
	bool doTrigger = false;
	SaveBlock *save = GetSaveFile()->GetBlock(-1);
	float actualLives = .0f;
	u8 count = 0;

	switch(this->type) {
		case 0:
			if(world < 10)
				if(level < 42)
					if(save->CheckLevelCondition(world, level, COND_COIN1) == starcoin1)
						if(save->CheckLevelCondition(world, level, COND_COIN2) == starcoin2)
							if(save->CheckLevelCondition(world, level, COND_COIN3) == starcoin3)
								doTrigger = true;
			break;
		case 1:
			if(world < 10)
				if(level < 42)
					if(save->CheckLevelCondition(world, level, secretExit ? COND_SECRET : COND_NORMAL) == exitOrCheckpointTaken)
						doTrigger = true;
			break;
		case 2:
			if((GameMgrP->eight.checkpointEntranceID != 255 && GameMgrP->eight.checkpointWorldID == LastLevelPlayed[0] && GameMgrP->eight.checkpointLevelID == LastLevelPlayed[1]) == exitOrCheckpointTaken)
				doTrigger = true;
			break;
		case 3:
			if(enableHardMode != hardmodeHasToBeOff)
				doTrigger = true;
			break;
		case 4:
			if(useGeqInsteadOfLeq)
				if(time*4096 >= GameTimerB)
					doTrigger = true;
			else
				if(time*4096 <= GameTimerB)
					doTrigger = true;

			break;
		case 5:
			for (int i = 0; i < 4; i++) {
				if (Player_Active[i] != 0) {

					if(livesType == 0)
						actualLives += Player_Lives[Player_ID[i]];
					else if(livesType == 1)
						if(actualLives > Player_Lives[Player_ID[i]])
							actualLives = Player_Lives[Player_ID[i]];
					else
						if(actualLives < Player_Lives[Player_ID[i]])
							actualLives = Player_Lives[Player_ID[i]];

					count++;
				}
			}
			if(livesType == 0)
				actualLives /= count;

			if(useGeqInsteadOfLeq)
				if(lives >= actualLives)
					doTrigger = true;
			else
				if(lives <= actualLives)
					doTrigger = true;
			break;
		default:
			this->Delete(1);
	}

	if(doTrigger) {
		if(this->toggelEvent) {
			dFlagMgr_c::instance->set(this->targetEvent, 0, !dFlagMgr_c::instance->active(this->targetEvent), false, false);
		} else {
			dFlagMgr_c::instance->set(this->targetEvent , 0, true, false, false);
		}
	}
}
//
// processed\../src/tripleblock.cpp
//

#include <common.h>
#include <game.h>
#include <actors.h>
#include "sfx.h"

class daEnTripleBlock_c : public daEnBlockMain_c {
public:
	TileRenderer tileRight;
	TileRenderer tileMiddle;
	TileRenderer tileLeft;
	Physics::Info physicsInfo;

	int onCreate();
	int onDelete();
	int onExecute();

	void calledWhenUpMoveExecutes();
	void calledWhenDownMoveExecutes();

	void blockWasHit(bool isDown);
	
	virtual bool isOutOfView();
	virtual void willBeDeleted();
	
	float wasIHit;
	int doOneTime;

	USING_STATES(daEnTripleBlock_c);
	DECLARE_STATE(Wait);

	static dActor_c *build();
};


CREATE_STATE(daEnTripleBlock_c, Wait);


int daEnTripleBlock_c::onCreate() {
	this->pos.y -= 8;
	blockInit(pos.y);
	this->sub_80021740();

	physicsInfo.x1 = -24;
	physicsInfo.y1 = 16;
	physicsInfo.x2 = 24;
	physicsInfo.y2 = 0;

	physicsInfo.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.flagsMaybe = 0x260;
	physics.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics.addToList();
	
	this->_68B = 1;
	physics._D8 &= ~0b00101000;
	
	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	
	//Right
	list->add(&tileRight);

	tileRight.x = pos.x + 8;
	tileRight.y = -(16 + pos.y);
	tileRight.tileNumber = 0x9B;

	//Middle
	list->add(&tileMiddle);

	tileMiddle.x = pos.x - 8;
	tileMiddle.y = -(16 + pos.y);
	tileMiddle.tileNumber = 0x9A;

	//Left
	list->add(&tileLeft);

	tileLeft.x = pos.x - 24;
	tileLeft.y = -(16 + pos.y);
	tileLeft.tileNumber = 0x99;

	this->wasIHit = 0.0f;
	this->pos.z = 200.0f;
	
	this->spriteSomeRectX = 6000.0f;
	
	doStateChange(&daEnTripleBlock_c::StateID_Wait);

	return true;
}


int daEnTripleBlock_c::onDelete() {
	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->remove(&tileRight);
	list->remove(&tileMiddle);
	list->remove(&tileLeft);

	physics.removeFromList();

	return true;
}


int daEnTripleBlock_c::onExecute() {
	acState.execute();
	physics.update();
	blockUpdate();

	tileRight.setPosition(pos.x+8, -(16+pos.y), pos.z);
	tileRight.setVars(scale.x);
	
	tileMiddle.setPosition(pos.x-8, -(16+pos.y), pos.z);
	tileMiddle.setVars(scale.x);
	
	tileLeft.setPosition(pos.x-24, -(16+pos.y), pos.z);
	tileLeft.setVars(scale.x);

	// now check zone bounds based on state
	if (acState.getCurrentState()->isEqual(&StateID_Wait)) {
		checkZoneBoundaries(0);
	}

	return true;
}


const char *TripleBlockFileList[] = {0};
const SpriteData TripleBlockSpriteData = { ProfileId::TripleBlock, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile TripleBlockProfile(&daEnTripleBlock_c::build, SpriteId::TripleBlock, TripleBlockSpriteData, ProfileId::TripleBlock, ProfileId::TripleBlock, "TripleBlock", TripleBlockFileList);

dActor_c *daEnTripleBlock_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daEnTripleBlock_c));
	return new(buffer) daEnTripleBlock_c;
}


extern "C" int CheckExistingPowerup(void * Player);

void daEnTripleBlock_c::blockWasHit(bool isDown) {
	pos.y = initialY;
	
	int p = CheckExistingPowerup(dAcPy_c::findByID(this->playerID)); // Powerups - 0 = small; 1 = big; 2 = fire; 3 = mini; 4 = prop; 5 = peng; 6 = ice; 7 = hammer
	
	Vec coinPosL = (Vec){this->pos.x - 16, this->pos.y + 8, this->pos.z}; //Setting non-GP coinLeft position
	Vec coinPosR = (Vec){this->pos.x + 16, this->pos.y + 8, this->pos.z}; //Setting non-GP coinRight position
	
	nw4r::snd::SoundHandle handle; //Sound Handle
	
	u32 enitemsettings; //EN_ITEM settings
	static u32 reggieToIG[] = {0x0,0x1,0x2,0x7,0x9,0xE,0x11,0x15,0x19,0x6,0x2}; //Mushroom, Star, Coin, 1UP, Fire Flower, Ice Flower, Penguin, Propeller, Mini Shroom, Hammer, 10 Coins
	u32 powerupToSet = reggieToIG[(this->settings >> 20 & 0xF)]; //Spritedata ID to EN_ITEM ID
	enitemsettings = 0 | (powerupToSet << 0) | (2 << 18) | (4 << 9) | (2 << 10) | (this->playerID + 8 << 16); //Setting non-GP settings
	
	u32 coinsettings; //Coins settings (which are EN_ITEM variant)
	coinsettings = 0 | (0x2 << 0) | (2 << 18) | (4 << 9) | (2 << 10) | (this->playerID + 8 << 16); //Setting non-GP settings
	
	if(isGroundPound) { //If the player groundpounded the block, change some setting and positions
		enitemsettings = 0 | (powerupToSet << 0) | (3 << 18) | (4 << 9) | (2 << 10) | (this->playerID + 8 << 16); //Changing value 0xD98 from 2 to 3
		coinsettings = 0 | (0x2 << 0) | (3 << 18) | (4 << 9) | (2 << 10) | (this->playerID + 8 << 16); //Changing value 0xD98 from 2 to 3
		coinPosL = (Vec){this->pos.x - 16, this->pos.y - 8, this->pos.z}; //Changing pos.y
		coinPosR = (Vec){this->pos.x + 16, this->pos.y - 8, this->pos.z}; //Changing pos.y
	}
	if((powerupToSet != 0x2 && powerupToSet != 0x15) || p == 0 || p == 3) { //Propeller does a different sound and Coin doesn't do any sound
		PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_OBJ_ITEM_APPEAR, 1); //Item sound
	}
	if(powerupToSet == 0x15 && p != 0) { //If powerup = propeller
		PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_OBJ_ITEM_PRPL_APPEAR, 1); //Propeller sound
	}
	dStageActor_c *PowerUp = dStageActor_c::create(EN_ITEM, enitemsettings, &this->pos, 0, 0); //Creating PowerUp
	dStageActor_c *coinLeft = dStageActor_c::create(EN_ITEM, coinsettings, &coinPosL, 0, 0); //Creating coinLeft
	dStageActor_c *coinRight = dStageActor_c::create(EN_ITEM, coinsettings, &coinPosR, 0, 0); //Creating coinRight
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_OBJ_GET_COIN, 1); //Coin sound
	if(powerupToSet != 0x15 || p == 0 || p == 3) { //If powerup =/= propeller OR actual powerup = 0
		PowerUp->pos.z = 100.0f; //make the powerup behind the triple block
	}

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.addToList();
	
	if((this->settings >> 20 & 0xF) == 10) { //If 10 Coins variant, then only add 0.1 to wasIHit
		this->wasIHit += 0.1f;
	}
	else { //Otherwise, add 1
		this->wasIHit = 1.0f;
	}
	doStateChange(&StateID_Wait); //Back to waiting state
}



void daEnTripleBlock_c::calledWhenUpMoveExecutes() {
	if (initialY >= pos.y)
		blockWasHit(false);
}

void daEnTripleBlock_c::calledWhenDownMoveExecutes() {
	if (initialY <= pos.y)
		blockWasHit(true);
}



void daEnTripleBlock_c::beginState_Wait() {
}

void daEnTripleBlock_c::endState_Wait() {
}

void daEnTripleBlock_c::executeState_Wait() {
	if(this->wasIHit < 1.0f) {
		int result = blockResult();

		if (result == 0)
			return;

		if (result == 1) {
			doStateChange(&daEnBlockMain_c::StateID_UpMove);
			anotherFlag = 2;
			isGroundPound = false;
		} else {
			doStateChange(&daEnBlockMain_c::StateID_DownMove);
			anotherFlag = 1;
			isGroundPound = true;
		}
	}
	if(this->wasIHit > 0.9f && this->doOneTime == 0) { //Was already hit ? Change the tiles.
		tileRight.tileNumber = 0xA8;
		tileMiddle.tileNumber = 0xA7;
		tileLeft.tileNumber = 0xA6;
		this->doOneTime++;
	}
}

bool daEnTripleBlock_c::isOutOfView() {
}

void daEnTripleBlock_c::willBeDeleted() {
	return;
}
//
// processed\../src/timeclock.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include <timekeeper.h>

const char* TimeClockFileList [] = { "clock", 0 };

extern "C" void PlaySoundWithFunctionB4(void *spc, nw4r::snd::SoundHandle *handle, int id, int unk);
static nw4r::snd::StrmSoundHandle handle;



//used in timeclock.S
bool slowDownTime = false;	
int getTimeSfxIndex() {
	dCourse_c *course = dCourseFull_c::instance->get(GetAreaNum());
	dCourse_c::zone_s *zone = course->getZoneByID(GetZoneNum());
	return zone->unk3;
}




u8 hijackMusicWithSongName(const char *songName, int themeID, bool hasFast, int channelCount, int trackCount, int *wantRealStreamID);

class daTimeClock_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	
	int immaGonnaDisappear;
	int timer;

	static dActor_c *build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
};

const SpriteData timeClockSpriteData = { ProfileId::TimeClock, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile timeClockEventProfile(&daTimeClock_c::build, SpriteId::TimeClock, timeClockSpriteData, ProfileId::TimeClock, ProfileId::TimeClock, "TimeClock", TimeClockFileList);



void daTimeClock_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	int addTime = ((this->settings >> 20 & 0xF) * 10);
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_DEMO_OP_V_PCH_INTO_CAKE, 1); //Audio[1045], replaced with the clock sound
	if(dGameDisplay_c::instance->timer <= 100 && dGameDisplay_c::instance->timer + addTime > 100)
		slowDownTime = true;
	TimeKeeper::instance->setTime(dGameDisplay_c::instance->timer + addTime);
	removeMyActivePhysics();
	// ClassWithCameraInfo *cwci = ClassWithCameraInfo::instance;
	// Vec debug = ConvertStagePositionIntoScreenPosition(&dGameDisplay_c::instance->timerBox->trans, &this->pos, ClassWithCameraInfo::instance);
	// OSReport("trans.x = %d trans.y = %d trans.z %d\n", dGameDisplay_c::instance->timerBox->trans.x, dGameDisplay_c::instance->timerBox->trans.y, dGameDisplay_c::instance->timerBox->trans.z);
	// OSReport("pos.x = %d pos.y = %d pos.z %d\n", this->pos.x, this->pos.y, this->pos.z);
	// OSReport("newtrans.x = %d newtrans.y = %d newtrans.z = %d\n", debug.x, debug.y, debug.z);
	// dGameDisplay_c::instance->timerBox->trans = ConvertStagePositionIntoScreenPosition(&dGameDisplay_c::instance->timerBox->trans, &this->pos, ClassWithCameraInfo::instance);
	this->immaGonnaDisappear++;
}

bool daTimeClock_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_DEMO_OP_V_PCH_INTO_CAKE, 1); //Audio[1045], replaced with the clock sound
	TimeKeeper::instance->setTime(dGameDisplay_c::instance->timer + ((this->settings >> 20 & 0xF) * 10));
	removeMyActivePhysics();
	this->immaGonnaDisappear++;
	return false;
}
bool daTimeClock_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	return collisionCat7_GroundPound(apThis, apOther);
}
bool daTimeClock_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	return collisionCat9_RollingObject(apThis, apOther);
}
bool daTimeClock_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther) {
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_DEMO_OP_V_PCH_INTO_CAKE, 1); //Audio[1045], replaced with the clock sound
	TimeKeeper::instance->setTime(dGameDisplay_c::instance->timer + ((this->settings >> 20 & 0xF) * 10));
	removeMyActivePhysics();
	this->immaGonnaDisappear++;
}

bool daTimeClock_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	return collisionCat9_RollingObject(apThis, apOther);
}
bool daTimeClock_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {
	return collisionCat9_RollingObject(apThis, apOther);
}
bool daTimeClock_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true;
}
bool daTimeClock_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
	return collisionCat9_RollingObject(apThis, apOther);
}
bool daTimeClock_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther) {
	return collisionCat1_Fireball_E_Explosion(apThis, apOther);
}

bool daTimeClock_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true;
}



dActor_c *daTimeClock_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daTimeClock_c));
	return new(buffer) daTimeClock_c;
}


int daTimeClock_c::onCreate() {

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	nw4r::g3d::ResFile rf(getResource("clock", "g3d/clock.brres"));
	if((this->settings >> 16 & 0xF) == 0) {
		bodyModel.setup(rf.GetResMdl("ClockGreen"), &allocator, 0x224, 1, 0);
	}
	if((this->settings >> 16 & 0xF) == 1) {
		bodyModel.setup(rf.GetResMdl("ClockBlue"), &allocator, 0x224, 1, 0);
	}
	SetupTextures_MapObj(&bodyModel, 0);

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;
	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;
	HitMeBaby.xDistToEdge = 12.0;
	HitMeBaby.yDistToEdge = 15.0;
	HitMeBaby.category1 = 0x5;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0xFFFFFFFF;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	this->scale.x = 50.0;
	this->scale.y = 50.0;
	this->scale.z = 50.0;

	this->pos.z = 3300.0;

	this->onExecute();
	return true;
}


int daTimeClock_c::onDelete() {
	return true;
}

int daTimeClock_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daTimeClock_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daTimeClock_c::onExecute() {
	updateModelMatrices();

	if(immaGonnaDisappear == 1) {
		this->rot.y -= 0x1000;
		this->timer++;
		this->scale = (Vec){this->scale.x - 2.1f, this->scale.y - 2.1f, this->scale.z - 2.1f};
		if(this->timer == 1) {
			S16Vec rotation = {0,0,0};
			Vec scale = {1.0, 1.0, 1.0};
			SpawnEffect("Wm_ob_starcoinget_ring", 0, &this->pos, &rotation, &scale);	
		}
		if(this->timer < 8) {
			this->pos.y += 2;
		}
		if(this->timer > 7 && this->timer < 16) {
			this->pos.y -= 2;
		}
		if(this->timer > 16) {
			this->Delete(1);
		}
	}
	else {
		this->rot.y -= 0x200;
	}
	return true;
}


//
// processed\../src/superBubble.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

const char* SuperBubbleFileList[] = { "frogM", 0 };



class daSuperBubble_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile resFileAnim;
	m3d::mdl_c bodyModel;

	m3d::anmChr_c chrAnimation;

	int alreadyOnTop;

	float XSpeed;
	bool canI;
	u32 cmgr_returnValue;
	int timer;
	int variation;

	/******/
	/*Frog*/
	/******/
	m3d::anmChr_c animationChr;
	m3d::mdl_c coinModel;
	m3d::anmChr_c animationCoinChr;
	mMtx coinmatrix;
	VEC3 coinscale;
	S16Vec coinrot;
	bool doIhaveCoin;
	bool isCoinSpawned;

	dStageActor_c *content;

	static dActor_c* build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate, bool isCoin);

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);

	USING_STATES(daSuperBubble_c);
	DECLARE_STATE(Bubble_Thrown);
};

const SpriteData SuperBubbleSpriteData = { ProfileId::SuperBubble, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile SuperBubbleProfile(&daSuperBubble_c::build, SpriteId::SuperBubble, SuperBubbleSpriteData, ProfileId::SuperBubble, ProfileId::SuperBubble, "SuperBubble", SuperBubbleFileList);


CREATE_STATE(daSuperBubble_c, Bubble_Thrown);


void daSuperBubble_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	int pid = getNybbleValue(apOther->owner->which_player, 6, 6);
	int coinsettings = 0 | (0x2 << 0) | (2 << 18) | (4 << 9) | (2 << 10) | ((pid + 8) << 16);
	VEC3 newPos = {this->pos.x, this->pos.y - 16, this->pos.z};
	dStageActor_c *coin = dStageActor_c::create(EN_ITEM, coinsettings, &newPos, 0, 0);
	PlaySound(this, SE_OBJ_GET_COIN);
	PlaySound(this, SE_OBJ_CMN_BALLOON_BREAK);
	Vec efPos = {this->pos.x, this->pos.y, this->pos.z};
	S16Vec nullRot = {0,0,0};
	Vec oneVec = {1.0f, 1.0f, 1.0f};
	SpawnEffect("Wm_mr_balloonburst", 0, &efPos, &nullRot, &oneVec);
	this->Delete(1);
}
void daSuperBubble_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {

}
bool daSuperBubble_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daSuperBubble_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daSuperBubble_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daSuperBubble_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daSuperBubble_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daSuperBubble_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daSuperBubble_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daSuperBubble_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daSuperBubble_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daSuperBubble_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daSuperBubble_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daSuperBubble_c));
	daSuperBubble_c* c = new(buffer) daSuperBubble_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

void daSuperBubble_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate, bool isCoin) {
	if(!isCoin) {
		nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
		this->animationChr.bind(&this->bodyModel, anmChr, unk);
		this->bodyModel.bindAnim(&this->animationChr, unk2);
		this->animationChr.setUpdateRate(rate);
	}
	else {
		nw4r::g3d::ResAnmChr anmCoinChr = this->resFile.GetResAnmChr(name);
		this->animationCoinChr.bind(&this->coinModel, anmCoinChr, unk);
		this->coinModel.bindAnim(&this->animationCoinChr, unk2);
		this->animationCoinChr.setUpdateRate(rate);
	}
}

int daSuperBubble_c::onCreate() {
	this->deleteForever = true;

	OSReport("0\n");
	
	//OSReport("Nybble 1-2: %x\n", this->eventId2);
	//OSReport("Nybble 3-4: %x\n", this->eventId1);
	OSReport("spriteFlagMask: %x\n", (u32)(this->spriteFlagMask >> 32));
	OSReport("spriteFlagMask: %x\n", (u32)this->spriteFlagMask);

	// Model creation
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("frogM", "g3d/balloon.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("balloon");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);

	OSReport("1\n");

	nw4r::g3d::ResMdl coinmdl = this->resFile.GetResMdl("obj_coin");
	coinModel.setup(coinmdl, &allocator, 0x224, 1, 0);
	SetupTextures_MapObj(&coinModel, 0);

	OSReport("2\n");

	bool ret;
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("float");
	ret = this->animationChr.setup(mdl, anmChr, &this->allocator, 0);

	OSReport("3\n");

	bool rett;
	nw4r::g3d::ResAnmChr anmCoinChr = this->resFile.GetResAnmChr("no");
	rett = this->animationCoinChr.setup(coinmdl, anmCoinChr, &this->allocator, 0);

	OSReport("4\n");

	allocator.unlink();

	Vec tempPos = (Vec){this->pos.x, this->pos.y, this->pos.z};
	content = CreateActor(EN_ITEM, 0xA, tempPos, 0, 0);

	// Stuff I do understand
	this->scale = (Vec){0.6, 0.6, 0.6};
	this->coinscale = (Vec){1.0, 1.0, 1.0};

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;
	this->direction = (this->settings >> 8) & 0xF; // Heading where the player look.
	this->speed.x = (this->direction == 1) ? -5 : 5;
	this->x_speed_inc = 0.1;

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0x8028E;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	// this->pos.y += 16;
	// this->pos.z = 9000;

	OSReport("5\n");

	bindAnimChr_and_setUpdateRate("float", 1, 0.0, 1.0, false);
	bindAnimChr_and_setUpdateRate("no", 1, 0.0, 1.0, true);

	OSReport("6\n");

	doStateChange(&StateID_Bubble_Thrown);

	OSReport("7\n");

	this->onExecute();

	OSReport("8\n");

	return true;
}


int daSuperBubble_c::onDelete() {
	return true;
}

int daSuperBubble_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daSuperBubble_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);
	coinmatrix.translation(pos.x, pos.y, pos.z);
	coinmatrix.applyRotationYXZ(&coinrot.x, &coinrot.y, &coinrot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
	coinModel.setDrawMatrix(coinmatrix);
	coinModel.setScale(&coinscale);
	coinModel.calcWorld(false);
	
	content->pos = this->pos;
}

int daSuperBubble_c::onExecute() {
	
	//OSReport("Nybble 1-2: %x\n", this->eventId2);
	//OSReport("Nybble 3-4: %x\n", this->eventId1);
	OSReport("spriteFlagMask: %x\n", (u32)(this->spriteFlagMask >> 32));
	OSReport("spriteFlagMask: %x\n", (u32)this->spriteFlagMask);
	coinModel._vf1C();
	bodyModel._vf1C();
	updateModelMatrices();
	this->timer++;

	if(this->doIhaveCoin && !this->isCoinSpawned) {
		bindAnimChr_and_setUpdateRate("yes", 1, 0.0, 1.0, true);
		this->isCoinSpawned = true;
	}

	if(this->animationChr.isAnimationDone()) {
		this->animationChr.setCurrentFrame(0.0);
	}
	if(this->animationCoinChr.isAnimationDone()) {
		this->animationCoinChr.setCurrentFrame(0.0);
	}

	if(this->timer > 300) {
		PlaySound(this, SE_OBJ_CMN_BALLOON_BREAK);
		Vec efPos = {this->pos.x, this->pos.y, this->pos.z};
		S16Vec nullRot = {0,0,0};
		Vec oneVec = {1.0f, 1.0f, 1.0f};
		SpawnEffect("Wm_mr_balloonburst", 0, &efPos, &nullRot, &oneVec);
		this->Delete(1);
	}

	this->pos.y += 0.1;
	this->coinrot.y += 0x400;



	for (int i = 0; i < 4; i++) {
		daPlBase_c *player = GetPlayerOrYoshi(i);
		if (player) {
			//player->setFlag(0x71);
			dPlayerModelHandler_c *pmh = (dPlayerModelHandler_c*)(((u32)player) + 0x2A60);
			pmh->mdlClass->startAnimation(132, 1.0f, 0.0f, 0.0f);
			pmh->mdlClass->enableStarColours();
			pmh->mdlClass->enableStarEffects();
		}
	}
}




void daSuperBubble_c::beginState_Bubble_Thrown() {

}

void daSuperBubble_c::executeState_Bubble_Thrown() {
	HandleXSpeed();
	doSpriteMovement();
	if(this->direction == 1) {
		if(this->speed.x > 0) {
			this->speed.x = 0;
			this->x_speed_inc = 0;
		}
	}
	if(this->direction == 0) {
		if(this->speed.x < 0) {
			this->speed.x = 0;
			this->x_speed_inc = 0;
		}
	}
}

void daSuperBubble_c::endState_Bubble_Thrown() {

}
//
// processed\../src/bossPlayerClown.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include "boss.h"

// #define cField(TYPE, OFFSET) (*(TYPE*)(((u32)clown) + (OFFSET)))
// #define cPlayerOccupying cField(dStageActor_c*, 0x738)
// #define cModel cField(m3d::mdl_c*, 0xFEC)
// #define cTimer cField(u32, 0xFEC+sizeof(m3d::mdl_c))
// #define cAllocator cField(mHeapAllocator_c*, 0xFD0)

#define cPlayerOccupying (*(dStageActor_c**)(((u32)(clown)) + 0x738 ))
#define cAllocator ((mHeapAllocator_c*)(((u32)(clown)) + 0xFD0 ))
#define cModel ((m3d::mdl_c*)( ((u32)(clown)) + 0xFEC ))
#define cTimer (*(u32*)((u32)(clown) + sizeof(m3d::mdl_c) + 0xFEC ))

extern "C" int PClownCarExecute(dEn_c *clown);
extern "C" void PClownCarAfterCreate(dEn_c *clown, u32);
extern "C" int PClownCarDraw(dEn_c *clown);
extern "C" void PClownCarMove(dEn_c *clown);


const char* PCCarcNameList [] = {
	"koopaJr_clown_ply",
	NULL
};



int CConDraw(dEn_c *clown) {
	// setup cannon model
	clown->matrix.translation(clown->pos.x, clown->pos.y + 8.0, clown->pos.z-100.0);
	short newrotz = -0x2000;
	short newroty = ((clown->rot.y * 0x4000) / 0x800) - 0x4000;
	short newrotx;
	if (clown->rot.x < 0x8000) {
		newrotx = -clown->rot.x;
	}
	else {
		newrotx = clown->rot.x;
	}
	// OSReport("Angle?: %x, %x", clown->rot.y, newroty);
	clown->matrix.applyRotationYXZ(&clown->rot.x, &newroty, &newrotz);

	cModel->setDrawMatrix(clown->matrix);
	if(clown->settings >> 4 & 1) {
		cModel->setScale(&(Vec){0.25, 0.5, 0.25});
	} else {
		cModel->setScale(&(Vec){0.0, 0.0, 0.0});
	}
	cModel->calcWorld(false);

	cModel->scheduleForDrawing();


	return PClownCarDraw(clown);
	// run normal clown function
}
extern dStateBase_c JrClownEndDemoState;
extern dStateBase_c JrClownDemoWaitState;
extern dStateBase_c ClownDemoWaitState;

int CConExecute(dEn_c *clown) {
	// A REALLY TERRIBLE HACK.
	float saveX = clown->pos.x;
	float saveY = clown->pos.y;

	int ret = PClownCarExecute(clown);

	dStateBase_c *state = clown->acState.getCurrentState();
	if (state == &JrClownEndDemoState || state == &JrClownDemoWaitState || state == &ClownDemoWaitState) {
		clown->pos.x = saveX;
		clown->pos.y = saveY;
		clown->speed.x = 0.0f;
		clown->speed.y = 0.0f;
	}
}

void CCafterCreate(dEn_c *clown, u32 param) {

	clown->scale.x *= 1.25;
	clown->scale.y *= 1.25;
	clown->scale.z *= 1.25;

	// setup the model
	nw4r::g3d::ResFile resFile;

	cAllocator->link(-1, GameHeaps[0], 0, 0x20);

	resFile.data = getResource("koopaJr_clown_ply", "g3d/cannon.brres");
	nw4r::g3d::ResMdl mdl = resFile.GetResMdl("Cannon");
	cModel->setup(mdl, cAllocator, 0x224, 1, 0);
	SetupTextures_MapObj(cModel, 0);

	cAllocator->unlink();

	// Original AfterCreate
	PClownCarAfterCreate(clown, param);

	int playerCount = 0;
	for (int i = 0; i < 4; i++)
		if (Player_Active[i])
			playerCount++;

	if ((clown->settings & 0xF) != 0) {
		int playerID = (clown->settings & 0xF) - 1;
		if (playerID >= playerCount)
			clown->Delete(1);
	}
}

void CConExecuteMove(dEn_c *clown) {
	if(clown->settings >> 4 & 1) {

		u8 player = cPlayerOccupying->which_player;
		// OSReport("Angle = %x, %x, %x", (GetSpecificPlayerActor(player))->rot.y, (GetSpecificPlayerActor(player))->rot.x, (GetSpecificPlayerActor(player))->rot.z);
		// OSReport("Clown = %x, %x, %x", (clown)->rot.y, (clown)->rot.x, (clown)->rot.z);

		Vec tempPos;
		
		u32 buttonPushed = Remocon_GetPressed(GetRemoconMng()->controllers[cPlayerOccupying->which_player]);
		if (buttonPushed & 0x0100) {

			if (cTimer > 90) {
				if (clown->direction == 0) { // Going right
					tempPos = (Vec){clown->pos.x + 32.0, clown->pos.y + 32.0, 3564.0};
					//dStageActor_c *spawned = CreateActor(657, 0, tempPos, 0, 0);
					//spawned->speed.x = 5.0;
				}
				else {
					tempPos = (Vec){clown->pos.x - 32.0, clown->pos.y + 32.0, 3564.0};
					//dStageActor_c *spawned = CreateActor(657, 0, tempPos, 0, 0);
					//spawned->speed.x = -5.0;
				}

				SpawnEffect("Wm_en_killervanish", 0, &tempPos, &(S16Vec){0,0,0}, &(Vec){0.1, 0.1, 0.1});
				nw4r::snd::SoundHandle handle;
				PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_OBJ_HOUDAI_S_SHOT, 1);

			cTimer = 0;
			}
		}

		cTimer++;

		ClassWithCameraInfo *cwci = ClassWithCameraInfo::instance;
		float leftBound = cwci->screenLeft + 12.0f;
		float rightBound = (cwci->screenLeft + cwci->screenWidth) - 12.0f;
		if (clown->pos.x < leftBound)
			clown->pos.x = leftBound;
		if (clown->pos.x > rightBound)
			clown->pos.x = rightBound;
	}

	// run normal move
	PClownCarMove(clown);
}


extern "C" m3d::mdl_c *__ct__Q23m3d5mdl_cFv(m3d::mdl_c *mdl);
extern "C" mHeapAllocator_c *__ct__16mHeapAllocator_cFv(mHeapAllocator_c *al);
extern "C" dEn_c *__ct__20daJrClownForPlayer_cFv(dEn_c *clown);

dEn_c *newClownCtor(dEn_c *clown) {
	__ct__20daJrClownForPlayer_cFv(clown);
	__ct__16mHeapAllocator_cFv(cAllocator);
	__ct__Q23m3d5mdl_cFv(cModel);
	return clown;
}


extern "C" void __dt__Q23m3d5mdl_cFv(m3d::mdl_c *mdl, u32 willDelete);
extern "C" void __dt__16mHeapAllocator_cFv(mHeapAllocator_c *al, u32 willDelete);
extern "C" void __dt__20daJrClownForPlayer_cFv(dEn_c *clown, u32 willDelete);

extern "C" u32 sAllocatorFunc__FrmHeap;

void newClownDtor(dEn_c *clown, u32 willDelete) {
	void **al = (void **)(((u32)clown) + 0x524);
	if (*al != &sAllocatorFunc__FrmHeap) {
		OSReport("oh no! bad allocator %p\n", *al);
		*al = &sAllocatorFunc__FrmHeap;
	}

	__dt__Q23m3d5mdl_cFv(cModel, 0xFFFFFFFF);
	__dt__16mHeapAllocator_cFv(cAllocator, 0xFFFFFFFF);
	__dt__20daJrClownForPlayer_cFv(clown, willDelete);
}

extern "C" void JrClownForPlayer_playAccelSound() {
	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_PLY_CROWN_ACC, 1);
}
//
// processed\../src/BlockAnim.cpp
//


/**
 * This function is called when the game needs to
 * determine the block type when a tileset block
 * is hit.
 *
 * Return value is:
 * 0 -> Question block/default
 * 1 -> Brick block
 * 2 -> Breaking brick block
 * 3 -> Unused -> Question
 * 4 -> Invisible block
 *
 * Because of further functions, output gets distorted
 *
 * Original function maps
 * 0x31->0, 0x30->1, 0x32->2, 0..10->4, 13->4, other -> 0
 */
int dBlockMgr_c_getBlockType(int dBlockMgr_c_instance, int tilenum) {
    if (tilenum == 0x31) {
        return 0;
    }

    if (tilenum == 0x30) {
        return 1;
    }

    if (tilenum == 0x32) {
        return 2;
    }

    // additions for Zement
	
    if (tilenum - 3 <= 7 || tilenum == 0x0D) {
        return 0; // Colored !-blocks
    }

    if (tilenum == 0xF0 || tilenum == 0xF1 || tilenum == 0xF2 || tilenum == 0xF3) {
        return 1; // Additional Brick Blocks. Also sets nybble 6 to 8 because overflow. Was originally "return 1 | 1 << 22;"
    }

    return 0;
}

//
// processed\../src/goalPole.cpp
//

#include <common.h>
#include <game.h>
#include "daEnGlPole_c.h"

void daEnGlpole_c_initInvisibleWallIfSet(ActivePhysics* wallPhysics, daEnGlpole_c* this_, ActivePhysics::Info * argument) {
    if (((this_->settings >> 4) & 1) == 0) {
        wallPhysics->initWithStruct(this_, (ActivePhysics::Info *) argument);
    }
}

//
// processed\../src/yoshiFly.cpp
//

// #include <common.h>
// #include <game.h>
// #include <g3dhax.h>
// #include <daYoshi_c.h>
// #include "yoshiFly.h"

// extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

// dYoshiWingsRenderer_c *dYoshiWingsRenderer_c::build() {
// 	return new dYoshiWingsRenderer_c;
// }

// dYoshiWingsRenderer_c::dYoshiWingsRenderer_c() { } dYoshiWingsRenderer_c::~dYoshiWingsRenderer_c() {
// }

// void dYoshiWingsRenderer_c::setup(dPlayerModelHandler_c *handler) {
// 	setup(handler, 0);
// }

// void dYoshiWingsRenderer_c::setup(dPlayerModelHandler_c *handler, int sceneID) {
// 	OSReport("Starting setup\n");
// 	yoshi = (dPlayerModel_c*)handler->mdlClass;

// 	allocator.link(-1, GameHeaps[0], 0, 0x20);

// 	nw4r::g3d::ResFile rf(getResource("Y_TexGreen", "g3d/wing.brres"));

// 	nw4r::g3d::ResMdl rm = rf.GetResMdl("wing");
// 	wings.setup(rm, &allocator, 0, 1, 0);
// 	SetupTextures_Enemy(&wings, sceneID);

// 	allocator.unlink();


// 	yoshiModel = &yoshi->models[0].body;
// 	nw4r::g3d::ResMdl *yoshiResMdl =
// 		(nw4r::g3d::ResMdl*)(((u32)yoshiModel->scnObj) + 0xE8);


// 	nw4r::g3d::ResNode spin = yoshiResMdl->GetResNode("spin");
// 	spinNodeID = spin.GetID();
// 	OSReport("Ending setup\n");
// }

// void dYoshiWingsRenderer_c::draw() {
// 	OSReport("Starting draw\n");
// 	daYoshi_c *CuteYoshi = dAcPy_c::findByID(yoshi->player_id_1)->getYoshi();
// 	if (!(getNybbleValue(CuteYoshi->settings, 12, 12) == 4 && getNybbleValue(CuteYoshi->settings, 5, 5) == 1))
// 		return;

// 	Mtx rootMtx;
// 	yoshiModel->getMatrixForNode(spinNodeID, &rootMtx);

// 	wings.setDrawMatrix(&rootMtx);
// 	wings.setScale(1.0f, 1.0f, 1.0f);
// 	wings.calcWorld(false);

// 	wings.scheduleForDrawing();
// 	OSReport("Ending draw\n");
// }



#include <common.h>
#include <game.h>
#include <profile.h>
#include <daYoshi_c.h>

const char *YoshiWingsFileList[] = {"Y_TexGreen", 0};


class daEnYoshiWings_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c animationChr;

	daYoshi_c *CuteYoshi;

	static dActor_c *build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
};

const SpriteData YoshiWingsSpriteData = { ProfileId::EN_YOSHIWINGS, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile YoshiWingsProfile(&daEnYoshiWings_c::build, SpriteId::EN_YOSHIWINGS, YoshiWingsSpriteData, ProfileId::EN_YOSHIWINGS, ProfileId::EN_YOSHIWINGS, "daEnYoshiWings_c", YoshiWingsFileList);



u8 hijackMusicWithSongName(const char *songName, int themeID, bool hasFast, int channelCount, int trackCount, int *wantRealStreamID);

void daEnYoshiWings_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
}
void daEnYoshiWings_c::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
}
bool daEnYoshiWings_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnYoshiWings_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnYoshiWings_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnYoshiWings_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}

bool daEnYoshiWings_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnYoshiWings_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {

	return false;
}
bool daEnYoshiWings_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {

	return false;
}
bool daEnYoshiWings_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnYoshiWings_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}

bool daEnYoshiWings_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}


dActor_c *daEnYoshiWings_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daEnYoshiWings_c));
	daEnYoshiWings_c *c = new(buffer) daEnYoshiWings_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

int daEnYoshiWings_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("Y_TexGreen", "g3d/wing.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("wing");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);

	bool ret;
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("wing_pata");
	ret = this->animationChr.setup(mdl, anmChr, &this->allocator, 0);
	this->animationChr.bind(&this->bodyModel, anmChr, 1);
	this->bodyModel.bindAnim(&this->animationChr, 0);
	this->animationChr.setUpdateRate(1.0);

	allocator.unlink();

	// ActivePhysics::Info HitMeBaby;

	// HitMeBaby.xDistToCenter = 0.0;
	// HitMeBaby.yDistToCenter = 0.0;

	// HitMeBaby.xDistToEdge = 7.5;
	// HitMeBaby.yDistToEdge = 7.5;

	// HitMeBaby.category1 = 0x3;
	// HitMeBaby.category2 = 0x0;
	// HitMeBaby.bitfield1 = 0x6F;
	// HitMeBaby.bitfield2 = 0xffbafffe;
	// HitMeBaby.unkShort1C = 0;
	// HitMeBaby.callback = &dEn_c::collisionCallback;

	// this->aPhysics.initWithStruct(this, &HitMeBaby);
	// this->aPhysics.addToList();

	// Stuff I do understand
	CuteYoshi = (daYoshi_c *)Actor_SearchByID(this->settings);

	this->scale = (Vec){1.0, 1.0, 1.0};

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;

	this->pos.z = 4000;


	this->onExecute();
	return true;
}


int daEnYoshiWings_c::onDelete() {
	return true;
}

int daEnYoshiWings_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}

// extern nw4r::g3d::ResMdl *yoshiResMDL;
void daEnYoshiWings_c::updateModelMatrices() {
	// dPlayerModel_c *yoshi = (dPlayerModel_c*)(CuteYoshi->modelhandler->mdlClass);
	// m3d::mdl_c *yoshiModel = &yoshi->models[0].body;
	// // nw4r::g3d::ResMdl *yoshiResMdl =
	// // 	(nw4r::g3d::ResMdl*)(((u32)yoshiModel->scnObj) + 0xE8);


	// nw4r::g3d::ResNode spin = yoshiResMDL->GetResNode("skl_root");
	// u32 spinNodeID = spin.GetID();

	// Mtx rootMtx;
	// yoshiModel->getMatrixForNode(spinNodeID, &rootMtx);

	matrix.translation(CuteYoshi->pos.x + ((CuteYoshi->direction) ? -4 : 4), CuteYoshi->pos.y + 11, CuteYoshi->pos.z + 5);
	matrix.applyRotationYXZ(&CuteYoshi->rot.x, &CuteYoshi->rot.y, &CuteYoshi->rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);

}

int daEnYoshiWings_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();
	if(CuteYoshi->input.getHeldTwo()) {
		this->animationChr.setUpdateRate(1.0);
	}
	else {
		this->animationChr.setUpdateRate(0.0);
	}

	if(this->animationChr.isAnimationDone()) {
		this->animationChr.setCurrentFrame(0.0);
	}

	return true;
}
//
// processed\../src/yoshiCourage.cpp
//

#include <game.h>
#include <actors.h>

void doStarEffect(daYoshi_c* yoshi) {
	//OSReport("somePlayerID: %d\n", somePlayerID);
	OSReport("Yoshi: %p\n", yoshi);
	dAcPy_c *player;
	for (int i = 0; i < 4; i++) {
		if (player = dAcPy_c::findByID(i)) {
			if(player->getYoshi() == yoshi) {
				goto found;
			}
		}
	}
	return;
	found:
	dPlayerModelHandler_c *pmh = (dPlayerModelHandler_c*)(((u32)player) + 0x2A60);
    //pmh->mdlClass->startAnimation(132, 1.0f, 0.0f, 0.0f);
	pmh->mdlClass->enableStarEffects();
	//pmh->mdlClass->enableStarColours();
}
//
// processed\../src/yoshiStomp.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include "yoshiquick.h"

int blueTime = 720;			//Time on which blue yoshi keeps a shell in his mouth if he ate one
int yellowTime = 960;		  //Time on which yellow yoshi keeps a shell in his mouth if he ate one
int doneRefreshingJauges;		//Global variable for the gameScene. For some reasons, making it a bool crashes the game

extern "C" float pow(float num, float power);

/*int getNybbleValue(u32 settings, int fromNybble, int toNybble) {	//This function is to get a nybble from a sprite's settings. It's probably more optimized to do the shifts and the AND by hand, but i prefer to prioritise the reading than the optimization:
	int numberOfNybble = (toNybble  - fromNybble) + 1;				//-Gets how many nybbles are used for the process (example: nybbles 4-6 -> there's nybbles 4, 5 and 6 used -> numberOfNybble = 3) 
	int valueToUse = 48 - (4 * toNybble);							//-Gets the value to use with the bitshift at the end 
	int fShit = pow(16, numberOfNybble) - 1;						//-Gets the value to use with the "&" operator at the end
	return ((settings >> valueToUse) & fShit);						//-Uses everything to make the nybble value, and return it
}*/

/*class dGameDisplay_c : dBase_c {	//The gameScene layout's class
	public:
		m2d::EmbedLayout_c layout;
		mEf::es2 effect;
		u32 _330;
		u32 _334;
		u32 _338;
		u32 _33C;
		u32 _340;
		u32 _344;
		u32 _348;
		u32 _34C;
		u32 _350;
		u32 _354;
		u32 _358;
		u32 _35C;
		u32 _360;
		u32 _364;
		u32 _368;
		u32 _36C;
		u32 _370;
		u32 _374;
		u32 _378;
		u32 _37C;
		u32 _380;
		u32 _384;
		u32 _388;
		u32 _38C;
		u32 _390;
		u32 _394;
		u32 _398;
		u32 _39C;
		u32 _3A0;
		u32 _3A4;
		dStateMgr_c state;
		u32 _3CC;
		u32 _3D0;
		u32 _3D4;
		u32 _3D8;
		u32 coins;
		u32 timer;
		u32 _3E4;
		u32 score;
		u32 _3EC;
		u32 _3F0;
		u32 _3F4;
		u32 _3F8;
		u32 _3FC;
		u32 _400;
		u32 _404;
		u32 _408;
		u32 _40C;
		u32 _410;
		u32 _414;
		u32 _418;
		u32 _41C;
		u32 _420;
		u32 _424;
		u32 _428;
		u32 _42C;
		u32 _430;
		u32 mustAtLeast2ForScoreToCount;
		u32 _438;
		u32 _43C;
		u32 _440;
		u32 _444;
		u8 _448;
		u8 _449;
		u8 _44A;
		u8 _44B;
		u32 _44C;
		u8 _450;
		u8 _451;
		u8 _452;
		u8 _453;
		u8 _454;
		u8 _455;
		u8 _456;
		u8 _457;
		u32 _458;
		u32 _45C;
		u32 _460;
		u32 _464;
		u32 _468;
		u32 _46C;
		u32 _470;
		u32 _474;
		u32 _478;
		u32 _47C;
		u32 _480;
		u32 _484;
		u32 _488;
		u32 _48C;
		u32 _490;
		nw4r::lyt::Picture* p_collectOff_00;
		nw4r::lyt::Picture* p_collection_00;
		nw4r::lyt::Picture* p_collectOff_01;
		nw4r::lyt::Picture* p_collection_01;
		nw4r::lyt::Picture* p_collectOff_02;
		nw4r::lyt::Picture* p_collection_02;
		nw4r::lyt::Picture* p_marioIcon_00;
		nw4r::lyt::Picture* p_luijiIcon_00;
		nw4r::lyt::Picture* p_kinoB_00;
		nw4r::lyt::Picture* p_kinoY_00;
		u32 _4BC;
		u32 _4C0;
		u32 _4C4;
		u32 _4C8;
		u32 _4CC;
		u32 _4D0;
		u32 _4D4;
		u32 _4D8;
		nw4r::lyt::TextBox* coinBox;
		nw4r::lyt::TextBox* timerBox;
		nw4r::lyt::TextBox* scoreBox;
		u32 _4E8;
		u32 _4EC;
		u32 _4F0;
		u32 _4F4;
		u8  _4F8;
		void* StarCoin1;
		void* StarCoin2;
		void* StarCoin3;
		u8  _505;
		u8  _506;
		u8  _507;
		u8 blob1[0x51C - 0x508];
		u32 _51C;
		u8 blob2[0x5A0 - 0x508];
		u32 _5A0;
	   
		static dGameDisplay_c* instance;
		int onCreate_orig();
		int onExecute_orig();
		int newOnCreate();
		int newOnExecute();
};*/
/*
int dGameDisplay_c::newOnCreate() {
	int orig_val = this->onCreate_orig();	//Execute the original onCreate

	doneRefreshingJauges = 0;				//Setting the jauge refreshing trigger to 0 (false) [for some reasons, hiding the jauges here crashes, so doing it in the onExecute using this value to only do it once]

	return orig_val;						//Return the original onCreate
}

int dGameDisplay_c::newOnExecute() {
	int orig_val = this->onExecute_orig();									//Execute the original onExecute

	if(!doneRefreshingJauges) {												//If the jauge refreshing wasn't done yet:
		nw4r::lyt::Picture *jaugeCast;										//-Create the jauge cast pointer
		nw4r::lyt::Picture *jaugeYellow;									//-Create the yellow jauge pointer
		nw4r::lyt::Picture *jaugeBlue;										//-Create the blue jauge pointer

		jaugeCast = this->layout.findPictureByName("P_jaugeCast_00");		//-Store the jauge cast
		jaugeYellow = this->layout.findPictureByName("P_yellowJauge_00");	//-Store the yellow jauge
		jaugeBlue = this->layout.findPictureByName("P_blueJauge_00");		//-Store the blue jauge

		jaugeCast->SetVisible(false);										//-Make the jauge cast invisible
		jaugeYellow->SetVisible(false);										//-Make the yellow jauge invisible
		jaugeBlue->SetVisible(false);										//-Make the blue jauge invisible
		doneRefreshingJauges = 1;											//-Set the "are we done refreshing the jauges" to true
	}

	return orig_val;														//Return the original onExecute
}

void showJauges(bool isYellow) {
	nw4r::lyt::Picture *jaugeCast = dGameDisplay_c::instance->layout.findPictureByName("P_jaugeCast_00");										//Store the jauge cast
	nw4r::lyt::Picture *jaugeColor = dGameDisplay_c::instance->layout.findPictureByName(((isYellow) ? "P_yellowJauge_00" : "P_blueJauge_00"));	//Store the correct jauge
	jaugeCast->SetVisible(true);																												//Make the jauge cast invisible
	jaugeColor->SetVisible(true);																												//Make the correct jauge invisible
}

void hideJauges() {
	nw4r::lyt::Picture *jaugeCast = dGameDisplay_c::instance->layout.findPictureByName("P_jaugeCast_00");		//Store the jauge cast
	nw4r::lyt::Picture *jaugeYellow = dGameDisplay_c::instance->layout.findPictureByName("P_yellowJauge_00");	//Store the yellow jauge
	nw4r::lyt::Picture *jaugeBlue = dGameDisplay_c::instance->layout.findPictureByName("P_blueJauge_00");		//Store the blue jauge
	jaugeCast->SetVisible(false);																				//Make the jauge cast invisible
	jaugeYellow->SetVisible(false);																				//Make the yellow jauge invisible
	jaugeBlue->SetVisible(false);																				//Make the blue jauge invisible
}*/

int daYoshi2_c::newOnExecute() { //demoStateTracker (1418), states2 (1464)
	/*******************************/
	/*Execute the original onCreate*/
	/*******************************/
	int orig_val = this->onExecute_orig();

	/*****************/
	/*State Debugging*/
	/*****************/
	/*nw4r::lyt::TextBox *stateText = dGameDisplay_c::instance->layout.findTextBoxByName("T_state_00");	//Store the debugging TextBox Pane in stateText

	wchar_t stupidTextW[100];																			//Make a wchar_t to store the future state name
	const char *stupidText = this->states2.getCurrentState()->getName();								//Get the current state as a const char*
	int charCount = 0;																					//Create the current char count
	
	while (*stupidText != 0 && charCount < 99) {														//Convert the const char* to the wchar_t:
		stupidTextW[charCount] = *stupidText;															//-Set the current char from the wchar_t to the one from the const char*
		stupidText++;																					//-Increment the const char* count
		charCount++;																					//-Increment the current char count
	}																									//-Repeat the process until all the chars from 0 to 98 is converted
	stupidTextW[charCount] = 0;																			//-Set the last char (99) of the wchar_t to 0

	stateText->SetString(stupidTextW);																	//Insert the wchar_t into the debugging TextBox Pane (stateText)

	/*****************/
	/*Jauges Updating*/
	/*****************/
	/*nw4r::lyt::Picture *shellJauge = dGameDisplay_c::instance->layout.findPictureByName((getNybbleValue(this->settings, 12, 12) == 2) ? "P_yellowJauge_00" : "P_blueJauge_00"); //Store the Picture Pane of the jauge to use in shellJauge
	*/
	u32 color = getNybbleValue(this->settings, 12, 12);
	if(getNybbleValue(this->settings, 5, 5)) {							//If nybble 5 (is there a shell in yoshi's mouth) is triggered, then:
		if(!this->isTimerEnabled) {										//-If the swallow timer isn't enabled yet:
			this->isTimerEnabled = true;								//--Enable it
			S16Vec nullRot = {0,0,0};
			if(color == 4 || color == 7) {
				dStageActor_c *wings = create(EN_YOSHIWINGS, this->id, &this->pos, &nullRot, 0);
				this->wingID = wings->id;
			}
		}
		if(!this->doOneTime) {											//-If not done yet:
			//showJauges((getNybbleValue(this->settings, 12, 12) == 2));	//--Show the correct jauge depending of yoshi's color (yellow or blue)
			this->swallowTimer = ((color == 2 || color == 3) ? yellowTime : blueTime);						//--Set the time before swallowing the shell
			//shellJauge->size.y = 49.0;									//--Set the correct jauge's maximum scale
			this->doOneTime = true;										//--Set the check to "done"
		}
	}
	else {																//Otherwise:
		if(this->isTimerEnabled) {										//-If the swallow timer is enabled:
			this->isTimerEnabled = false;								//--Disable it
			this->doOneTime = false;									//--Set the check to "not done yet"
			if(color == 4 || color == 7) {
				Actor_SearchByID(this->wingID)->Delete(1);
			}
			//hideJauges();												//--Hide the jauges
		}
	}

	if(this->isTimerEnabled && this->swallowTimer > 0) {				//If the swallow timer is enabled and the swallow timer is greater than 0:
		this->swallowTimer--;											//-Decrease the swallow timer by 1
		//shellJauge->size.y -= (49.0f / ((getNybbleValue(this->settings, 12, 12) == 2) ? yellowTime : blueTime));				//-Decrease the correct jauge's Y Scale by its rate (its maximum scale divided by the waiting frames until swallowing the shell)
	}
	if(this->isTimerEnabled && this->swallowTimer <= 0) {				//If the swallow timer is enabled and the swallow timer is less or equal to 0:
		this->eatenID = 0;												//-Remove the current eaten shell from yoshi's mouth
		this->settings ^= 0x10000000;									//-Untrigger nybble 5 (is there a shell in yoshi's mouth)
	}

	/**************************************/
	/*Return the original onCreate's value*/
	/**************************************/
	return orig_val;
}

void daYoshi2_c::newEndState_HipAttack() {
	endState_HipAttack_orig();	//Execute the original endState_HipAttack
	this->doneGP = false;		//Untrigger the groundpounding check
}

extern void ewhipAttackStage4();
void daPlBase_c::newHipAttackStage4() {
	ewhipAttackStage4();																												//Execute the original hipAttackStage4
	// OSReport("hipAttackStage4 %08X\n", this->which_player);																			//Debugging
	daYoshi2_c *CuteYoshi = (daYoshi2_c*)dAcPy_c::findByID(this->which_player)->getYoshi();															//Get the current yoshi
	// OSReport("meh %08X\n", CuteYoshi->settings);																						//Debugging
	if(CuteYoshi->settings != 0) {																										//If its settings aren't null (so the yoshi exists):
		u32 color = getNybbleValue(CuteYoshi->settings, 12, 12);
		if((color == 2 || color == 3) && getNybbleValue(CuteYoshi->settings, 5, 5) && !CuteYoshi->doneGP) {								//-If this yoshi is yellow or green, has a shell in his mouth and the groundpounding check isn't triggered:
			S16Vec nullRot = {0,0,0};																									//--Set the ongoing effect's rotation to 0 on all axes
			VEC3 vecOne = {0.2f, 0.2f, 0.2f};																							//--Set the ongoing effect's scale to 0.2 on all axes
			SpawnEffect("Wm_ob_powdown_ind", 0, &CuteYoshi->pos, &nullRot, &vecOne);													//--Create a POW effect with the rotation and scale from above
			nw4r::snd::SoundHandle powHandle;																							//--Create a SoundHandle for the ongoing SFX
			PlaySoundWithFunctionB4(SoundRelatedClass, &powHandle, SE_OBJ_POW_BLOCK_QUAKE, 1);											//--Play a POW SFX in the above SoundHandle
	
			dActor_c *iter = 0;																											//--Create an actor pointer
			while(iter = (dActor_c*)dActor_c::searchByBaseType(2, iter)) {																//--For every actor found by the searchByBaseType function:
				dEn_c *sa = (dEn_c*)iter;																								//---Convert it to a dStageActor_c
	
				if((sa->name == EN_KURIBO || sa->name == EN_PATA_KURIBO ||																//---If it's a goomba, or a paragoomba,
					sa->name == EN_NOKONOKO || sa->name == EN_PATAPATA ||																//---or a koopa, or a parakoopa,
					sa->name == EN_MET || sa->name == EN_TOGEZO || sa->name == EN_SAKASA_TOGEZO ||										//---or a buzzy beetle, or a spiny, or an upside-down spiny,
					sa->name == EN_JIMEN_PAKKUN || sa->name == EN_UP_DOKAN_PAKKUN ||													//---or a piranha plant, or an UPPipe piranha plant,
					sa->name == EN_DOWN_DOKAN_PAKKUN || sa->name == EN_RIGHT_DOKAN_PAKKUN ||											//---or a DOWNPipe piranha plant, or a RIGHTPipe piranha plant,
					sa->name == EN_LEFT_DOKAN_PAKKUN || sa->name == EN_UP_DOKAN_FPAKKUN ||												//---or a LEFTPipe piranha plant, or an UPPipe fire piranha plant,
					sa->name == EN_DOWN_DOKAN_FPAKKUN || sa->name == EN_RIGHT_DOKAN_FPAKKUN ||											//---or a DOWNPipe fire piranha plant, or a RIGHTPipe fire piranha plant,
					sa->name == EN_LEFT_DOKAN_FPAKKUN ||																				//---or a LEFTPipe fire piranha plant,
					sa->name == EN_JIMEN_FPAKKUN ||																						//---or a fire piranha plant,
					sa->name == EN_WATERPAKKUN || sa->name == EN_WALK_PAKKUN) && CuteYoshi->eatenID != sa->id) {						//---or a river piranha plant, or a walking piranha plant, and it's not the shell currently in yoshi's mouth:
					int range = 64; //one tile = 16																						//----Set the range to 64 (4 tiles)
					if(sa->pos.x < (CuteYoshi->pos.x + range) && sa->pos.x > (CuteYoshi->pos.x - range)) {								//----If the actor is in the range in the X axis:
						if(sa->pos.y < (CuteYoshi->pos.y + range) && sa->pos.y > (CuteYoshi->pos.y - range)) {							//-----If the actor is in the range in the Y axis:
							sa->collisionCat13_Hammer(&sa->aPhysics, &CuteYoshi->aPhysics);												//------Kill it like it it was touched by a hammer
						}
					}
				}
			}
			CuteYoshi->doneGP = true;																									//--Trigger the groundpounding check
		}
	}
}
//
// processed\../src/UpsideDownEvent.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>


class upsideDownEvent : public dStageActor_c {
public:
	bool deactivateInsteadOfActivate;
	bool useTriggerEvent;
	bool repeat;
	bool toggelEvent;
	int interval;
	int timer;

	void tryToTrigger();

	int onCreate();
	int onExecute();

	static dActor_c *build();
};

const char *UpsideDownEventFileList[] = {0};
const SpriteData upsideDownEventSpriteData = { ProfileId::UpsideDownEvent, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile upsideDownEventProfile(&upsideDownEvent::build, SpriteId::UpsideDownEvent, upsideDownEventSpriteData, ProfileId::UpsideDownEvent, ProfileId::UpsideDownEvent, "UpsideDownEvent", UpsideDownEventFileList);


dActor_c  *upsideDownEvent::build() {
	void *buffer = AllocFromGameHeap1(sizeof(upsideDownEvent));
	upsideDownEvent *c = new(buffer) upsideDownEvent;

	return c;
}


int upsideDownEvent::onCreate() {
	this->deactivateInsteadOfActivate = this->settings >> 8 & 0b1;		//0 activate, 1 deactivate
	this->useTriggerEvent = this->settings >> 7 & 0b1;
	this->repeat = this->settings >> 6 & 0b1;
	this->toggelEvent = this->settings >> 5 & 0b1;
	this->interval = (this->settings & 0b11111) + 1;
	this->timer = 0;

	OSReport("useTriggerEvent: %s\n", useTriggerEvent ? "true" : "false");
	OSReport("repeat: %s\n", repeat ? "true" : "false");
	OSReport("toggelEvent: %s\n", toggelEvent ? "true" : "false");
	OSReport("interval: %d\n", interval);
	OSReport("deactivateInsteadOfActivate: %s\n", deactivateInsteadOfActivate ? "true" : "false");

	this->onExecute();
	return true;
}


int upsideDownEvent::onExecute() {
	//OSReport("playerNumber: %d\n", GetActivePlayerCount());
	if(this->timer == 0) {
		if(this->useTriggerEvent) {
			bool flagOn = ((dFlagMgr_c::instance->flags & spriteFlagMask) != 0);
			//OSReport("Is flag on: %s\n", flagOn ? "true" : "false");
			if(flagOn) {
				this->tryToTrigger();
				if(!this->repeat) {
					dFlagMgr_c::instance->flags &= ~spriteFlagMask;		//deactivate triggering event after being done!
					return true;
				}
			} else {
				return true;
			}
		} else {
			this->tryToTrigger();
			if(!this->repeat) {
				this->Delete(1);
				return true;
			}
		}
		this->timer = this->interval*60;
	} else {
		this->timer--;
	}

	return true;
}

int IsGravityEnabled2 = 0;
extern int IsGravityEnabled;
void upsideDownEvent::tryToTrigger() {
	//OSReport("tryToTrigger: %d\n", eventNums[GetActivePlayerCount()-1]);
	if(this->toggelEvent) {
		if(IsGravityEnabled == 0)
			IsGravityEnabled = 16;
		else
			IsGravityEnabled = 0;
	} else {
		if(deactivateInsteadOfActivate)
			IsGravityEnabled = 0;
		else
			IsGravityEnabled = 16;
	}
}
//
// processed\../src/UpsideDownWall.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

u8 playersUpsideDown[4];

class dUpsideDownWall_c : public dStageActor_c {
public:
	bool allLocations;
	int locationID;

	void tryToTrigger();

	int onCreate();
	int onExecute();

	static dActor_c *build();
};

const char *UpsideDownWallFileList[] = {0};
const SpriteData UpsideDownWallSpriteData = { ProfileId::UpsideDownWall, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile UpsideDownWallProfile(&dUpsideDownWall_c::build, SpriteId::UpsideDownWall, UpsideDownWallSpriteData, ProfileId::UpsideDownWall, ProfileId::UpsideDownWall, "UpsideDownWall", UpsideDownWallFileList);


dActor_c  *dUpsideDownWall_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dUpsideDownWall_c));
	dUpsideDownWall_c *c = new(buffer) dUpsideDownWall_c;

	return c;
}


int dUpsideDownWall_c::onCreate() {
	this->allLocations = this->settings >> 31 & 1;
	this->locationID = this->settings & 0xFF;

	return true;
}

inline u32 isInLocation(dAcPy_c* player, int locationID, dCourse_c* course) {
	mRect rect;
	course->getRectByID(locationID, &rect);

	OSReport("ID: %d, settings: %x, name: %d\n", player->id, player->settings, player->name);

	if(player->pos.x >= rect.x) {
		//OSReport("Check 1\n");
		if(player->pos.x <= rect.x + rect.width) {
			//OSReport("Check 2\n");
			if(player->pos.y <= rect.y) {
				//OSReport("Check 3\n");
				if(player->pos.y >= rect.y - rect.height) {
					//OSReport("Check 4\n");				
					return 16;
				}
			}
		}
	}
	return 0;
}

int dUpsideDownWall_c::onExecute() {
	for (int i = 0; i < 4; i++) {
		//OSReport("P1: %d, P2: %d, P3: %d, P4: %d\n", playersUpsideDown[0], playersUpsideDown[1], playersUpsideDown[2], playersUpsideDown[3]);
		dAcPy_c *player;
		if (player = dAcPy_c::findByID(i)) {
			OSReport("Player: %d\n", i);
			dCourse_c* course = dCourseFull_c::instance->get(GetAreaNum());
			if(allLocations) {
				u32 isPlayerInLocation = 0;
				for(int j = 0; j <= course->rectCount; j++) {
					if(isInLocation(player, j, course) != 0) {
						isPlayerInLocation = 16;
						break;
					}
				}
				playersUpsideDown[player->settings & 3] = isPlayerInLocation;
			} else {
				playersUpsideDown[player->settings & 3] = isInLocation(player, locationID, course);
			}
		}
	}
	return true;
}
//
// processed\../src/ballon.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "path.h"

extern "C" dCourse_c::rail_s *GetRail(int id);

const char* BallonFileList[] = { "ballon", 0 };

class daBallon_c : public dEnPath_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;

	u8 moveDirection;
	Physics physics0;
	Physics::Info physicsInfo1;
	Physics physics1;
	Physics::Info physicsInfo2;
	Physics physics2;
	Physics::Info physicsInfo3;
	Physics physics3;
	Physics::Info physicsInfo4;
	Physics physics4;
	Physics::Info physicsInfo5;
	Physics physics5;
	Physics::Info physicsInfo6;
	Physics physics6;
	float aTestFloat;
	s16 leftRotPtr;
	s16 rightRotPtr;
	StandOnTopCollider sotCollider;

	dCourse_c *course;
	dCourse_c::rail_s *rail;
	dCourse_c::railNode_s *currentNode;
	dCourse_c::railNode_s *nextNode;
	int currentNodeNum;
	float moveDeltaX, moveDeltaY;
	int steps;
	int speed;

	static dActor_c *build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	
	USING_STATES(daBallon_c);
	
	DECLARE_STATE(Wait);
};

CREATE_STATE(daBallon_c, Wait);


void daBallon_c::beginState_Wait() {}
void daBallon_c::executeState_Wait() {
	dStageActor_c* player = (dStageActor_c*)FindActorByType(PLAYER, 0);

	dx = player->pos.x - this->pos.x;
	dy = player->pos.y - this->pos.y;

	distance = sqrtf(pow(dx, 2) + pow(dy, 2));

	if (distance <= 64) {
		doStateChange(&StateID_FollowPath);
	}
}
void daBallon_c::endState_Wait() {}






const SpriteData BallonSpriteData = { ProfileId::Ballon, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile BallonProfile(&daBallon_c::build, SpriteId::Ballon, BallonSpriteData, ProfileId::Ballon, ProfileId::Ballon, "Ballon", BallonFileList);


void daBallon_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
}
void daBallon_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {

}
bool daBallon_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBallon_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBallon_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBallon_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daBallon_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBallon_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBallon_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daBallon_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBallon_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daBallon_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daBallon_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daBallon_c));
	daBallon_c* c = new(buffer) daBallon_c;

	return c;
}

static void BallonPhysCB1(daBallon_c *one, dStageActor_c *two) {
	if (two->stageActorType != 1)
		return;

	// if left/right
	if (one->moveDirection <= 1)
		return;

	if (one->pos_delta.y > 0.0f)
		HurtMarioBecauseOfBeingSquashed(two, one, 1);
	else
		HurtMarioBecauseOfBeingSquashed(two, one, 9);
}

static void BallonPhysCB2(daBallon_c *one, dStageActor_c *two) {
	if (two->stageActorType != 1)
		return;

	// if left/right
	if (one->moveDirection <= 1)
		return;

	if (one->pos_delta.y < 0.0f)
		HurtMarioBecauseOfBeingSquashed(two, one, 2);
	else
		HurtMarioBecauseOfBeingSquashed(two, one, 10);
}

static void BallonPhysCB3(daBallon_c *one, dStageActor_c *two, bool unkMaybeNotBool) {
	if (two->stageActorType != 1)
		return;

	// if up/down
	if (one->moveDirection > 1)
		return;

	if (unkMaybeNotBool) {
		if (one->pos_delta.x > 0.0f)
			HurtMarioBecauseOfBeingSquashed(two, one, 6);
		else
			HurtMarioBecauseOfBeingSquashed(two, one, 12);
	} else {
		if (one->pos_delta.x < 0.0f)
			HurtMarioBecauseOfBeingSquashed(two, one, 5);
		else
			HurtMarioBecauseOfBeingSquashed(two, one, 11);
	}
}

static bool BallonPhysCB4(daBallon_c *one, dStageActor_c *two) {
	return (one->pos_delta.y > 0.0f);
}

static bool BallonPhysCB5(daBallon_c *one, dStageActor_c *two) {
	return (one->pos_delta.y < 0.0f);
}

static bool BallonPhysCB6(daBallon_c *one, dStageActor_c *two, bool unkMaybeNotBool) {
	if (unkMaybeNotBool) {
		if (one->pos_delta.x > 0.0f)
			return true;
	} else {
		if (one->pos_delta.x < 0.0f)
			return true;
	}
	return false;
}

int daBallon_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("ballon", "g3d/ballon_green.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("ballon_green");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	allocator.unlink();


	//round
	physics0.setupRound(this, 0.0f, 175.0f, 80.0f, (void*)&BallonPhysCB1, (void*)&BallonPhysCB2, (void*)&BallonPhysCB3, 1, 0, 0);
	physics0.callback1 = (void*)&BallonPhysCB4;
	physics0.callback2 = (void*)&BallonPhysCB5;
	physics0.callback3 = (void*)&BallonPhysCB6;
	physics0.addToList();
	

	//middle bottom
	physicsInfo1.x1 = -24;
	physicsInfo1.y1 = 4;
	physicsInfo1.x2 = 24;
	physicsInfo1.y2 = 0;

	physicsInfo1.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo1.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo1.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics1.setup(this, &physicsInfo1, 3, currentLayerID);
	physics1.flagsMaybe = 0x260;
	physics1.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics1.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics1.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics1.addToList();
	
	
	//left bottom
	physicsInfo2.x1 = -24;
	physicsInfo2.y1 = 20;
	physicsInfo2.x2 = -20;
	physicsInfo2.y2 = 4;

	physicsInfo2.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo2.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo2.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics2.setup(this, &physicsInfo2, 3, currentLayerID);
	physics2.flagsMaybe = 0x260;
	physics2.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics2.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics2.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics2.addToList();


	//right bottom
	physicsInfo3.x1 = 20;
	physicsInfo3.y1 = 20;
	physicsInfo3.x2 = 24;
	physicsInfo3.y2 = 4;

	physicsInfo3.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo3.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo3.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics3.setup(this, &physicsInfo3, 3, currentLayerID);
	physics3.flagsMaybe = 0x260;
	physics3.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics3.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics3.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics3.addToList();
	
	
	//right top
	physicsInfo4.x1 = -14;
	physicsInfo4.y1 = 140;
	physicsInfo4.x2 = -8;
	physicsInfo4.y2 = 70;
	rightRotPtr = -5500;
	
	physicsInfo4.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo4.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo4.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics4.setup(this, &physicsInfo4, 3, currentLayerID);
	physics4.flagsMaybe = 0x260;
	physics4.setPtrToRotation(&rightRotPtr);
	physics4.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics4.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics4.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics4.addToList();
	
	
	//left top
	physicsInfo5.x1 = 8;
	physicsInfo5.y1 = 140;
	physicsInfo5.x2 = 14;
	physicsInfo5.y2 = 70;
	leftRotPtr = 5500;

	physicsInfo5.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo5.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo5.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics5.setup(this, &physicsInfo5, 3, currentLayerID);
	physics5.flagsMaybe = 0x260;
	physics5.setPtrToRotation(&leftRotPtr);
	physics5.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics5.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics5.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics5.addToList();
	
	
	//middle top
	physicsInfo6.x1 = -32;
	physicsInfo6.y1 = 72;
	physicsInfo6.x2 = 32;
	physicsInfo6.y2 = 62;

	physicsInfo6.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo6.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo6.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics6.setup(this, &physicsInfo6, 3, currentLayerID);
	physics6.flagsMaybe = 0x260;
	physics6.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics6.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics6.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics6.addToList();
	
	
	

	sotCollider.init(this, 0, 16, -8, 24, -24, 0, 1);
	sotCollider._47 = 0xA;
	sotCollider.flags = 0x80180 | 0xC00;
	sotCollider.addToList();
	
	
	
	
	
	
	this->disableEatIn();


	this->aTestFloat = 0.25f;


	/*speed = ((this->settings >> 12 & 0b1111) + 1 ) * 8;						//Bit 29-32
	currentNodeNum = this->settings >> 8 & 0b11111111;						//Bit 33-40
	int pathID = this->settings & 0b11111111;								//Bit 41-48
	if(pathID) {
		rail = GetRail(pathID);
		course = dCourseFull_c::instance->get(GetAreaNum());
		currentNode = &course->railNode[rail->startNode + currentNodeNum];
		nextNode = &course->railNode[rail->startNode + 1 + currentNodeNum];
		OSReport("pathID: %d\n", pathID);
		OSReport("startNode: %d\n", currentNodeNum);
		OSReport("N1.x: %d, N1.y: %d, N2.x: %d, N2.y: %d\n", currentNode->xPos, currentNode->yPos, nextNode->xPos, nextNode->yPos);
		//OSReport("Ballon: %f, %f\n", this->pos.x, this->pos.y);
		this->pos.x = currentNode->xPos;
		this->pos.y = -currentNode->yPos;
		//OSReport("Ballon: %f, %f\n", this->pos.x, this->pos.y);
	} else {
		
	}*/
	

	// Stuff I do understand
	this->scale = (Vec){1, 1, 1};

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;

	this->pos.z = 4000;

	beginState_Init();
	executeState_Init();
	doStateChange(&StateID_Wait);
	
	this->onExecute();
	return true;
}


int daBallon_c::onDelete() {
	return true;
}

int daBallon_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daBallon_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daBallon_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();
	acState.execute();
	/*physics1.removeFromList();
	physics1.setupRound(this, 0.0f, 200.0f - this->aTestFloat, 80.0f, (void*)&BallonPhysCB1, (void*)&BallonPhysCB2, (void*)&BallonPhysCB3, 1, 0, 0);
	physics1.addToList();
	OSReport("Ballon aTestFloat: %f\n", this->aTestFloat);
	this->aTestFloat += 0.25;*/
	//this->pos.x += aTestFloat;
	
	//this->rot.y = -5500;
	//OSReport("Rot.y: %d\n", this->rot.y);
	
		//round
	physics0.removeFromList();
	physics0.setupRound(this, 0.0f, 175.0f, 80.0f, (void*)&BallonPhysCB1, (void*)&BallonPhysCB2, (void*)&BallonPhysCB3, 1, 0, 0);
	physics0.callback1 = (void*)&BallonPhysCB4;
	physics0.callback2 = (void*)&BallonPhysCB5;
	physics0.callback3 = (void*)&BallonPhysCB6;
	physics0.addToList();
	
	sotCollider.update();
	physics0.update();
	physics1.update();
	physics2.update();
	physics3.update();
	physics4.update();
	physics5.update();
	physics6.update();
}
//
// processed\../src/ActorSpawner.cpp
//

#include <game.h>
#include "path.h"

const char* SpawnerFileList[] = { 0 };

class dPathSpawner_c;
class dSpawnerDataBank_c;

class dActorSpawner_c : public dStageActor_c {
public:
    static dActor_c *build(); // Method to allocate memory for the actor.

    int onCreate(); // Called once when the actor is created.
    int onExecute(); // Called every frame that the actor is in existence.

    bool newActorIsAlive();

    bool ranOnce;
	
    bool automaticRespawn; 
    bool despawnWithoutEvent;
    bool saveDespawnLocation;
    bool doMultiSpawning;
	u32 actorID;
	u32 dbSettings;
	u8 dbEventId2;
	u8 dbEventId1;
	u16 dbSpriteFlagNum;
	u8 useLocation;
	u8 spawnerID;
	dPathSpawner_c* pathController;

	dStageActor_c* newActor;
    u16 spawnedId;
};

class dSpawnerDataBank_c : public dStageActor_c {
public:
    static dActor_c *build(); // Method to allocate memory for the actor.

    int onCreate(); // Called once when the actor is created.
    int onExecute(); // Called every frame that the actor is in existence.
};

class dPathSpawner_c : public dPath_c {
public:
    static dActor_c *build(); // Method to allocate memory for the actor.

    int onCreate(); // Called once when the actor is created.
    int onExecute(); // Called every frame that the actor is in existence.

	int spawnerID;
};

const SpriteData NewActorSpawnerSpriteData = { ProfileId::NewActorSpawner, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile NewActorSpawnerProfile(&dActorSpawner_c::build, SpriteId::NewActorSpawner, NewActorSpawnerSpriteData, ProfileId::NewActorSpawner, ProfileId::NewActorSpawner, "NewActorSpawner", SpawnerFileList);


dActor_c* dActorSpawner_c::build() {
    void* buffer = AllocFromGameHeap1(sizeof(dActorSpawner_c));
    return new(buffer) dActorSpawner_c;
}

int dActorSpawner_c::onCreate() {
    // Return the first time in order to get the values of eventId1 and eventId2.
    if (this->ranOnce == false) {
        this->ranOnce = true;
        return false; // Retry onCreate().
    }
	
	this->spawnerID = this->eventId1;

	dSpawnerDataBank_c* dataBank = 0;
	while(dataBank = (dSpawnerDataBank_c*)fBase_c::search(NewActorSpawnerDataBank, dataBank)) {
		OSReport("Found Data Bank with ID: %d\n", dataBank->currentLayerID);
		if(dataBank->currentLayerID == this->spawnerID) {
			break;
		}
	}
	if(dataBank) {
		this->dbSettings = dataBank->settings;
		this->dbEventId1 = dataBank->eventId1;
		this->dbEventId2 = dataBank->eventId2;
		this->dbSpriteFlagNum = dataBank->spriteFlagNum;
		OSReport("Actor Spawner Data Bank found! Settings copied, deleting Data Bank!\n");
		dataBank->Delete(1);
	} else {
		OSReport("No Actor Spawner Data Bank found for Spawner ID: %d\nDeleting Actor Spawner!\n", this->spawnerID);
		this->Delete(1);
	}

	pathController = 0;
	while(pathController = (dPathSpawner_c*)fBase_c::search(NewActorSpawnerPath, (fBase_c*)pathController)) {
		if(pathController->spawnerID == this->spawnerID) {
			break;
		}
	}
	if(pathController) {
		OSReport("Actor Spawner Path Controller found!\n");
	} else {
		OSReport("No Actor Spawner Path Controller found for Spawner ID: %d\n", this->spawnerID);
	}
	
	doMultiSpawning = this->settings >> 16 & 1;
	saveDespawnLocation = this->settings >> 17 & 1;
	despawnWithoutEvent = this->settings >> 18 & 1;
	automaticRespawn = this->settings >> 19 & 1;
	
	actorID = this->settings >> 20;
	
	useLocation = this->settings & 0xFF;
	
    return true;
}

int dActorSpawner_c::onExecute() {
	if(doMultiSpawning) {
		if((dFlagMgr_c::instance->flags & (1ULL << (eventId2 - 1))) != 0) {
			Vec spawnPos = this->pos;
			if(useLocation) {
				mRect rect;
				dCourseFull_c::instance->get(GetAreaNum())->getRectByID(useLocation, &rect);

				// Round the positions down/up to get the rectangle
				int left = rect.x;
				//int right = left + rect.width;
				int top = -rect.y;
				int bottom = top + rect.height;

				spawnPos.x = GenerateRandomNumber(rect.width) + left;
				spawnPos.y = GenerateRandomNumber(rect.height) + bottom; 
			}

			dStageActor_c *ac = dStageActor_c::create((Actors)actorID, dbSettings, &spawnPos, 0, this->currentLayerID);
			
			ac->spriteFlagNum = dbSpriteFlagNum;
			ac->eventId1 = dbEventId1;
			ac->eventId2 = dbEventId2;
		}
	} else {
		if((dFlagMgr_c::instance->flags & (1ULL << (eventId2 - 1))) != 0) {
			if(!newActor) {
				newActor = dStageActor_c::create((Actors)actorID, dbSettings, &pos, 0, this->currentLayerID);
				if(pathController) {
					pathController->acState.setState(&dPath_c::StateID_Init);
				}
			} else {
				if(pathController) {
					newActor->pos = pathController->pos;
				}
			}
		} else {
			if(newActor) {
				newActor->Delete(1);
				newActor = 0;
			}
		}
	}



    return true;
}

bool dActorSpawner_c::newActorIsAlive() {
    // Return true if the search doesn't return 0; the actor is alive.
    return true; //fBase_c::search(this->newActor->id) != 0;
}











const SpriteData NewActorSpawnerDataBankSpriteData = { ProfileId::NewActorSpawnerDataBank, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile NewActorSpawnerDataBankProfile(&dSpawnerDataBank_c::build, SpriteId::NewActorSpawnerDataBank, NewActorSpawnerDataBankSpriteData, ProfileId::NewActorSpawnerDataBank, ProfileId::NewActorSpawnerDataBank, "NewActorSpawnerDataBank", SpawnerFileList);


dActor_c* dSpawnerDataBank_c::build() {
    void* buffer = AllocFromGameHeap1(sizeof(dSpawnerDataBank_c));
    return new(buffer) dSpawnerDataBank_c;
}


int dSpawnerDataBank_c::onCreate() {
	//this->currentLayerID; use the layer ID as the spawnerID
    return true;
}

int dSpawnerDataBank_c::onExecute() {
    return true;
}













const SpriteData NewActorSpawnerPathSpriteData = { ProfileId::NewActorSpawnerPath, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile NewActorSpawnerPathProfile(&dPathSpawner_c::build, SpriteId::NewActorSpawnerPath, NewActorSpawnerPathSpriteData, ProfileId::NewActorSpawnerPath, ProfileId::NewActorSpawnerPath, "NewActorSpawnerPath", SpawnerFileList);


dActor_c* dPathSpawner_c::build() {
    void* buffer = AllocFromGameHeap1(sizeof(dPathSpawner_c));
    return new(buffer) dPathSpawner_c;
}


int dPathSpawner_c::onCreate() {
	this->spawnerID = this->settings >> 20 & 0xFF;
	OSReport("Actor Spawner Path Controller: %d\n", this->spawnerID);
	
    return true;
}

int dPathSpawner_c::onExecute() {
	acState.execute();

    return true;
}















//
// processed\../src/theGreatGoalPole.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "path.h"

extern "C" dCourse_c::rail_s *GetRail(int id);

const char* GreatGoalPoleFileList[] = { "goal_set", "wing", 0 };

class daGreatGoalPole_c : public dEnPath_c {
public:
	int onCreate();
	int onExecute();
	int afterExecute(int param);
	int onDelete();
	int onDraw();

	Physics physics;

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile goalBrres;
	m3d::mdl_c baseA;
	m3d::mdl_c goal_flag;
	nw4r::g3d::ResFile wingBrres;
	m3d::mdl_c wing;
	m3d::anmChr_c anmFlag;
	m3d::anmTexSrt_c flagSrt;
	m3d::anmChr_c anmWing;

	S16Vec baseArot;
	S16Vec wingRot;
	Vec wingScale;

	ActivePhysics a1UPPhysics;
	Physics::Info physicsInfo;
	StandOnTopCollider  sotCollider;
	
	bool done;

	static dActor_c *build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	
	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	
	USING_STATES(daGreatGoalPole_c);
	
	DECLARE_STATE(Wait);
};

CREATE_STATE(daGreatGoalPole_c, Wait);


void daGreatGoalPole_c::beginState_Wait() {}
void daGreatGoalPole_c::executeState_Wait() {
	if (!done) {
		dStageActor_c* player = (dStageActor_c*)FindActorByType(PLAYER, 0);

		if (player->pos.x >= this->pos.x - 64) {
			doStateChange(&StateID_FollowPath);
		}
	}
}
void daGreatGoalPole_c::endState_Wait() {}



void daGreatGoalPole_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->goalBrres.GetResAnmChr(name);
	this->anmFlag.bind(&this->goal_flag, anmChr, unk);
	this->goal_flag.bindAnim(&this->anmFlag, unk2);
	this->anmFlag.setUpdateRate(rate);
}


const SpriteData GreatGoalPoleSpriteData = { ProfileId::GreatGoalPole, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile GreatGoalPoleProfile(&daGreatGoalPole_c::build, SpriteId::GreatGoalPole, GreatGoalPoleSpriteData, ProfileId::GreatGoalPole, ProfileId::GreatGoalPole, "TheGreatGoalPole", GreatGoalPoleFileList);


void daGreatGoalPole_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
}
void daGreatGoalPole_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {

}
bool daGreatGoalPole_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daGreatGoalPole_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daGreatGoalPole_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daGreatGoalPole_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daGreatGoalPole_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daGreatGoalPole_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daGreatGoalPole_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daGreatGoalPole_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daGreatGoalPole_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daGreatGoalPole_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daGreatGoalPole_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daGreatGoalPole_c));
	daGreatGoalPole_c* c = new(buffer) daGreatGoalPole_c;

	return c;
}


int daGreatGoalPole_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->goalBrres.data = getResource("goal_set", "g3d/t00.brres");
	nw4r::g3d::ResMdl baseAMdl = this->goalBrres.GetResMdl("baseA");
	nw4r::g3d::ResMdl goal_flagMdl = this->goalBrres.GetResMdl("goal_flag");
	

	
	this->wingBrres.data = getResource("wing", "g3d/wing.brres");
	nw4r::g3d::ResMdl wingMdl = this->wingBrres.GetResMdl("wing");
	

	
	this->baseA.setup(baseAMdl, &allocator, 0x224, 1, 0);
	this->goal_flag.setup(goal_flagMdl, &allocator, 0x224, 1, 0);
	this->wing.setup(wingMdl, &allocator, 0x224, 1, 0);
	
	SetupTextures_MapObj(&this->baseA, 0);
	SetupTextures_MapObj(&this->goal_flag, 0);
	SetupTextures_Enemy(&this->wing, 0);


	
	nw4r::g3d::ResAnmChr anmChr = this->goalBrres.GetResAnmChr("wait");
	this->anmFlag.setup(goal_flagMdl, anmChr, &this->allocator, 0);
	
	
	nw4r::g3d::ResAnmTexSrt anmSrt = this->goalBrres.GetResAnmTexSrt("wait");
	this->flagSrt.setup(goal_flagMdl, anmSrt, &this->allocator, 0, 1);
	this->flagSrt.setEntryByte34(0, 0);


	nw4r::g3d::ResAnmChr anmChr2 = this->wingBrres.GetResAnmChr("wing_kuri");
	this->anmWing.setup(wingMdl, anmChr2, &this->allocator, 0);
	
	
	
	//bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);
	this->anmFlag.bind(&this->goal_flag, anmChr, 1);
	this->goal_flag.bindAnim(&this->anmFlag, 0.0);
	this->anmFlag.setUpdateRate(1.0);

	this->flagSrt.bindEntry(&this->goal_flag, anmSrt, 0, 1);
	this->goal_flag.bindAnim(&this->flagSrt, 1.0);
	this->flagSrt.setFrameForEntry(1.0, 0);
	this->flagSrt.setUpdateRateForEntry(1.0, 0);

	this->anmWing.bind(&this->wing, anmChr2, 1);
	this->wing.bindAnim(&this->anmWing, 0.0);
	this->anmWing.setUpdateRate(1.0);
	

	allocator.unlink();

	//goal_flag
	ActivePhysics::Info aPhysicsInfo;
	aPhysicsInfo.xDistToCenter = 0.0;
	aPhysicsInfo.yDistToCenter = 72.0;
	aPhysicsInfo.category1 = 0x0;
	aPhysicsInfo.category2 = 0x0;
	aPhysicsInfo.bitfield1 = 0x0;

	aPhysicsInfo.bitfield2 = 0x0;
	aPhysicsInfo.xDistToEdge = 3;
	aPhysicsInfo.yDistToEdge = 76;

	aPhysicsInfo.unkShort1C = 0;
	aPhysicsInfo.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &aPhysicsInfo);
	this->aPhysics.addToList();

	//goal_flag 1UP
	ActivePhysics::Info a1UPPhysicsInfo;
	a1UPPhysicsInfo.xDistToCenter = 0.0;
	a1UPPhysicsInfo.yDistToCenter = 151.0;
	a1UPPhysicsInfo.category1 = 0x0;
	a1UPPhysicsInfo.category2 = 0x0;
	a1UPPhysicsInfo.bitfield1 = 0x0;

	a1UPPhysicsInfo.bitfield2 = 0x0;
	a1UPPhysicsInfo.xDistToEdge = 3;
	a1UPPhysicsInfo.yDistToEdge = 3;

	a1UPPhysicsInfo.unkShort1C = 0;
	a1UPPhysicsInfo.callback = &dEn_c::collisionCallback;

	this->a1UPPhysics.initWithStruct(this, &a1UPPhysicsInfo);
	this->a1UPPhysics.addToList();

	//baseA
	physicsInfo.x1 = -16;
	physicsInfo.y1 = 15.5;
	physicsInfo.x2 = 16;
	physicsInfo.y2 = 0;

	physics.setup(this, &physicsInfo, 1, 0, 0);
	physics.flagsMaybe = 0x260;
	physics.callback1 = (void*)&PhysCB4;
	physics.callback2 = (void*)&PhysCB5;
	physics.callback3 = (void*)&PhysCB6;
	physics.addToList();
	
	sotCollider.init(this, 0, 16, 0, 16, -16, 0, 1);
	sotCollider._47 = 0xA;
	sotCollider.flags = 0x80180 | 0xC00;
	sotCollider.addToList();
	
	done = false;
	
	this->disableEatIn();

	baseArot = (S16Vec){0, 0, 0};
	wingRot = (S16Vec){0, 0x4000, 0};
	
	this->scale = (Vec){1, 1, 1};
	this->wingScale = (Vec){2, 2, 2};

	this->rot.x = 0;
	this->rot.y = 0xC000; //0x8000;
	this->rot.z = 0;

	this->pos.z = 4000;

	beginState_Init();
	executeState_Init();
	doStateChange(&StateID_Wait);
	
	return true;
}


int daGreatGoalPole_c::onDelete() {
	physics.removeFromList();
	return true;
}

int daGreatGoalPole_c::onDraw() {
	baseA.scheduleForDrawing();
	goal_flag.scheduleForDrawing();
	wing.scheduleForDrawing();
	return true;
}


void daGreatGoalPole_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&baseArot.x, &baseArot.y, &baseArot.z);
	baseA.setDrawMatrix(matrix);
	baseA.setScale(&scale);
	baseA.calcWorld(false);

	matrix.translation(pos.x, pos.y, pos.z + 5);
	matrix.applyRotationYXZ(&wingRot.x, &wingRot.y, &wingRot.z);
	wing.setDrawMatrix(matrix);
	wing.setScale(&wingScale);
	wing.calcWorld(false);

	matrix.translation(pos.x, pos.y+85, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);
	goal_flag.setDrawMatrix(matrix);
	goal_flag.setScale(&scale);
	goal_flag.calcWorld(false);
}

int daGreatGoalPole_c::onExecute() {
	baseA._vf1C();
	goal_flag._vf1C();
	wing._vf1C();
	updateModelMatrices();
	acState.execute();

	if (this->anmFlag.isAnimationDone()) {
		this->anmFlag.setCurrentFrame(0.0);
	}
	
	if(acState.getCurrentState()->isEqual(&StateID_FollowPath)){
		if (this->anmWing.isAnimationDone()) {
			this->anmWing.setCurrentFrame(0.0);
		}
	} else {
		this->anmWing.setCurrentFrame(anmWing._28);
	}
	
	this->flagSrt.process();
	if(this->flagSrt.isEntryAnimationDone(0))
		this->flagSrt.setFrameForEntry(1.0, 0);
	
	sotCollider.update();
	physics.update();
	return true;
}

int daGreatGoalPole_c::afterExecute(int param) {
	dEn_c::afterExecute(param);
	a1UPPhysics.clear();
	return true;
}
//
// processed\../src/gakenoko.cpp
//

#include <game.h>

struct daEnGakeNoko_c : public dEn_c {
	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c model;
	m3d::anmChr_c anmChr;
	nw4r::g3d::ResAnmTexPat resAnmTexPat;
	m3d::anmTexPat_c anmTexPat;
	u32 _5EC;
	int countdown;
	u8 gap[0x12C];

	USING_STATES(daEnGakeNoko_c);
	REF_NINTENDO_STATE(FoolMove);
	REF_NINTENDO_STATE(Move);
	REF_NINTENDO_STATE(Air);
	REF_NINTENDO_STATE(Awake);
	REF_NINTENDO_STATE(Fall);
	REF_NINTENDO_STATE(Fall2);
	REF_NINTENDO_STATE(Hang);
	REF_NINTENDO_STATE(DieFumi);
};

const ActivePhysics::Info GakeNokoColl = {
    0.0f,  // float xDistToCenter;
    11.0f,  // float yDistToCenter;
    8.0f,  // float xDistToEdge;
    11.0f,  // float yDistToEdge;
    3,  // u8 category1;
    0,  // u8 category2;
    0x4F,  // u32 bitfield1;
    0xFFBAFFFE,  // u32 bitfield2;
    0,  // u16 unkShort1C;
    &dEn_c::collisionCallback  // Callback callback;
};

int EN_GAKE_NOKO_ctor_new(daEnGakeNoko_c *self) {								//b @ 0x80A025A0
	self->allocator.link(-1, mHeap::gameHeaps[0], 0, 0x20);
	self->resFile.data = getResource("nokonokoB", "g3d/nokonokoB.brres");

	nw4r::g3d::ResMdl resMdl = self->resFile.GetResMdl("nokonokoB");
	self->model.setup(resMdl, &self->allocator, 0x7FFF, 1, 0);
	SetupTextures_Enemy(&self->model, 0);

	nw4r::g3d::ResAnmChr resAnmChr = self->resFile.GetResAnmChr("net_walk2");
	self->anmChr.setup(resMdl, resAnmChr, &self->allocator, 0);

	self->resAnmTexPat = self->resFile.GetResAnmTexPat("nokonokoB");
	self->anmTexPat.setup(resMdl, self->resAnmTexPat, &self->allocator, 0, 1);
	self->anmTexPat.bindEntry(&self->model, &self->resAnmTexPat, 0, 1);

	self->allocator.unlink();

	// Nybble 10: green (0) / red (1)
	if ((self->settings >> 8) & 1) {
		self->doStateChange(&daEnGakeNoko_c::StateID_Move);
	} else {
		self->doStateChange(&daEnGakeNoko_c::StateID_FoolMove);
	}
	if ((self->settings >> 8) & 1) {
		self->anmTexPat.setEntryByte34(1, 0);
		self->model.bindAnim(&self->anmTexPat, 0.0);
		self->anmTexPat.setFrameForEntry(1.0, 0);
	} else {
		self->anmTexPat.setFrameForEntry(0.0, 0);
	}

	// Nybble 11: initial direction: right (0) / left (1)
	if ((self->settings >> 4) & 1) {
		// (Logic copied from how the Move state switches directions
		// at the end of a ledge -- basic block at 80A02E00 in PALv1)
		self->direction ^= 1;
		self->speed.x = -self->speed.x;
		self->anmChr.playState = 2;
	}

	// Nybble 12: if 1, vertical positioning is improved
	if (self->settings & 1) {
		self->pos.y += 16.0;
	}

	// ActivePhysics for 2021
	self->aPhysics.initWithStruct(self, (ActivePhysics::Info *)&GakeNokoColl);
	self->aPhysics.addToList();

	self->rot.y = 0x8000;  // Face the wall

	return 1;
}


// Edit some Y-position-related constants in various states if nybble 12 is enabled
float twenty_four_or_alt_f[2] = { 24.0f, 8.0f };
float thirty_one_or_alt_f[2] = { 31.0f, 15.0f };

//
// processed\../src/sidestepper.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include <stage.h>
#include <profile.h>
#include "boss.h"

#define NUMBER_OF_MINIS 3

const char* SidestepperArcNameList [] = 
{
	
	"test_lift",
	NULL
};

extern "C" void destroyBarrel(dStageActor_c*);


class daMiniSidestepper_c : public dEn_c {
public:

	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	nw4r::g3d::ResFile resFile;
	m3d::anmChr_c chrAnimation;

	u64 eventFlag;
	u32 delay;

	u32 effect;
	u8 type;

	S16Vec nullRot;
	Vec efScale;


	dAc_Py_c* target;

	float BaseLine;
	int randomnum;
	int isBuried; //0 when not, 1 when yes
	int startposx;
	bool left;
	bool right;
	bool fastwalkafterhit;
	bool everysecondtry;
	float rndmnum;
	int plusorminus; // 0-Plus, 1-Minus
	int plusorminusrock; // 0-Plus, 1-Minus
	int rndmactor;
	int buryprojectiletimer;
	bool everysecondtry2;
	int walkwaitwalk; //for wait 
	bool left2;
	bool right2;
	int timerock;
	int rndmtimerock;
	bool morelives;
	float point0;
	float point1;
	float point2;
	int howmanypoints; //Used for the BackUp State
	int whichpoint;
	float distbetweenpoints;
	bool bossFlag;
	
	int timer;

	int lives;


	Vec possand;
	Vec BackUpEffect;
	Vec posbarrel;
	Vec posenemy;
	Vec posrock;
	Vec barreleffect;
	Vec enemyeffect;


	static dActor_c* build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	void _vf148();
	void _vf14C();
	bool CreateIceActors();

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat5_Mario(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat8_FencePunch(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat11_PipeCannon(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	//bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);

	USING_STATES(daMiniSidestepper_c);
	DECLARE_STATE(Wait);
	DECLARE_STATE(Walk);
	DECLARE_STATE(Bury);
	DECLARE_STATE(MoveSand);
	DECLARE_STATE(BackUp);
	DECLARE_STATE(Outro);
};

CREATE_STATE(daMiniSidestepper_c, Wait);
CREATE_STATE(daMiniSidestepper_c, Walk);
CREATE_STATE(daMiniSidestepper_c, Bury);
CREATE_STATE(daMiniSidestepper_c, MoveSand);
CREATE_STATE(daMiniSidestepper_c, BackUp);
CREATE_STATE(daMiniSidestepper_c, Outro);

class daSidestepper_c : public daBoss {
public:
	
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	nw4r::g3d::ResFile resFile;
	m3d::anmChr_c chrAnimation;

	u64 eventFlag;
	u32 delay;

	u32 effect;
	u8 type;

	S16Vec nullRot;
	Vec efScale;

	//
	m3d::anmTexSrt_c body;

	m3d::mdl_c fogModel;
	m3d::anmTexSrt_c fogSRT;
	//


	dAc_Py_c* target;

	float BaseLine;
	int randomnum;
	int isBuried; //0 when not, 1 when yes
	float startposx;
	float stagemiddle;
	bool left;
	bool right;
	bool fastwalkafterhit;
	bool everysecondtry;
	float rndmnum;
	int plusorminus; // 0-Plus, 1-Minus
	int plusorminusrock; // 0-Plus, 1-Minus
	int rndmactor;
	int buryprojectiletimer;
	bool everysecondtry2;
	int walkwaitwalk; //for wait 
	bool left2;
	bool right2;
	int timerock;
	int rndmtimerock;
	bool round0;
	bool round1;
	bool rockisleft;
	u32 barrelid;
	int barrelisthere;
	int rndmnumms;
	int rndmspeedr;


	dStageActor_c* barrel;
	daMiniSidestepper_c* enemy[NUMBER_OF_MINIS];
	dStageActor_c* rock;
	dStageActor_c* claw;

	nw4r::snd::SoundHandle* handle;

	int lives;


	Vec possand;
	Vec BackUpEffect;
	Vec posbarrel;
	Vec posenemy;
	Vec posrock;
	Vec barreleffect;
	Vec enemyeffect;


	static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);				
	bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);					
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);					
	bool collisionCat8_FencePunch(ActivePhysics *apThis, ActivePhysics *apOther);				
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);				
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);			
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);				
	bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);				
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);			
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);		
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);		
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);					
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	
	USING_STATES(daSidestepper_c);
	DECLARE_STATE(Grow);
	DECLARE_STATE(Hit);
	DECLARE_STATE(Wait);
	DECLARE_STATE(Walk);
	DECLARE_STATE(Projectiles);
	DECLARE_STATE(Bury);
	DECLARE_STATE(Actors);
	DECLARE_STATE(MoveSand);
	DECLARE_STATE(BackUp);
	DECLARE_STATE(Run);
	DECLARE_STATE(Claw);
	DECLARE_STATE(Outro);
};

CREATE_STATE(daSidestepper_c, Grow);
CREATE_STATE(daSidestepper_c, Hit);
CREATE_STATE(daSidestepper_c, Wait);
CREATE_STATE(daSidestepper_c, Walk);
CREATE_STATE(daSidestepper_c, Projectiles);
CREATE_STATE(daSidestepper_c, Bury);
CREATE_STATE(daSidestepper_c, Actors);
CREATE_STATE(daSidestepper_c, MoveSand);
CREATE_STATE(daSidestepper_c, BackUp);
CREATE_STATE(daSidestepper_c, Run);
CREATE_STATE(daSidestepper_c, Claw);
CREATE_STATE(daSidestepper_c, Outro);

void daSidestepper_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}



// Extra collision conditions:

void daSidestepper_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther)
{
	DamagePlayer(this, apThis, apOther);
}

bool daSidestepper_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When player collides using star
	// Call the default collision function, to not repeat the same code
    return true;
}
bool daSidestepper_c::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When player collides using butt slide
	playerCollision(apThis, apOther);
    return true;
}
bool daSidestepper_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When player drills with propeller
	playerCollision(apThis, apOther);
    return true;
}
bool daSidestepper_c::collisionCat8_FencePunch(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When player punches fence behind
	playerCollision(apThis, apOther);
    return true;
}
bool daSidestepper_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When player ground pounds
	playerCollision(apThis, apOther);
    return true;
}
bool daSidestepper_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When player ground pounds with Yoshi
	playerCollision(apThis, apOther);
    return true;
}
bool daSidestepper_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When player slides with penguin suit
	playerCollision(apThis, apOther);
    return true;
}
bool daSidestepper_c::collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When player shoots from pipe cannon
	playerCollision(apThis, apOther);
    return true;
}
bool daSidestepper_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When player throws object at sprite
	
	dActor_c* block = apOther->owner;
	dEn_c* blah = (dEn_c*)block;

	if (blah->direction == 0) { blah->direction = 1; }
	else { blah->direction = 0; }
	
	blah->speed.x = -blah->speed.x;
	blah->pos.x += blah->speed.x;

	if (blah->speed.y < 0) {
		blah->speed.y = -blah->speed.y;
	}

	blah->doSpriteMovement();
	blah->doSpriteMovement();

	this->pos.x -= blah->speed.x;

	Vec oneVec = { 1.0f, 1.0f, 1.0f };
	if (acState.getCurrentState() == &StateID_Bury || acState.getCurrentState() == &StateID_BackUp || acState.getCurrentState() == &StateID_Hit)
	{
		destroyBarrel(blah);
		return true;
	}

	PlaySound(this, SE_EMY_DOWN);

	PlaySound(this, SE_EMY_BLOW_PAKKUN_DOWN);
	
	SpawnEffect("Wm_mr_kickhit", 0, &blah->pos, &nullRot, &oneVec);

	this->damage += 5;


	if (this->damage > this->lives)
	{
		if (enemy[0] != NULL)
			enemy[0]->doStateChange(&daMiniSidestepper_c::StateID_Outro);
		if (enemy[1] != NULL)
			enemy[1]->doStateChange(&daMiniSidestepper_c::StateID_Outro);
		if (enemy[2] != NULL)
			enemy[2]->doStateChange(&daMiniSidestepper_c::StateID_Outro);
		doStateChange(&StateID_Outro);
	}
	else { 
		this->fastwalkafterhit = true;
		doStateChange(&StateID_Hit); 
	}

	return true;
}
bool daSidestepper_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When collides with fireball
    return true;
}
bool daSidestepper_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When collides with ice ball
    return true;
}
bool daSidestepper_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When collides with hammer projectile
    return true;
}
bool daSidestepper_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther) {
	// When collides with Yoshi fire spit
    return true;
}


dActor_c *daSidestepper_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daSidestepper_c));
	return new(buffer) daSidestepper_c;
}

const SpriteData SidestepperSpriteData =
	{ ProfileId::Sidestepper, 0, 0 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };

Profile SidestepperProfile(&daSidestepper_c::build, SpriteId::Sidestepper, SidestepperSpriteData, ProfileId::Sidestepper, ProfileId::Sidestepper, "Sidestepper", SidestepperArcNameList);


int daSidestepper_c::onCreate() {
	//Variables
	this->nullRot = (S16Vec){0, 0, 0};
	this->efScale = (Vec){2.0f, 1.0f, 1.0f};

	target = GetSpecificPlayerActor(0); //target is mario


	this->randomnum = 0;
	this->isBuried = 0; //0 when not, 1 when yes
	this->fastwalkafterhit = false;
	this->everysecondtry = false;
	this->everysecondtry2 = true;
	this->round0 = false;
	this->round1 = false;
	this->rockisleft = false;

	this->barrelid = 418;
	
	
	// Do the following once when object is spawned:

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	// Model settings. First string is arc name, second string is brres name inside arc, third string is mdl0 name inside brres.
	this->resFile.data = getResource("test_lift", "g3d/test_lift.brres");

	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("test_lift");
	bodyModel.setup(mdl, &this->allocator, 0x224, 1, 0);
	SetupTextures_Boss(&bodyModel, 0);

	nw4r::g3d::ResAnmChr anmChr = resFile.GetResAnmChr("wait");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);


	//
	/*

	mdl = this->resFile.GetResMdl("bubble_fog_CS");
	fogModel.setup(mdl, &allocator, 0x124, 1, 0);

	nw4r::g3d::ResAnmTexSrt anmRes = this->resFile.GetResAnmTexSrt("wait_proj");
	this->fogSRT.setup(mdl, anmRes, &this->allocator, 0, 1);
	this->fogSRT.bindEntry(&this->fogModel, anmRes, 0, 0);
	this->fogModel.bindAnim(&this->fogSRT, 0.0);

	*/
	//



	allocator.unlink();

	// Physics settings. Use hitbox debug mode to test hitbox, [Press "-" 16 times on star coin menu].
	ActivePhysics::Info Physics;
	Physics.xDistToCenter = 0.0;
	Physics.yDistToCenter = 0.0;
	Physics.xDistToEdge = 32.0;
	Physics.yDistToEdge = 53.0;
	Physics.category1 = 0x3;
	Physics.category2 = 0x0;
	Physics.bitfield1 = 0x4F;
	Physics.bitfield2 = 0xFFFFFFFF;
	Physics.unkShort1C = 0;
	Physics.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &Physics);
	this->aPhysics.addToList();

	// Size settings

	this->scale.x = 0.15;
	this->scale.y = 0.15;
	this->scale.z = 0.15;

	//This make it Layer 0
	//this->pos.z = -1000.0; //before 3300.0
	this->pos.y -= 1;

	this->startposx = pos.x;
	this->BaseLine = pos.y;

	//5 Lives function was disabled in Reggie due to incompatibility with other attacks. (Is enabled in the code)
	//DO NOT USE 5 LIVES!!!
	if (this->settings >> 31 & 0b1)
	{
		this->lives = 24;
	}
	else
	{
		this->lives = 14;
	}

	this->lives = 14;

	doStateChange(&StateID_Grow);

	this->onExecute();
	return true;
}


int daSidestepper_c::onDelete() {
	// Do the following when deleted:
	
	return true;
}

int daSidestepper_c::onDraw() {
	bodyModel.scheduleForDrawing();
	//
	fogModel.scheduleForDrawing();
	//fogModel._vf1C();
	this->fogSRT.process();
	//
	return true;
}


void daSidestepper_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daSidestepper_c::onExecute() {
	// Do the following every frame:
	acState.execute();
	updateModelMatrices();
	bodyModel._vf1C();
	fogModel._vf1C();

	if (this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}
	
	for (int i = 0; i < NUMBER_OF_MINIS; i++) {
    	if (enemy[i] != NULL && enemy[i]->acState.getCurrentState() == &daMiniSidestepper_c::StateID_Outro) {
        	enemy[i] = NULL;
		}
    }
	

	return true;
}



/*//////*/
/*States*/
/*//////*/


void daSidestepper_c::beginState_Grow()
{
	this->timer = 0;

	bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);

	SetupBoss();
}

void daSidestepper_c::executeState_Grow()
{
	this->timer += 1;

	bool ret;
	ret = GrowBossNoKameck(this, 0.15, 0.4, 0, this->timer);


	//Grow Sound Test

	if (ret) {
		PlaySound(this, SE_EMY_MECHAKOOPA_BOUND);
		doStateChange(&StateID_Bury);
	}
	

}

void daSidestepper_c::endState_Grow()
{
	CleanupBoss();
	this->BaseLine = this->pos.y;
}

void daSidestepper_c::beginState_Hit()
{
	timer = 0;

	bindAnimChr_and_setUpdateRate("hit", 1, 0.0, 1.0);
}

void daSidestepper_c::executeState_Hit()
{
	if (timer > 120)
	{
		doStateChange(&StateID_Bury);
	}

	timer += 1;
}

void daSidestepper_c::endState_Hit()
{ }


void daSidestepper_c::beginState_Wait()
{
	this->timer = 0;
	bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);
}

void daSidestepper_c::executeState_Wait()
{
	this->timer += 1;

	if (timer > 50)
	{
		if (this->isBuried == 1)
		{
			this->isBuried = 0;
			if (everysecondtry2)
			{
				everysecondtry2 = false;
				doStateChange(&StateID_Actors);
			}
			else
			{
				//everysecondtry2 = true;
				doStateChange(&StateID_MoveSand);
			}
				
		}
		else
			doStateChange(&StateID_Walk);
	}
}

void daSidestepper_c::endState_Wait()
{ }

void daSidestepper_c::beginState_Walk()
{
	this->timer = 0;
	this->randomnum += 1;

	if (target->pos.x > pos.x)
	{
		bindAnimChr_and_setUpdateRate("walk_r", 1, 0.0, 1.0);
		this->right = true;
		this->left = false;
	}
	else if (target->pos.x <= pos.x)
	{
		bindAnimChr_and_setUpdateRate("walk_l", 1, 0.0, 1.0);
		this->left = true;
		this->right = false;
	}
}

void daSidestepper_c::executeState_Walk()
{
	this->timer += 1;



	if (this->lives == 14)
	{
		if (damage > 9)
		{
			doStateChange(&StateID_Run);
		}
	}
	else if (this->lives == 24)
	{
		if (damage > 19)
		{
			doStateChange(&StateID_Run);
		}
	}



	if (this->left == true)
		pos.x -= 1;
	else if (this->right == true)
		pos.x += 1;
	if (this->randomnum > 2)
	{
		doStateChange(&StateID_Projectiles); //Before Bury
		this->randomnum = 0;
	}


	if (this->timer > 50) 
		doStateChange(&StateID_Wait); 
}

void daSidestepper_c::endState_Walk()
{

}

void daSidestepper_c::beginState_Projectiles()
{

	this->timer = 0;
	

	bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);

	this->rndmtimerock = GenerateRandomNumber(6);

	switch (this->rndmtimerock) //Don't judge me for switches Mihi!
	{
	case 0:
		this->timerock = 0;
		break;
	case 1:
		this->timerock = 16;
		break;
	case 2:
		this->timerock = 32;
		break;
	case 3:
		this->timerock = 48;
		break;
	case 4:
		this->timerock = 64;
		break;
	case 5:
		this->timerock = 80;
		break;
	default:
		this->Delete(1);
		break;
	}


	plusorminusrock = GenerateRandomNumber(2);


	//Check lives
	

	if (damage > 4) //1 hit
	{
		round1 = true;
	}

	else { //0 hits
		round0 = true;
	}


	if (target->pos.x > pos.x)
	{
		bindAnimChr_and_setUpdateRate("projectileRotRight", 1, 0.0, 1.0);
		this->right = true;
		this->left = false;
		this->posrock = (Vec){ pos.x + 20.0 , pos.y + 20.0 , 0 };
	}
	else if (target->pos.x < pos.x)
	{
		bindAnimChr_and_setUpdateRate("projectileRotLeft", 1, 0.0, 1.0);
		this->left = true;
		this->right = false;
		this->posrock = (Vec){ pos.x - 20.0 , pos.y + 20.0 , 0 };
	}
}

void daSidestepper_c::executeState_Projectiles()
{
	//+19 after shoot to create actor
	//+23 after Create Actor (then wait)


	this->timer += 1;

	if (this->right == true)
	{
		//If round0 is rn
		if (round0)
		{
			if (timer == 119)
			{
				bindAnimChr_and_setUpdateRate("projectileWaitRight", 1, 0.0, 1.0);
			}


			if (timer == 198)
			{

				bindAnimChr_and_setUpdateRate("projectileShootRight", 1, 0.0, 1.0);
			}

			if (timer == 217)
			{
				Vec interneffectpos = { pos.x + 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 240)
			{
				bindAnimChr_and_setUpdateRate("projectileShootRight", 1, 0.0, 1.0);
			}

			if (timer == 259)
			{
				Vec interneffectpos = { pos.x + 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 282)
			{
				bindAnimChr_and_setUpdateRate("projectileRotBackRight", 1, 0.0, 1.0);
			}

			if (timer > 216)
			{
				timerock--;
				if (timerock > 0)
				{
					rock->pos.y += 1;
				}
			}
		}
		
		//If round1 is rn
		else if (round1)
		{
			if (timer == 119)
			{
				bindAnimChr_and_setUpdateRate("projectileWaitRight", 1, 0.0, 1.0);
			}


			if (timer == 198)
			{

				bindAnimChr_and_setUpdateRate("projectileShootRight", 1, 0.0, 1.0);
			}

			if (timer == 217)
			{
				Vec interneffectpos = { pos.x + 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 240)
			{
				bindAnimChr_and_setUpdateRate("projectileShootRight", 1, 0.0, 1.0);
			}

			if (timer == 259)
			{
				Vec interneffectpos = { pos.x + 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 284)
			{
				bindAnimChr_and_setUpdateRate("projectileShootRight", 1, 0.0, 1.0);
			}

			if (timer == 303)
			{
				Vec interneffectpos = { pos.x + 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 328)
			{
				bindAnimChr_and_setUpdateRate("projectileShootRight", 1, 0.0, 1.0);
			}

			if (timer == 347)
			{
				Vec interneffectpos = { pos.x + 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 370)
			{
				bindAnimChr_and_setUpdateRate("projectileRotBackRight", 1, 0.0, 1.0);
			}

			if (timer > 216)
			{
				timerock--;
				if (timerock > 0)
				{
					rock->pos.y += 1;
				}
			}
		}
		
	}
	else if (this->left == true)
	{

		//If round0 is rn
		if (round0)
		{
			if (timer == 119)
			{
				bindAnimChr_and_setUpdateRate("projectileWaitLeft", 1, 0.0, 1.0);
			}


			if (timer == 198)
			{

				bindAnimChr_and_setUpdateRate("projectileShootLeft", 1, 0.0, 1.0);
			}

			if (timer == 217)
			{
				Vec interneffectpos = { pos.x - 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 1 << 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 240)
			{
				bindAnimChr_and_setUpdateRate("projectileShootLeft", 1, 0.0, 1.0);
			}

			if (timer == 259)
			{
				Vec interneffectpos = { pos.x - 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 1 << 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 282)
			{
				bindAnimChr_and_setUpdateRate("projectileRotBackLeft", 1, 0.0, 1.0);
			}

			if (timer > 216)
			{
				timerock--;
				if (timerock > 0)
				{
					rock->pos.y += 1;
				}
			}
		}

		//If round1 is rn
		else if (round1)
		{
			if (timer == 119)
			{
				bindAnimChr_and_setUpdateRate("projectileWaitLeft", 1, 0.0, 1.0);
			}


			if (timer == 198)
			{

				bindAnimChr_and_setUpdateRate("projectileShootLeft", 1, 0.0, 1.0);
			}

			if (timer == 217)
			{
				Vec interneffectpos = { pos.x - 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 1 << 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 240)
			{
				bindAnimChr_and_setUpdateRate("projectileShootLeft", 1, 0.0, 1.0);
			}

			if (timer == 259)
			{
				Vec interneffectpos = { pos.x - 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 1 << 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 284)
			{
				bindAnimChr_and_setUpdateRate("projectileShootLeft", 1, 0.0, 1.0);
			}

			if (timer == 303)
			{
				Vec interneffectpos = { pos.x - 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 1 << 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 328)
			{
				bindAnimChr_and_setUpdateRate("projectileShootLeft", 1, 0.0, 1.0);
			}

			if (timer == 347)
			{
				Vec interneffectpos = { pos.x - 12.0, pos.y + 2.0, 0 };
				S16Vec nullRot = { 0,0,0 };
				Vec oneVec = { 1.5f, 1.5f, 1.5f };
				SpawnEffect("Wm_mr_hardhit_glow", 0, &interneffectpos, &nullRot, &oneVec);
				this->rock = CreateActor(287, 1 << 0, this->posrock, 0, 0);
				PlaySound(this, SE_EMY_KANIBO_THROW);
			}

			if (timer == 370)
			{
				bindAnimChr_and_setUpdateRate("projectileRotBackLeft", 1, 0.0, 1.0);
			}

			if (timer > 216)
			{
				timerock--;
				if (timerock > 0)
				{
					rock->pos.y += 1;
				}
			}
		}
	}

	if (round0)
	{
		if (this->timer > 401)
		{
			this->round0 = false;
			this->round1 = false;

			everysecondtry2 = true;

			doStateChange(&StateID_Bury);
		}
	}
	if (round1)
	{
		if (this->timer > 489)
		{
			this->round0 = false;
			this->round1 = false;

			everysecondtry2 = true;

			doStateChange(&StateID_Bury);
		}
	}

}

void daSidestepper_c::endState_Projectiles()
{ }

void daSidestepper_c::beginState_Bury()
{
	bindAnimChr_and_setUpdateRate("groundDisappear", 1, 0.0, 1.0);

	this->timer = 0;

	PlaySound(this, 545);

	SpawnEffect("Wm_mr_sanddive_out", 0, &this->pos, &nullRot, &efScale);
	SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
}

void daSidestepper_c::executeState_Bury()
{


	if (this->timer < 60) {
		this->pos.y -= 2.0;  // Height is 54 pixels, move down
	}

	if (this->timer > 90) {

		this->isBuried = 1;

		doStateChange(&StateID_Wait);
	}

	this->timer += 1;
}

void daSidestepper_c::endState_Bury()
{ }



void daSidestepper_c::beginState_Actors()
{
	this->timer = 0;

	if ((dStageActor_c*)fBase_c::search(BLOCK_TARU))
	{
		destroyBarrel(barrel);
	}
}

void daSidestepper_c::executeState_Actors()
{
	if (timer == 0)
	{
		//Barrel
		rndmnum = GenerateRandomNumber(170); //pos from actor

		plusorminus = GenerateRandomNumber(2); //plus or minus
		if (plusorminus == 0)
		{
			this->posbarrel = (Vec){ pos.x + rndmnum, pos.y, pos.z };
		}
		else if (plusorminus == 1)
		{
			this->posbarrel = (Vec){ pos.x - rndmnum, pos.y, pos.z };
		}
		else
			this->Delete(1);


		//Crab or Enemy
		rndmnum = GenerateRandomNumber(220); //pos from actor

		plusorminus = GenerateRandomNumber(2); //plus or minus
		if (plusorminus == 0)
		{
			this->posenemy = (Vec){ pos.x + rndmnum, this->BaseLine, pos.z - 100.0 };
		}
		else if (plusorminus == 1)
		{
			this->posenemy = (Vec){ pos.x - rndmnum, this->BaseLine, pos.z - 100.0 };
		}
		else
			this->Delete(1);
		
		
		//Create Effect at barrels pos
		this->barreleffect = (Vec){ this->posbarrel.x, this->BaseLine, 0 };
		SpawnEffect("Wm_mr_sanddive_out", 0, &this->barreleffect, &nullRot, &efScale);
		SpawnEffect("Wm_mr_sanddive_smk", 0, &this->barreleffect, &nullRot, &efScale);

		//Create Effect at crabs pos
		if (this->enemy[1] == NULL || this->enemy[0] == NULL || this->enemy[2] == NULL)
		{
			this->enemyeffect = (Vec){ this->posenemy.x, this->BaseLine, 0 };
			SpawnEffect("Wm_mr_sanddive_out", 0, &this->enemyeffect, &nullRot, &efScale);
			SpawnEffect("Wm_mr_sanddive_smk", 0, &this->enemyeffect, &nullRot, &efScale);
		}
	}
	
	if (timer > 50)
	{
		if (timer < 74)
		{
			if (timer == 51)
			{
				this->barrel = CreateActor(418, 0, this->posbarrel, 0, 0);

				if (this->enemy[0] == NULL)
				{
					this->enemy[0] = (daMiniSidestepper_c*)CreateActor(780, 0, this->posenemy, 0, 0);
					this->enemy[0]->bossFlag = true;
				}
				else if (this->enemy[1] == NULL)
				{
					this->enemy[1] = (daMiniSidestepper_c*)CreateActor(780, 0, this->posenemy, 0, 0);
					this->enemy[1]->bossFlag = true;	
				}
				else if (this->enemy[2] == NULL)
				{
					this->enemy[2] = (daMiniSidestepper_c*)CreateActor(780, 0, this->posenemy, 0, 0);
					this->enemy[2]->bossFlag = true;	
				}
			}
			barrel->pos.y += 2.0;
			barrel->pos.y += 2.0;
			barrel->pos.y += 2.0;
		}
	}
	if (timer > 73)
		doStateChange(&StateID_MoveSand);

	this->timer += 1;
}

void daSidestepper_c::endState_Actors()
{ }

void daSidestepper_c::beginState_MoveSand()
{


	bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);
	this->timer = 0;

	this->rndmnumms = GenerateRandomNumber(4) + 1;

}

void daSidestepper_c::executeState_MoveSand()
{
	


	this->timer += 1;

	if (this->timer == 60)
	{

		this->possand = (Vec){ target->pos.x, this->BaseLine, 0 };

		SpawnEffect("Wm_mr_sanddive_out", 0, &this->possand, &nullRot, &efScale);
		SpawnEffect("Wm_mr_sanddive_smk", 0, &this->possand, &nullRot, &efScale);
	}

	if (this->timer == 120)
	{

		this->possand = (Vec){ target->pos.x, this->BaseLine, 0 };

		SpawnEffect("Wm_mr_sanddive_out", 0, &this->possand, &nullRot, &efScale);
		SpawnEffect("Wm_mr_sanddive_smk", 0, &this->possand, &nullRot, &efScale);
	}

	if (this->timer == 180)
	{

		this->possand = (Vec){ target->pos.x, this->BaseLine, 0 };

		SpawnEffect("Wm_mr_sanddive_out", 0, &this->possand, &nullRot, &efScale);
		SpawnEffect("Wm_mr_sanddive_smk", 0, &this->possand, &nullRot, &efScale);
	}

	if (this->timer == (this->rndmnumms * 60))
	{
		pos.x = target->pos.x;
		doStateChange(&StateID_BackUp);
	}
}

void daSidestepper_c::endState_MoveSand()
{

}


void daSidestepper_c::beginState_BackUp()
{
	bindAnimChr_and_setUpdateRate("groundAppear", 1, 0.0, 1.0);
	this->timer = 0;

	BackUpEffect = (Vec){ pos.x, this->BaseLine, 0 };

	SpawnEffect("Wm_mr_sanddive_out", 0, &this->BackUpEffect, &nullRot, &efScale);
	SpawnEffect("Wm_mr_sanddive_smk", 0, &this->BackUpEffect, &nullRot, &efScale);
	PlaySound(this, 775);
}

void daSidestepper_c::executeState_BackUp()
{
	if (this->timer < 90 && this->timer > 29) {
		this->pos.y += 2.0;  // Height is 54 pixels, move down
	}

	if (this->timer == 90) { bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0); }

	if (this->timer > 120) {
		if (pos.y != this->BaseLine)
		{
			pos.y = this->BaseLine;
		}
		
		if (this->fastwalkafterhit)
		{
			this->fastwalkafterhit = false;
			doStateChange(&StateID_Run);
		}
		else
			doStateChange(&StateID_Walk);
	}

	this->timer += 1;
}

void daSidestepper_c::endState_BackUp()
{ }



void daSidestepper_c::beginState_Run()
{
	this->timer = 0;

	this->rndmspeedr = GenerateRandomNumber(3) + 2;

	if (this->damage > 5)
	{
		this->rndmspeedr = 4;
	}

	if (target->pos.x > pos.x)
	{
		bindAnimChr_and_setUpdateRate("attack_l_down", 1, 0.0, 1.0);
		this->right = true;
		this->left = false;
	}
	else if (target->pos.x <= pos.x)
	{
		bindAnimChr_and_setUpdateRate("attack_r_down", 1, 0.0, 1.0);
		this->left = true;
		this->right = false;
	}
}

void daSidestepper_c::executeState_Run()
{
	this->timer += 1;

	if (this->right == true)
	{
		if (this->timer < 60)
		{
			SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
		}
		if (this->timer >= 60)
		{
			if (timer == 60) { bindAnimChr_and_setUpdateRate("attack_l_loop", 1, 0.0, 1.0); }
			PlaySound(this, SE_OBJ_TEKKYU_G_CRASH);
			pos.x += this->rndmspeedr;

			if (everysecondtry == true) {
				SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
				everysecondtry = false;
			}
			if (everysecondtry == false) {
				everysecondtry = true;
			}
		}
		
	}
	else if (this->left == true)
	{
		if (this->timer < 60)
		{
			SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
		}
		if (this->timer >= 60)
		{
			if (timer == 60) { bindAnimChr_and_setUpdateRate("attack_r_loop", 1, 0.0, 1.0); }
			PlaySound(this, SE_OBJ_TEKKYU_G_CRASH);
			pos.x -= this->rndmspeedr;

			if (everysecondtry == true) {
				SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
				everysecondtry = false;
			}
			if (everysecondtry == false) {
				everysecondtry = true;
			}
		}
	}


	if (this->damage != 10) 
	{
		OSReport("Damage value: %x\n", this->damage);
		if (this->timer > 230)
		{
			doStateChange(&StateID_Bury);
		}
	}
	else 
	{
		if (this->timer > 230)
		{
			if (this->right == true)
			{
				if (this->timer < 291)
				{
					SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
				}
				if (this->timer >= 291)
				{
					if (timer == 291) { bindAnimChr_and_setUpdateRate("attack_l_loop", 1, 0.0, 1.0); }
					PlaySound(this, SE_OBJ_TEKKYU_G_CRASH);
					pos.x += this->rndmspeedr;

					if (everysecondtry == true) {
						SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
						everysecondtry = false;
					}
					if (everysecondtry == false) {
						everysecondtry = true;
					}
				}
				
			}
			else if (this->left == true)
			{
				if (this->timer < 291)
				{
					SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
				}
				if (this->timer >= 291)
				{
					if (timer == 291) { bindAnimChr_and_setUpdateRate("attack_r_loop", 1, 0.0, 1.0); }
					PlaySound(this, SE_OBJ_TEKKYU_G_CRASH);
					pos.x -= this->rndmspeedr;

					if (everysecondtry == true) {
						SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
						everysecondtry = false;
					}
					if (everysecondtry == false) {
						everysecondtry = true;
					}
				}
			}
		}
		
		if (this->timer > 291)
		{
			doStateChange(&StateID_Bury);
		}
	}
}

void daSidestepper_c::endState_Run()
{ }




void daSidestepper_c::beginState_Claw()
{
	timer = 0;
	this->claw = CreateActor(801, 0, this->pos, 0, 0);
}
void daSidestepper_c::executeState_Claw()
{
	if (timer == 350)
	{
		doStateChange(&StateID_BackUp);
	}
	
	timer++;
}
void daSidestepper_c::endState_Claw() 
{ }




void daSidestepper_c::beginState_Outro()
{
	this->timer = 0;
	bindAnimChr_and_setUpdateRate("hit", 1, 0.0, 1.0);
	OutroSetup(this);
}

void daSidestepper_c::executeState_Outro()
{
	if (this->dying == 1) {
		if (this->timer > 180) {
			ExitStage(WORLD_MAP, 0, BEAT_LEVEL, MARIO_WIPE);
		}
		if (this->timer == 60) { PlayerVictoryCries(this); }

		this->timer += 1;
		return;
	}

	bool ret;
	ret = ShrinkBoss(this, &this->pos, 0.4, this->timer);

	if (ret == true) {
		this->pos.z = 10000.0;
		BossExplode(this, &this->pos);
		this->dying = 1;
		this->timer = 0;
	}

	this->timer += 1;
}

void daSidestepper_c::endState_Outro() { }
//
// processed\../src/minisidestepper.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include <stage.h>
#include <profile.h>
#include "boss.h"

//Yeah... I know... This is a lazy copy of the sidestepper boss... But it works! -LiQ | 02/06/21 11:13am

extern "C" void destroyBarrel(dStageActor_c*);

const char* MiniSidestepperArcNameList[] =
{

	"test_lift",
	NULL
};

//class defined in sidestepper.cpp

void daMiniSidestepper_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}


// Extra collision conditions:

void daMiniSidestepper_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther)
{
	this->_vf220(apOther->owner);
}

bool daMiniSidestepper_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	PlaySound(this, SE_EMY_DOWN);

	doStateChange(&StateID_Outro);

	return true;
}
bool daMiniSidestepper_c::collisionCat5_Mario(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When player collides using butt slide
	playerCollision(apThis, apOther);
	return true;
}
bool daMiniSidestepper_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When player drills with propeller
	playerCollision(apThis, apOther);
	return true;
}
bool daMiniSidestepper_c::collisionCat8_FencePunch(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When player punches fence behind
	playerCollision(apThis, apOther);
	return true;
}
bool daMiniSidestepper_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When player ground pounds
	playerCollision(apThis, apOther);
	return true;
}
bool daMiniSidestepper_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When player ground pounds with Yoshi
	playerCollision(apThis, apOther);
	return true;
}
bool daMiniSidestepper_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When player slides with penguin suit
	PlaySound(this, SE_EMY_DOWN);

	doStateChange(&StateID_Outro);

	return true;
}
bool daMiniSidestepper_c::collisionCat11_PipeCannon(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When player shoots from pipe cannon
	PlaySound(this, SE_EMY_DOWN);

	doStateChange(&StateID_Outro);

	return true;
}
bool daMiniSidestepper_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When player throws object at sprite
	if (bossFlag)
	{
		dActor_c *block = apOther->owner;
		dEn_c* blah = (dEn_c*)block;

		if (block->name == BLOCK_TARU)
		{
			destroyBarrel(blah);
		}
	}

	PlaySound(this, SE_EMY_DOWN);

	doStateChange(&StateID_Outro);

	return true;
}
bool daMiniSidestepper_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When collides with fireball
	PlaySound(this, SE_EMY_DOWN);

	doStateChange(&StateID_Outro);

	return true;
}
bool daMiniSidestepper_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When collides with hammer projectile
	PlaySound(this, SE_EMY_DOWN);

	doStateChange(&StateID_Outro);

	return true;
}
bool daMiniSidestepper_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	// When collides with Yoshi fire spit
	PlaySound(this, SE_EMY_DOWN);

	doStateChange(&StateID_Outro);

	return true;
}



// These handle the ice crap
void daMiniSidestepper_c::_vf148() {
	dEn_c::_vf148();
	doStateChange(&StateID_Outro);
}
void daMiniSidestepper_c::_vf14C() {
	dEn_c::_vf14C();
	doStateChange(&StateID_Outro);
}

extern "C" void sub_80024C20(void);
extern "C" void __destroy_arr(void*, void(*)(void), int, int);
//extern "C" __destroy_arr(struct DoSomethingCool, void(*)(void), int cnt, int bar);

bool daMiniSidestepper_c::CreateIceActors() {
	struct DoSomethingCool my_struct = { 0, this->pos, {1.8, 1.4, 1.2}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	this->frzMgr.Create_ICEACTORs((void*)&my_struct, 1);
	__destroy_arr((void*)&my_struct, sub_80024C20, 0x3C, 1);
	chrAnimation.setUpdateRate(0.0f);
	return true;
}





dActor_c* daMiniSidestepper_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daMiniSidestepper_c));
	return new(buffer) daMiniSidestepper_c;
}

const SpriteData MiniSidestepperSpriteData =
{ ProfileId::MiniSidestepper, 0, 0 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 2 };

Profile MiniSidestepperProfile(&daMiniSidestepper_c::build, SpriteId::MiniSidestepper, MiniSidestepperSpriteData, ProfileId::MiniSidestepper, ProfileId::MiniSidestepper, "MiniSidestepper", MiniSidestepperArcNameList);


int daMiniSidestepper_c::onCreate() {
	//Variables
	this->nullRot = (S16Vec){ 0, 0, 0 };
	this->efScale = (Vec){ 1.0f, 0.5f, 1.0f };

	target = GetSpecificPlayerActor(0); //target is mario


	this->randomnum = 0;
	this->isBuried = 0; //0 when not, 1 when yes
	this->fastwalkafterhit = false;
	this->everysecondtry = false;
	this->everysecondtry2 = true;



	// Do the following once when object is spawned:

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	// Model settings. First string is arc name, second string is brres name inside arc, third string is mdl0 name inside brres.
	this->resFile.data = getResource("test_lift", "g3d/test_lift.brres");

	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("test_lift");
	bodyModel.setup(mdl, &this->allocator, 0x224, 1, 0);
	SetupTextures_MapObj(&bodyModel, 0);

	nw4r::g3d::ResAnmChr anmChr = resFile.GetResAnmChr("wait");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);


	//
	/*

	mdl = this->resFile.GetResMdl("bubble_fog_CS");
	fogModel.setup(mdl, &allocator, 0x124, 1, 0);

	nw4r::g3d::ResAnmTexSrt anmRes = this->resFile.GetResAnmTexSrt("wait_proj");
	this->fogSRT.setup(mdl, anmRes, &this->allocator, 0, 1);
	this->fogSRT.bindEntry(&this->fogModel, anmRes, 0, 0);
	this->fogModel.bindAnim(&this->fogSRT, 0.0);

	*/
	//



	allocator.unlink();

	// Physics settings. Use hitbox debug mode to test hitbox, [Press "-" 16 times on star coin menu].
	ActivePhysics::Info Physics;
	Physics.xDistToCenter = 0.0;
	Physics.yDistToCenter = 2.5;
	Physics.xDistToEdge = 10.0;
	Physics.yDistToEdge = 12.0;
	Physics.category1 = 0x3;
	Physics.category2 = 0x0;
	Physics.bitfield1 = 0x4F;
	Physics.bitfield2 = 0xFFFFFFFF;
	Physics.unkShort1C = 0;
	Physics.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &Physics);
	this->aPhysics.addToList();

	// Size settings

	this->scale.x = 0.15;
	this->scale.y = 0.15;
	this->scale.z = 0.15;


	this->pos.z = -1000.0;

	this->startposx = pos.x;


	daSidestepper_c* test;



	this->BaseLine = pos.y;


	//Set dist
	if (this->settings >> 3 & 0b1)
	{
		distbetweenpoints = 16.0;
	}
	else if (this->settings >> 4 & 0b1)
	{
		distbetweenpoints = 32.0;
	}
	else if (this->settings >> 5 & 0b1)
	{
		distbetweenpoints = 48.0;
	}
	else if (this->settings >> 6 & 0b1)
	{
		distbetweenpoints = 64.0;
	}
	else if (this->settings >> 7 & 0b1)
	{
		distbetweenpoints = 80.0;
	}

	else if (bossFlag)
	{
		distbetweenpoints = 80.0;
	}

	else
	{
		distbetweenpoints = 16.0;
	}



	//Check SpawnPoints
	if (this->settings & 0b1) //1 point
	{
		howmanypoints = 1;
		this->point0 = this->startposx;
	}
	else if (this->settings >> 1 & 0b1) //2
	{
		howmanypoints = 2;
		this->point0 = this->startposx;
		this->point1 = this->startposx + distbetweenpoints;
	}
	else if (this->settings >> 2 & 0b1) //3
	{
		howmanypoints = 3;
		this->point0 = this->startposx;
		this->point1 = this->startposx + distbetweenpoints;
		this->point2 = this->startposx - distbetweenpoints;
	}

	else if (bossFlag) //when sidestepper boss
	{
		howmanypoints = 3;
		this->point0 = this->startposx;
		this->point1 = this->startposx + distbetweenpoints;
		this->point2 = this->startposx - distbetweenpoints;
	}
	else //1 point
	{
		howmanypoints = 1;
		this->point0 = this->startposx;
	}


	doStateChange(&StateID_Wait);

	this->onExecute();
	return true;
}


int daMiniSidestepper_c::onDelete() {
	// Do the following when deleted:

	return true;
}

int daMiniSidestepper_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daMiniSidestepper_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daMiniSidestepper_c::onExecute() {
	// Do the following every frame:
	acState.execute();
	updateModelMatrices();
	bodyModel._vf1C();

	if (this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}


	return true;
}



/*//////*/
/*States*/
/*//////*/



void daMiniSidestepper_c::beginState_Wait()
{
	this->timer = 0;
	bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);
}

void daMiniSidestepper_c::executeState_Wait()
{
	this->timer += 1;

	if (timer > 50)
	{
		if (this->isBuried == 1)
		{
			this->isBuried = 0;
			
			everysecondtry2 = true;
			doStateChange(&StateID_MoveSand);
			

		}
		else
			doStateChange(&StateID_Walk);
	}
}

void daMiniSidestepper_c::endState_Wait()
{ }

void daMiniSidestepper_c::beginState_Walk()
{
	this->timer = 0;
	this->randomnum += 1;

	if (target->pos.x > pos.x)
	{
		bindAnimChr_and_setUpdateRate("walk_r", 1, 0.0, 1.0);
		this->right = true;
		this->left = false;
	}
	else if (target->pos.x < pos.x)
	{
		bindAnimChr_and_setUpdateRate("walk_l", 1, 0.0, 1.0);
		this->left = true;
		this->right = false;
	}
}

void daMiniSidestepper_c::executeState_Walk()
{
	this->timer += 1;


	if (this->left == true)
		pos.x -= 0.4;
	else if (this->right == true)
		pos.x += 0.4;
	if (this->randomnum == 4)
	{
		doStateChange(&StateID_Bury);
		this->randomnum = 0;
	}


	if (this->timer > 50)
		doStateChange(&StateID_Wait);
}

void daMiniSidestepper_c::endState_Walk()
{

}


void daMiniSidestepper_c::beginState_Bury()
{
	bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);

	this->timer = 0;

	PlaySound(this, 0x221);

	SpawnEffect("Wm_mr_sanddive_out", 0, &this->pos, &nullRot, &efScale);
	SpawnEffect("Wm_mr_sanddive_smk", 0, &this->pos, &nullRot, &efScale);
}

void daMiniSidestepper_c::executeState_Bury()
{
	if (this->timer < 60) {
		this->pos.y -= 1.0;  // Height is 54 pixels, move down
	}

	if (this->timer > 90) {
		this->isBuried = 1;
		doStateChange(&StateID_Wait);
	}

	this->timer += 1;
}

void daMiniSidestepper_c::endState_Bury()
{ }


void daMiniSidestepper_c::beginState_MoveSand()
{


	bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);
	this->timer = 0;

}

void daMiniSidestepper_c::executeState_MoveSand()
{
	this->timer += 1;

	if (this->timer == 60)
	{

		this->possand = (Vec){ pos.x, this->BaseLine, 0 };

		SpawnEffect("Wm_mr_sanddive_out", 0, &this->possand, &nullRot, &efScale);
		SpawnEffect("Wm_mr_sanddive_smk", 0, &this->possand, &nullRot, &efScale);
	}

	if (this->timer == 120)
	{
		whichpoint = GenerateRandomNumber(howmanypoints);
		switch (whichpoint)
		{
		case 0:
			pos.x = point0;
			break;
		case 1:
			pos.x = point1;
			break;
		case 2:
			pos.x = point2;
			break;
		}

		doStateChange(&StateID_BackUp);
	}
}

void daMiniSidestepper_c::endState_MoveSand()
{

}


void daMiniSidestepper_c::beginState_BackUp()
{
	bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);
	this->timer = 0;

	BackUpEffect = (Vec){ pos.x, this->BaseLine, 0 };


	SpawnEffect("Wm_mr_sanddive_out", 0, &this->BackUpEffect, &nullRot, &efScale);
	SpawnEffect("Wm_mr_sanddive_smk", 0, &this->BackUpEffect, &nullRot, &efScale);
}

void daMiniSidestepper_c::executeState_BackUp()
{
	if (this->timer < 60) {
		this->pos.y += 1.0;  // Height is 54 pixels, move down
	}

	if (this->timer > 90) {

		doStateChange(&StateID_Walk);
	}

	this->timer += 1;
}

void daMiniSidestepper_c::endState_BackUp()
{ }


void daMiniSidestepper_c::beginState_Outro()
{
	this->timer = 0;
	bindAnimChr_and_setUpdateRate("wait", 1, 0.0, 1.0);

	pos.z = 5000.0;
}

void daMiniSidestepper_c::executeState_Outro()
{
	if (timer == 300)
	{
		this->Delete(1);
	}
	
	//this->rot.x += 0x500;
	//this->rot.y += 0x500;
	//this->rot.z += 0x500;
	//pos.y -= 1.5;
	
	dEn_c::dieFall_Execute();

	this->timer += 1;
}

void daMiniSidestepper_c::endState_Outro() { }
//
// processed\../src/waterlift.cpp
//

#include <game.h>

const char* WaterliftFileList [] = {"lift_han_wood", "lift_han_stone", "lift_kinoko_yoko", "lift_han_spin", "boss_koopa_lift", "boss_koopa_lift_down", NULL};

class dWaterliftSpawner : public dStageActor_c {
public:
	static dActor_c *build(); // Method to allocate memory for the actor.

	int onCreate(); // Called once when the actor is created.
};


const SpriteData WaterliftSpawnerSpriteData = { ProfileId::WATER_LIFT_NEW, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile WaterliftSpawnerProfile(&dWaterliftSpawner::build, SpriteId::WATER_LIFT, WaterliftSpawnerSpriteData, ProfileId::WATER_LIFT_NEW, ProfileId::WATER_LIFT_NEW, "WATER_LIFT", WaterliftFileList);


dActor_c* dWaterliftSpawner::build() {
	void* buffer = AllocFromGameHeap1(sizeof(dWaterliftSpawner));
	return new(buffer) dWaterliftSpawner;
}


s32 dWaterliftSpawner::onCreate() {
	dStageActor_c* actor = (dStageActor_c*) dStageActor_c::create(WATER_LIFT, settings, &(this->pos), 0, 0);
	return true;
}
//
// processed\../src/texmapcolouriser.cpp
//

#include "texmapcolouriser.h"

dTexMapColouriser_c::dTexMapColouriser_c() {
	texmap = 0;
	original = 0;
	mine = 0;
}

void *EGG__Heap__alloc(unsigned long size, int unk, void *heap);
void EGG__Heap__free(void *ptr, void *heap);

dTexMapColouriser_c::~dTexMapColouriser_c() {
	resetAndClear();
}

void dTexMapColouriser_c::resetAndClear() {
	texmap = 0;
	if (mine) {
		EGG__Heap__free(mine, 0);
		mine = 0;
	}
}

void dTexMapColouriser_c::setTexMap(nw4r::lyt::TexMap *tm) {
	OSReport("Colourising TexMap: %p (w:%d h:%d)\n", tm, tm->width, tm->height);
	if (texmap)
		resetAndClear();

	if (tm->mBits.textureFormat != GX_TF_IA8) {
		OSReport("Warning: Trying to colourise image whose format is %d not GX_TF_IA8\n", tm->mBits.textureFormat);
	}

	texmap = tm;
	original = (u16*)tm->image;
	mine = (u16*)EGG__Heap__alloc(tm->width * tm->height * 4, 0x20, mHeap::gameHeaps[2]);
	tm->image = mine;
	tm->mBits.textureFormat = GX_TF_RGBA8;
}

void dTexMapColouriser_c::applyAlso(nw4r::lyt::TexMap *tm) {
	if (!texmap) {
		setTexMap(tm);
	} else {
		tm->image = mine;
		tm->mBits.textureFormat = GX_TF_RGBA8;
	}
}

inline static float hslValue(float n1, float n2, float hue) {
	if (hue > 6.0f)
		hue -= 6.0f;
	else if (hue < 0.0f)
		hue += 6.0f;

	if (hue < 1.0f)
		return n1 + (n2 - n1) * hue;
	else if (hue < 3.0f)
		return n2;
	else if (hue < 4.0f)
		return n1 + (n2 - n1) * (4.0f - hue);
	else
		return n1;
}

void dTexMapColouriser_c::colourise(int h, int s, int l) {
	if (!mine)
		return;

	int width = texmap->width, height = texmap->height;
	int texelW = width / 4, texelH = height / 4;

	u16 *source = original, *dest = mine;

	float hueParam = h / 360.0f;
	float satParam = s / 100.0f;
	float lumParam = l / 100.0f;

	for (int texelY = 0; texelY < texelH; texelY++) {
		for (int texelX = 0; texelX < texelW; texelX++) {
			for (int y = 0; y < 4; y++) {
				for (int x = 0; x < 4; x++) {
					u8 intensity = *source & 0xFF;
					u8 alpha = *source >> 8;

					u8 r, g, b;

					// This is a hack
					if (alpha < 250) {
						r = g = b = intensity;
					} else {
						// converting from GIMP's colourise code...
						// h and s are always the same
						// l is the only thing we need to touch:
						// we get the luminance from the source pixel
						// (which, conveniently, is the intensity)
						// manipulate it using the passed l and then
						// convert the whole thing to RGB

						float lum = intensity / 255.0f;

						// manipulate it
						if (l > 0) {
							lum = lum * (1.0f - lumParam);
							lum += (1.0f - (1.0f - lumParam));
						} else if (l < 0) {
							lum = lum * (lumParam + 1.0f);
						}

						// make it RGB

						if (s == 0) {
							r = g = b = lum*255.0f;
						} else {
							float m1, m2;
							if (lum <= 0.5f)
								m2 = lum * (1.0f + satParam);
							else
								m2 = lum + satParam - lum * satParam;

							m1 = 2.0f * lum - m2;

							r = hslValue(m1, m2, hueParam * 6.0f + 2.0) * 255.0f;
							g = hslValue(m1, m2, hueParam * 6.0f) * 255.0f;
							b = hslValue(m1, m2, hueParam * 6.0f - 2.0) * 255.0f;
						}
					}

					// now write it
					dest[0] = (alpha<<8)|r;
					dest[16] = (g<<8)|b;

					source++;
					dest++;
				}
			}

			dest += 16;
		}
	}
}



//
// processed\../src/worldmapShop.cpp
//

// TODO:  - 0x80926ba0 LoadFilesForWorldMap: re-add lakitu and items
//          - Warning: eventually the poweruplist was already changed before in boomeranghax, poweruphax or some stockItemFix file ...
//                     WorldMap folder list handled in worldmapGrid.S
//          - also add all new items
//        - The cursor doesn't get deleted together with the rest of the actor
//        - eventually make the shop have 2 pages with the first one being a new stockItem and the second the shop
//          - in this case bind the spawning of this actor to button 1
//          - no need for a mushroom house shop on the map
//        - unhardcode shop names and items
//          - load from planned worldInfo.bin
//        - re-add texmapcolouriser functionality with colours from worldInfo.bin
//        - check why the game crashes after the following sequence of events:
//          - open shop while on level node
//          - press 2 -> buying something while starting the level
//          - finish the level
//          - try to re-open/spawn the shop
//          >> probably the problem is that the bool containing the info whether the shop is spawned is true while there is no shop
//             the code in worldmapGird.cpp then tries to delete the non existend shop and crashes the game ...

#ifndef __KOOPATLAS_SHOP_H
#define __KOOPATLAS_SHOP_H

//#include "koopatlas/core.h"
#include "texmapcolouriser.h"

class dWMShop_c : public dActor_c {
	public:
		static dWMShop_c *build();
		static dWMShop_c *instance;

		dWMShop_c();

		int onCreate();
		int onDelete();
		int onExecute();
		int onDraw();
		void specialDraw1();

		bool layoutLoaded;
		m2d::EmbedLayout_c layout;

		bool visible;
		float scaleEase;
		int timer;

		int selected, lastTopRowChoice;
		int shopKind;

		int coinsRemaining, timerForCoinCountdown;
		
		bool showShop;

		enum Animation {
			SHOW_ALL = 0,
			HIDE_ALL = 1,
			ACTIVATE_BUTTON = 2, // 3, 4, 5, 6, 7
			DEACTIVATE_BUTTON = 8, // 9, 10, 11, 12, 13
			COUNT_COIN = 14,
		};

		enum ItemTypes {
			MUSHROOM = 0,
			FIRE_FLOWER,
			PROPELLER,
			ICE_FLOWER,
			PENGUIN,
			MINI_SHROOM,
			STARMAN,
			HAMMER,
			GOLD_FLOWER,
			SPIKE_SHROOM,
			BOOMERANG,
			FROG,
			CLOUD,
			WAND,
			ONE_UP,
			ITEM_TYPE_COUNT
		};

		enum _Constants {
			ITEM_COUNT = 12,
		};

		static const ItemTypes Inventory[10][12];

		nw4r::lyt::TextBox
			*Title, *TitleShadow,
			*CoinCount, *CoinCountShadow,
			*BackText, *BuyText;

		nw4r::lyt::Picture
			*BtnLeft[6], *BtnMid[6], *BtnRight[6];

		nw4r::lyt::Pane
			*Buttons[6], *Btn1Base, *Btn2Base;

		dTexMapColouriser_c leftCol, midCol, rightCol;

		class ShopModel_c {
			public:
				mHeapAllocator_c allocator;

				nw4r::g3d::ResFile res;
				m3d::mdl_c model;
				m3d::anmChr_c animation;

				float x, y, scaleFactor, scaleEase;
				bool isLakitu, playingNotEnough;

				void setupItem(float x, float y, ItemTypes type);
				void setupLakitu(int id);
				void execute();
				void draw();
				void playAnim(const char *name, float rate, char loop);
		};

		ShopModel_c *itemModels;
		ShopModel_c *lakituModel;

		void show(int shopNumber);

		void loadInfo();
		void loadModels();
		void deleteModels();

		void buyItem(int item);

		void showSelectCursor();

		dStateWrapper_c<dWMShop_c> state;

		USING_STATES(dWMShop_c);
		DECLARE_STATE(Hidden);
		DECLARE_STATE(ShowWait);
		DECLARE_STATE(ButtonActivateWait);
		DECLARE_STATE(CoinCountdown);
		DECLARE_STATE(Wait);
		DECLARE_STATE(HideWait);
};

#endif

extern int PtrToWM_CS_SEQ_MNG;
extern "C" bool FUN_801017c0(int, int, int, int, int);
extern "C" void FUN_808fbd10(int);
extern "C" void dCourseSelectGuide_c__loadLives(int);

CREATE_STATE(dWMShop_c, Hidden);
CREATE_STATE(dWMShop_c, ShowWait);
CREATE_STATE(dWMShop_c, ButtonActivateWait);
CREATE_STATE(dWMShop_c, CoinCountdown);
CREATE_STATE(dWMShop_c, Wait);
CREATE_STATE(dWMShop_c, HideWait);


int getUnspentStarCoinCount() {
	SaveBlock *save = GetSaveFile()->GetBlock(-1);
	int coinsSpent = save->spentStarCoins;
	return getStarCoinCount() - coinsSpent;
}

int getStarCoinCount() {
	SaveBlock *save = GetSaveFile()->GetBlock(-1);
	int coinsEarned = 0;

	for (int w = 0; w < 10; w++) {
		for (int l = 0; l < 42; l++) {
			u32 conds = save->GetLevelCondition(w, l);

			if (conds & COND_COIN1) { coinsEarned++; }
			if (conds & COND_COIN2) { coinsEarned++; }
			if (conds & COND_COIN3) { coinsEarned++; }
		}
	}

	return coinsEarned;
}

void dWMShop_c::ShopModel_c::setupItem(float x, float y, ItemTypes type) {
	static const char* Produce[ITEM_TYPE_COUNT][4] = { 
		{ "I_kinoko", 		"g3d/I_kinoko.brres", 			"I_kinoko", 			"wait2" },
		{ "I_fireflower", 	"g3d/I_fireflower.brres", 		"I_fireflower", 		"wait2" },
		{ "I_propeller", 	"g3d/I_propeller.brres", 		"I_propeller_model", 	"wait2" },
		{ "I_iceflower", 	"g3d/I_iceflower.brres", 		"I_iceflower", 			"wait2" },
		{ "I_penguin", 		"g3d/I_penguin.brres", 			"I_penguin", 			"wait2" },
		{ "I_kinoko_bundle","g3d/I_mini_kinoko.brres", 		"I_mini_kinoko", 		"wait2" },
		{ "I_star", 		"g3d/I_star.brres", 			"I_star", 				"wait2" },
		{ "I_hammer", 		"g3d/I_fireflower.brres",		"I_fireflower",			"wait2" },
		{ "I_gold",			"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_spike",		"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_boomerang",	"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_frog",			"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_cloud",		"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_wand",			"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_kinoko_bundle","g3d/I_life_kinoko.brres", 		"I_life_kinoko", 		"wait2" },
		
	};

	this->x = x;
	this->y = y;
	
	scaleFactor = 2.3f;

	int id = (int)type;
	isLakitu = false;

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	res.data = getResource(Produce[id][0], Produce[id][1]);
	nw4r::g3d::ResMdl mdlRes = res.GetResMdl(Produce[id][2]);
	model.setup(mdlRes, &allocator, 0x224, 1, 0);

	SetupTextures_Item(&model, 1);

	nw4r::g3d::ResAnmChr anmChr = res.GetResAnmChr(Produce[id][3]);
	animation.setup(mdlRes, anmChr, &allocator, 0);
	playAnim(Produce[id][3], 1.0f, 0);

	allocator.unlink();
}

void dWMShop_c::ShopModel_c::setupLakitu(int id) {
	static const char* models[10] = { 
		"g3d/yoshi.brres", "g3d/desert.brres", "g3d/mountain.brres", "g3d/sakura.brres", "g3d/santa.brres", 
		"g3d/ghost.brres", "g3d/space.brres", "g3d/koopa.brres", "g3d/sewer.brres", "g3d/goldwood.brres" 
	};

	scaleFactor = 1.0f;
	scaleEase = 0.0f;
	this->isLakitu = true;

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	res.data = getResource("Rosalina", "g3d/rosalina.brres"/*models[id]*/);
	nw4r::g3d::ResMdl mdlRes = res.GetResMdl("rosalina");
	model.setup(mdlRes, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&model, 1);

	nw4r::g3d::ResAnmChr anmChr = res.GetResAnmChr("wait");
	animation.setup(mdlRes, anmChr, &allocator, 0);

	playAnim("wait", 1.0f, 0);
	playingNotEnough = false;

	allocator.unlink();
}

void dWMShop_c::ShopModel_c::playAnim(const char *name, float rate, char loop) {
	nw4r::g3d::ResAnmChr anmChr = res.GetResAnmChr(name);
	animation.bind(&model, anmChr, loop);
	model.bindAnim(&animation, 0.0f);
	animation.setUpdateRate(rate);
}

void dWMShop_c::ShopModel_c::execute() {
	model._vf1C();

	if(this->animation.isAnimationDone()) {
		OSReport("Animaiton Complete");
		if (this->isLakitu) {
			OSReport("Setting animation to idle");
			playAnim("wait", 1.0f, 0);
			this->animation.setCurrentFrame(0.0);
			if (playingNotEnough) {
				OSReport("Detected Not Enough animation as being over\n");
				playingNotEnough = false;
			}
		}
	}	
}

void dWMShop_c::ShopModel_c::draw() {
	mMtx mtx;
	mtx.translation(x, y, 1000.0f);
	model.setDrawMatrix(mtx);

	float s = scaleFactor * scaleEase;

	Vec scale = {s, s, s};
	model.setScale(&scale);

	model.calcWorld(false);
	model.scheduleForDrawing();
}



dWMShop_c *dWMShop_c::instance = 0;

dWMShop_c *dWMShop_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dWMShop_c));
	dWMShop_c *c = new(buffer) dWMShop_c;

	instance = c;
	return c;
}

dWMShop_c::dWMShop_c() : state(this, &StateID_Hidden) {
	layoutLoaded = false;
	visible = false;
}

int dWMShop_c::onCreate() {
	showShop = false;
	if (!layoutLoaded) {
		bool gotFile = layout.loadArc("shop.arc", false);
		if (!gotFile)
			return false;

		selected = 0;
		lastTopRowChoice = 0;

		layout.build("shop.brlyt");

		if (IsWideScreen()) {
			layout.layout.rootPane->scale.x = 0.735f;
		} else {
			layout.clippingEnabled = true;
			layout.clipX = 0;
			layout.clipY = 52;
			layout.clipWidth = 640;
			layout.clipHeight = 352;
			layout.layout.rootPane->scale.x = 0.731f;
			layout.layout.rootPane->scale.y = 0.7711f;
		}

		static const char *brlanNames[] = {
			"shop_Show.brlan",
			"shop_Hide.brlan",
			"shop_ActivateButton.brlan",
			"shop_DeactivateButton.brlan",
			"shop_CountCoin.brlan"
		};
		static const char *groupNames[] = {
			"BaseGroup", "BaseGroup",
			"GBtn00", "GBtn01", "GBtn02", "GBtn03", "GBtn1", "GBtn2",
			"GBtn00", "GBtn01", "GBtn02", "GBtn03", "GBtn1", "GBtn2",
			"GCoinCount"
		};
		static const int brlanIDs[] = {
			0, 1,
			2, 2, 2, 2, 2, 2,
			3, 3, 3, 3, 3, 3,
			4,
		};

		layout.loadAnimations(brlanNames, 5);
		layout.loadGroups(groupNames, brlanIDs, 15);
		layout.disableAllAnimations();

		layout.drawOrder = 1;

		static const char *tbNames[] = {
			"Title", "TitleShadow",
			"CoinCount", "CoinCountShadow",
			"BackText", "BuyText",
		};
		layout.getTextBoxes(tbNames, &Title, 6);

		// Warning: weird code coming up
		const char *crap = "000102031\0" "2\0";
		char name[12];
		for (int i = 0; i < 6; i++) {
			strcpy(name, "BtnLeftXX");
			name[7] = crap[i*2];
			name[8] = crap[i*2+1];
			BtnLeft[i] = layout.findPictureByName(name);

			strcpy(name, "BtnMidXX");
			name[6] = crap[i*2];
			name[7] = crap[i*2+1];
			BtnMid[i] = layout.findPictureByName(name);

			strcpy(name, "BtnRightXX");
			name[8] = crap[i*2];
			name[9] = crap[i*2+1];
			BtnRight[i] = layout.findPictureByName(name);

			strcpy(name, "BtnXX");
			name[3] = crap[i*2];
			name[4] = crap[i*2+1];
			Buttons[i] = layout.findPaneByName(name);
		}

		Btn1Base = layout.findPaneByName("Btn1_Base");
		Btn2Base = layout.findPaneByName("Btn2_Base");
		OSReport("Found btn 1,2: %p, %p\n", Btn1Base, Btn2Base);

		leftCol.setTexMap(BtnLeft[0]->material->texMaps);
		midCol.setTexMap(BtnMid[0]->material->texMaps);
		rightCol.setTexMap(BtnRight[0]->material->texMaps);

		for (int i = 1; i < 6; i++) {
			leftCol.applyAlso(BtnLeft[i]->material->texMaps);
			midCol.applyAlso(BtnMid[i]->material->texMaps);
			rightCol.applyAlso(BtnRight[i]->material->texMaps);
		}

		layoutLoaded = true;
	}

	return true;
}


int dWMShop_c::onDelete() {
	deleteModels();
	return layout.free();
}


int dWMShop_c::onExecute() {
	//OSReport("Shop state: %s\n", this->state.getCurrentState()->getName());
	state.execute();

	//OSReport("isFrozen: %s\n\n", isFrozen ? "true" : "false");

	if (visible) {
		lakituModel->execute();

		for (int i = 0; i < 12; i++)
			itemModels[i].execute();
	}

	layout.execAnimations();
	layout.update();

	return true;
}

int dWMShop_c::onDraw() {
	if (visible)
		layout.scheduleForDrawing();

	return true;
}

void dWMShop_c::specialDraw1() {
	if (visible) {
		lakituModel->scaleEase = scaleEase * 2.5f;
		lakituModel->draw();
		for (int i = 0; i < 12; i++) {
			itemModels[i].scaleEase = scaleEase;
			itemModels[i].draw();
		}
	}


//		if (wasOff) { effect.spawn("Wm_ob_greencoinkira", 0, &pos, &rot, &scale); wasOff = false; }

//		if(this->ska.isAnimationDone())
//			this->ska.setCurrentFrame(0.0);
}


void dWMShop_c::show(int shopNumber) {
	shopKind = shopNumber;
	state.setState(&StateID_ShowWait);
}

void makeShopShowUp() {
	dWMShop_c::instance->showShop = true;
}

bool isBPressed() {
	Remocon* rem = GetActiveRemocon();
	int nowPressed = Remocon_GetPressed(rem);
	if(rem->controllerType == 0) {	//Wiimote
		return nowPressed & WPAD_B;
	} else {						// == 1 <-> Wiimote + Nunchuck 
		//OSReport("nowPressed: 0x%x\n", nowPressed);
		//return false;
		return nowPressed & 0x2000;
	}
}

// Hidden
void dWMShop_c::beginState_Hidden() { }
void dWMShop_c::executeState_Hidden() {
	/*int nowPressed = Remocon_GetPressed(GetActiveRemocon());

	OSReport("PtrToWM_CS_SEQ_MNG+0x394: %x\n\n", PtrToWM_CS_SEQ_MNG + 0x394);
	OSReport("PtrToWM_CS_SEQ_MNG+0x394: %p\n\n", (u8*)(PtrToWM_CS_SEQ_MNG + 0x394));*/

	if (showShop) {
		//dActor_c* wmDirector = (dActor_c*)fBase_c::search(WM_DIRECTOR);
		showShop = false;
		//if(*(u8*)((int)(wmDirector) + 0x1A8) == 0) {			//if map is not frozen
			
			state.setState(&StateID_ShowWait);
			FUN_801017c0(PtrToWM_CS_SEQ_MNG, 0x35, 0, 0, 0x80);
			dActor_c* csMng = (dActor_c*)fBase_c::search(COURSE_SELECT_MANAGER);
			*(u8*)((int)(csMng) + 0x53C) = 0;					//hide gameScene
			//*(u8*)((int)(csMng) + 0x545) = 1;			//startedSomeMsgThing = true
		//}
	}
}
void dWMShop_c::endState_Hidden() { }

// ShowWait
void dWMShop_c::beginState_ShowWait() {
	MapSoundPlayer(SoundRelatedClass, SE_SYS_DIALOGUE_IN, 1);

	layout.disableAllAnimations();
	layout.enableNonLoopAnim(SHOW_ALL);
	visible = true;
	scaleEase = 0.0;

	loadInfo();
	loadModels();
}
void dWMShop_c::executeState_ShowWait() {
	OSReport("1");
	if (!layout.isAnimOn(SHOW_ALL)) {
	OSReport("2");
		selected = 0;
	OSReport("3");
		layout.enableNonLoopAnim(ACTIVATE_BUTTON);
	OSReport("4");
		state.setState(&StateID_ButtonActivateWait);
	OSReport("5");
	}
}
void dWMShop_c::endState_ShowWait() {
	MapSoundPlayer(SoundRelatedClass, SE_OBJ_CLOUD_BLOCK_TO_JUGEM, 1);
	timer = 1;
}

// ButtonActivateWait
void dWMShop_c::beginState_ButtonActivateWait() { }
void dWMShop_c::executeState_ButtonActivateWait() {
	if (!layout.isAnyAnimOn())
		state.setState(&StateID_Wait);
}
void dWMShop_c::endState_ButtonActivateWait() { }

// Wait
void dWMShop_c::beginState_Wait() {
	showSelectCursor();
}
void dWMShop_c::executeState_Wait() {
	if (timer < 90) {
		scaleEase = -((cos(timer * 3.14 /20)-0.9)/timer*10)+1;
		timer++;
		return;
	}

	int nowPressed = Remocon_GetPressed(GetActiveRemocon());

	int newSelection = -1;

	if (nowPressed & WPAD_ONE) {
		// Hide the thing
		state.setState(&StateID_HideWait);

	} else if (nowPressed & WPAD_UP) {
		// Move up
		if (selected == 4)
			newSelection = lastTopRowChoice;
		else if (selected == 5)
			newSelection = 4;

	} else if (nowPressed & WPAD_DOWN) {
		// Move down
		if (selected <= 3)
			newSelection = 4;
		else if (selected == 4)
			newSelection = 5;

	} else if (nowPressed & WPAD_LEFT) {
		// Just use the previous choice
		if (selected > 0)
			newSelection = selected - 1;

	} else if (nowPressed & WPAD_RIGHT) {
		// Just use the next choice
		if (selected < 5)
			newSelection = selected + 1;

	} else if (nowPressed & WPAD_TWO) {
		if (!lakituModel->playingNotEnough)
			buyItem(selected);
		else
			OSReport("Not Enough is still playing!\n");
	}

	if (newSelection > -1) {
		MapSoundPlayer(SoundRelatedClass, SE_SYS_CURSOR, 1);

		layout.enableNonLoopAnim(DEACTIVATE_BUTTON+selected);
		layout.enableNonLoopAnim(ACTIVATE_BUTTON+newSelection);

		selected = newSelection;
		if (newSelection <= 3)
			lastTopRowChoice = newSelection;

		showSelectCursor();
	}
}
void dWMShop_c::endState_Wait() { }

// HideWait
void dWMShop_c::beginState_HideWait() {
	MapSoundPlayer(SoundRelatedClass, SE_SYS_DIALOGUE_OUT_AUTO, 1);
	layout.enableNonLoopAnim(HIDE_ALL);
	layout.enableNonLoopAnim(DEACTIVATE_BUTTON+selected);

	timer = 26;
	MapSoundPlayer(SoundRelatedClass, SE_OBJ_CS_KINOHOUSE_DISAPP, 1);

	HideSelectCursor(SelectCursorPointer, 0);
}
void dWMShop_c::executeState_HideWait() {
	if (timer > 0) {
		timer--;
		scaleEase = -((cos(timer * 3.14 /13.5)-0.9)/timer*10)+1;
		if (scaleEase < 0.0f)
			scaleEase = 0.0f;
	} else {
		dActor_c* csMng = (dActor_c*)fBase_c::search(COURSE_SELECT_MANAGER);
		dActor_c* wmDirector = (dActor_c*)fBase_c::search(WM_DIRECTOR);
		*(u8*)((int)(csMng) + 0x53C) = 1;			//unhide gameScene
		FUN_808fbd10((int)wmDirector);				//unfreeze map
		
		//*(u8*)((int)(csMng) + 0x548) = 0;			//doesStockItemSelectWait=false
		//*(u8*)((int)(csMng) + 0x546) = 1;			//endedSomeMsgThing = true
		//*(u8*)((int)(csMng) + 0x545) = 0;			//startedSomeMsgThing = false
		  
	}

	if (!layout.isAnimOn(HIDE_ALL))
		state.setState(&StateID_Hidden);
}
void dWMShop_c::endState_HideWait() {
	deleteModels();
	visible = false;
}


// Powerup Listing:
// 0 = Mushroom		- 1
	// 1 = Fireflower	- 2
	// 2 = Iceflower	- 2
		// 3 = Penguin		- 3
		// 4 = Propeller	- 3
	// 5 = MiniShroom	- 2
	// 6 = Starman		- 2
		// 7 = Hammer		- 3
	// 8 = 1-ups		- 2
//
// Format: 1coin, 1coin, 2coins, 3coins, 5coins[3] (Value 6-9), 8coins[5] (Value 10-15)
//
// Possible 5 coin combos =  2,2,2  /  1,2,3  /  2,3,2  /  3,2,3  /  3,3,3
// Possible 8 coin combos =  1,1,2,3,3  /  1,2,2,3,3  /  1,2,3,3,3  /  2,2,2,3,3  /  2,2,3,3,3  /  1,3,3,3,3  /  2,3,3,3,3  /  3,3,3,3,3

const dWMShop_c::ItemTypes dWMShop_c::Inventory[10][12] = { 
	{ // Yoshi's Island
		MUSHROOM, FIRE_FLOWER, ICE_FLOWER, PROPELLER,
		HAMMER, GOLD_FLOWER, SPIKE_SHROOM,
		BOOMERANG, FROG, CLOUD, WAND, ONE_UP
	},
	{ // Desert
		MUSHROOM, FIRE_FLOWER, ICE_FLOWER, PROPELLER,
		FIRE_FLOWER, STARMAN, FIRE_FLOWER,
		MUSHROOM, FIRE_FLOWER, FIRE_FLOWER, PROPELLER, PROPELLER
	},
	{ // Mountain
		MUSHROOM, FIRE_FLOWER, MINI_SHROOM, PROPELLER,
		MUSHROOM, MINI_SHROOM, PROPELLER,
		MUSHROOM, MINI_SHROOM, PROPELLER, PROPELLER, HAMMER
	},
	{ // Japan
		MUSHROOM, FIRE_FLOWER, ONE_UP, HAMMER,
		ONE_UP, ONE_UP, ONE_UP,
		PROPELLER, ICE_FLOWER, ONE_UP, FIRE_FLOWER, PROPELLER
	},
	{ // FreezeFlame
		MUSHROOM, FIRE_FLOWER, ICE_FLOWER, PENGUIN,
		ICE_FLOWER, PENGUIN, ICE_FLOWER,
		ICE_FLOWER, PENGUIN, PENGUIN, PENGUIN, ICE_FLOWER
	},
	{ // Ghost
		MUSHROOM, FIRE_FLOWER, STARMAN, PROPELLER,
		MINI_SHROOM, PROPELLER, MINI_SHROOM,
		PROPELLER, PROPELLER, MUSHROOM, PROPELLER, PROPELLER
	},
	{ // Space
		MUSHROOM, STARMAN, ONE_UP, HAMMER,
		STARMAN, STARMAN, STARMAN,
		HAMMER, HAMMER, ONE_UP, HAMMER, HAMMER
	},
	{ // Koopa
		MUSHROOM, ONE_UP, PROPELLER, HAMMER,
		HAMMER, PROPELLER, HAMMER,
		PROPELLER, HAMMER, PROPELLER, HAMMER, PROPELLER
	},
	{ // Unknown
		MUSHROOM, MUSHROOM, MUSHROOM, MUSHROOM,
		MUSHROOM, MUSHROOM, MUSHROOM,
		MUSHROOM, MUSHROOM, MUSHROOM, MUSHROOM, MUSHROOM
	},
	{ // Goldwood
		MUSHROOM, FIRE_FLOWER, ONE_UP, PENGUIN,
		FIRE_FLOWER, PROPELLER, FIRE_FLOWER,
		FIRE_FLOWER, FIRE_FLOWER, STARMAN, FIRE_FLOWER, FIRE_FLOWER
	}
};

void dWMShop_c::loadModels() {
	lakituModel = new ShopModel_c;
	lakituModel->setupLakitu(shopKind);
	lakituModel->x = 240.0f;
	lakituModel->y = 220.0f;
	if (!IsWideScreen()) {
		lakituModel->x = (0.731f * (lakituModel->x + 416.0f)) - 292.0f;
		lakituModel->y *= 0.7711f;
		lakituModel->y += 52.0f;
		lakituModel->scaleFactor = 0.77f;
	}

	static const float itemPos[ITEM_COUNT][2] = {
		{357.0f, 276.0f},
		{450.0f, 276.0f},
		{543.0f, 276.0f},
		{636.0f, 276.0f},

		{380.0f, 190.0f},
		{462.0f, 190.0f},
		{544.0f, 190.0f},

		{363.0f, 104.0f},
		{413.0f, 104.0f},
		{463.0f, 104.0f},
		{513.0f, 104.0f},
		{563.0f, 104.0f},
	};

	itemModels = new ShopModel_c[ITEM_COUNT];
	
	OSReport("new ShopModel_c\n");
	
	for (int i = 0; i < ITEM_COUNT; i++) {
		OSReport("for\n");		
		float effectiveX = itemPos[i][0];
		float effectiveY = itemPos[i][1];
		if (!IsWideScreen()) {
			effectiveX = (0.731f * (effectiveX + 416.0f)) - 296.0f;
			effectiveY *= 0.7711f;
			effectiveY += 50.0f;
			itemModels[i].scaleFactor = 1.6f;
		}
		itemModels[i].setupItem(effectiveX, effectiveY, Inventory[shopKind][i]);
		OSReport("setupItem\n");
	}
}
void dWMShop_c::deleteModels() {
	if (lakituModel)
		delete lakituModel;
	lakituModel = 0;

	if (itemModels)
		delete[] itemModels;
	itemModels = 0;
}


void dWMShop_c::loadInfo() {
	SaveBlock *save = GetSaveFile()->GetBlock(-1);

	//missing color information in original save file!
	s16 hue        = 138;
	s8  saturation = 50;
	s8  lightness  = 30;
	
	//leftCol.colourise(save->hudHintH, save->hudHintS, save->hudHintL);
	//midCol.colourise(save->hudHintH, save->hudHintS, save->hudHintL);
	//rightCol.colourise(save->hudHintH, save->hudHintS, save->hudHintL);
	leftCol.colourise(hue, saturation, lightness);
	midCol.colourise(hue, saturation, lightness);
	rightCol.colourise(hue, saturation, lightness);

	// find out the shop name
	dLevelInfo_c::entry_s *shopNameEntry =
		dLevelInfo_c::s_info.searchBySlot(shopKind, 98);

	wchar_t shopName[100];
	// TODO: refactor this a bit
	const char *sourceName = dLevelInfo_c::s_info.getNameForLevel(shopNameEntry);
	int charCount = 0;
	
	while (*sourceName != 0 && charCount < 99) {
		shopName[charCount] = *sourceName;
		sourceName++;
		charCount++;
	}
	shopName[charCount] = 0;

	Title->SetString(shopName);
	TitleShadow->SetString(shopName);

	// load the coin count
	int scCount = getUnspentStarCoinCount();
	WriteNumberToTextBox(&scCount, CoinCount, false);
	WriteNumberToTextBox(&scCount, CoinCountShadow, false);


	WriteBMGToTextBox(BackText, GetBMG(), 2, 58, 0);
	WriteBMGToTextBox(BuyText, GetBMG(), 302, 4, 0);
}


void dWMShop_c::buyItem(int item) {
	static int itemDefs[6][3] = {
		// Cost, Start Index, Count
		{1, 0, 1}, {2, 1, 1}, {2, 2, 1}, {3, 3, 1},
		{5, 4, 3}, {8, 7, 5}
	};

	int cost = itemDefs[item][0], cash = getUnspentStarCoinCount();

	if (cost > cash) {
		OSReport("Started playing Not Enough\n");
		//lakituModel->playingNotEnough = true;
		//lakituModel->playAnim("notenough", 1.0f, 1);
		MapSoundPlayer(SoundRelatedClass, SE_SYS_INVALID, 1);
		return;
	}

	MapSoundPlayer(SoundRelatedClass, SE_SYS_DECIDE, 1);

	SaveFile *file = GetSaveFile();
	SaveBlock *block = file->GetBlock(file->header.current_file);

	coinsRemaining = cost;

	// Work out what we need to apply
	int appliedItems[ITEM_TYPE_COUNT];
	for (int i = 0; i < ITEM_TYPE_COUNT; i++)
		appliedItems[i] = 0;

	int invStartIndex = itemDefs[item][1], invCount = itemDefs[item][2];
	for (int i = 0; i < invCount; i++)
		appliedItems[(int)Inventory[shopKind][invStartIndex+i]]++;

	dStockItem_c* stockItemPtr = (dStockItem_c*)fBase_c::search(STOCK_ITEM);
	for (int i = 0; i < 14; i++) {
		block->new_powerups_available[i] += appliedItems[i];

		if (block->new_powerups_available[i] > 99)
			block->new_powerups_available[i] = 99;

		stockItemPtr->newCounts[i] = block->new_powerups_available[i];

	}

	// Apply lives to everyone
	for (int i = 0; i < 4; i++) {
		if (Player_Active[i]) {
			int id = Player_ID[i];
			Player_Lives[id] += appliedItems[(int)ONE_UP];
			if (Player_Lives[id] > 99)
				Player_Lives[id] = 99;
		}
	}

	if (appliedItems[(int)ONE_UP] > 0)
		MapSoundPlayer(SoundRelatedClass, SE_SYS_100COIN_ONE_UP, 1);

	dActor_c* csMng = (dActor_c*)fBase_c::search(COURSE_SELECT_MANAGER);
	dCourseSelectGuide_c__loadLives((int)(csMng) + 200);


	state.setState(&StateID_CoinCountdown);
	HideSelectCursor(SelectCursorPointer, 0);
}


void dWMShop_c::beginState_CoinCountdown() {
	timerForCoinCountdown = 8;
}

void dWMShop_c::endState_CoinCountdown() { }

void dWMShop_c::executeState_CoinCountdown() {
	/* removed for testing
	timerForCoinCountdown--;
	if (timerForCoinCountdown <= 0) {

		SaveBlock *save = GetSaveFile()->GetBlock(-1);
		save->spentStarCoins++;

		// load the coin count
		int scCount = getUnspentStarCoinCount();
		WriteNumberToTextBox(&scCount, CoinCount, false);
		WriteNumberToTextBox(&scCount, CoinCountShadow, false);

		layout.enableNonLoopAnim(COUNT_COIN);
		VEC3 efPos = {
			CoinCount->effectiveMtx[0][3],
			CoinCount->effectiveMtx[1][3],
			0.0f};

		// ARGHHHHHHHHHHHHHHHHh.
		if (IsWideScreen()) {
			float div = 5.0f;
			if (scCount < 100)
				div = 3.6f;
			if (scCount < 10)
				div = 2.7f;
			efPos.x -= (CoinCount->size.x / div);
			efPos.y -= (CoinCount->size.y / 2.0f);
		} else {
			float div = 5.8f;
			if (scCount < 100)
				div = 8.2f;
			if (scCount < 10)
				div = 14.5f;
			efPos.x += (CoinCount->size.x / div);
			efPos.y -= (CoinCount->size.y / 2.8f);
		}

		VEC3 efScale = {0.7f, 0.7f, 0.7f};
		SpawnEffect("Wm_2d_moviecoinvanish", 0, &efPos, 0, &efScale);

		coinsRemaining--;
		if (coinsRemaining <= 0) {
			MapSoundPlayer(SoundRelatedClass, SE_PLY_GET_ITEM_AGAIN, 1);
			state.setState(&StateID_Wait);
		} else {
			MapSoundPlayer(SoundRelatedClass, SE_SYS_STAR_COIN_PAY, 1);
			beginState_CoinCountdown();
		}
	}*/state.setState(&StateID_Wait);
}


void dWMShop_c::showSelectCursor() {
	switch (selected) {
		case 4: UpdateSelectCursor(Btn1Base, 0, false); break;
		case 5: UpdateSelectCursor(Btn2Base, 0, false); break;
		default: UpdateSelectCursor(Buttons[selected], 0, false);
	}
}


//
// processed\../src/worldmapWorldSelection.cpp
//

#ifndef __WORLDSELECTION_H
#define __WORLDSELECTION_H

#include "texmapcolouriser.h"

class dWMSelection_c : public dActor_c {
	public:
		static dWMSelection_c *build();
		static dWMSelection_c *instance;

		dWMSelection_c();

		int onCreate();
		int onDelete();
		int onExecute();
		int onDraw();
		void specialDraw1();

		bool layoutLoaded;
		m2d::EmbedLayout_c layout;

		bool visible;
		float scaleEase;
		int timer;

		int selected, lastTopRowChoice;
		int shopKind;

		int coinsRemaining, timerForCoinCountdown;
		
		bool showShop;

		enum Animation {
			SHOW_ALL = 0,
			HIDE_ALL = 1,
			ACTIVATE_BUTTON = 2, // 3, 4, 5, 6, 7
			DEACTIVATE_BUTTON = 8, // 9, 10, 11, 12, 13
			COUNT_COIN = 14,
		};

		enum ItemTypes {
			MUSHROOM = 0,
			FIRE_FLOWER,
			PROPELLER,
			ICE_FLOWER,
			PENGUIN,
			MINI_SHROOM,
			STARMAN,
			HAMMER,
			GOLD_FLOWER,
			SPIKE_SHROOM,
			BOOMERANG,
			FROG,
			CLOUD,
			WAND,
			ONE_UP,
			ITEM_TYPE_COUNT
		};

		enum _Constants {
			ITEM_COUNT = 12,
		};

		static const ItemTypes Inventory[10][12];

		nw4r::lyt::TextBox
			*Title, *TitleShadow,
			*CoinCount, *CoinCountShadow,
			*BackText, *BuyText;

		nw4r::lyt::Picture
			*BtnLeft[6], *BtnMid[6], *BtnRight[6];

		nw4r::lyt::Pane
			*Buttons[6], *Btn1Base, *Btn2Base;

		dTexMapColouriser_c leftCol, midCol, rightCol;

		class ShopModel_c {
			public:
				mHeapAllocator_c allocator;

				nw4r::g3d::ResFile res;
				m3d::mdl_c model;
				m3d::anmChr_c animation;

				float x, y, scaleFactor, scaleEase;
				bool isLakitu, playingNotEnough;

				void setupItem(float x, float y, ItemTypes type);
				void setupLakitu(int id);
				void execute();
				void draw();
				void playAnim(const char *name, float rate, char loop);
		};

		ShopModel_c *itemModels;
		ShopModel_c *lakituModel;

		void show(int shopNumber);

		void loadInfo();
		void loadModels();
		void deleteModels();

		void buyItem(int item);

		void showSelectCursor();

		dStateWrapper_c<dWMSelection_c> state;

		USING_STATES(dWMSelection_c);
		DECLARE_STATE(Hidden);
		DECLARE_STATE(ShowWait);
		DECLARE_STATE(ButtonActivateWait);
		DECLARE_STATE(CoinCountdown);
		DECLARE_STATE(Wait);
		DECLARE_STATE(HideWait);
};

#endif

extern int PtrToWM_CS_SEQ_MNG;
extern "C" bool FUN_801017c0(int, int, int, int, int);
extern "C" void FUN_808fbd10(int);
extern "C" void dCourseSelectGuide_c__loadLives(int);

CREATE_STATE(dWMSelection_c, Hidden);
CREATE_STATE(dWMSelection_c, ShowWait);
CREATE_STATE(dWMSelection_c, ButtonActivateWait);
CREATE_STATE(dWMSelection_c, CoinCountdown);
CREATE_STATE(dWMSelection_c, Wait);
CREATE_STATE(dWMSelection_c, HideWait);


void dWMSelection_c::ShopModel_c::setupItem(float x, float y, ItemTypes type) {
	static const char* Produce[ITEM_TYPE_COUNT][4] = { 
		{ "I_kinoko", 		"g3d/I_kinoko.brres", 			"I_kinoko", 			"wait2" },
		{ "I_fireflower", 	"g3d/I_fireflower.brres", 		"I_fireflower", 		"wait2" },
		{ "I_propeller", 	"g3d/I_propeller.brres", 		"I_propeller_model", 	"wait2" },
		{ "I_iceflower", 	"g3d/I_iceflower.brres", 		"I_iceflower", 			"wait2" },
		{ "I_penguin", 		"g3d/I_penguin.brres", 			"I_penguin", 			"wait2" },
		{ "I_kinoko_bundle","g3d/I_mini_kinoko.brres", 		"I_mini_kinoko", 		"wait2" },
		{ "I_star", 		"g3d/I_star.brres", 			"I_star", 				"wait2" },
		{ "I_hammer", 		"g3d/I_fireflower.brres",		"I_fireflower",			"wait2" },
		{ "I_gold",			"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_spike",		"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_boomerang",	"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_frog",			"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_cloud",		"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_wand",			"g3d/I_fireflower.brres",		"I_fireflower", 		"wait2" },
		{ "I_kinoko_bundle","g3d/I_life_kinoko.brres", 		"I_life_kinoko", 		"wait2" },
		
	};

	this->x = x;
	this->y = y;
	
	scaleFactor = 2.3f;

	int id = (int)type;
	isLakitu = false;

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	res.data = getResource(Produce[id][0], Produce[id][1]);
	nw4r::g3d::ResMdl mdlRes = res.GetResMdl(Produce[id][2]);
	model.setup(mdlRes, &allocator, 0x224, 1, 0);

	SetupTextures_Item(&model, 1);

	nw4r::g3d::ResAnmChr anmChr = res.GetResAnmChr(Produce[id][3]);
	animation.setup(mdlRes, anmChr, &allocator, 0);
	playAnim(Produce[id][3], 1.0f, 0);

	allocator.unlink();
}

void dWMSelection_c::ShopModel_c::setupLakitu(int id) {
	static const char* models[10] = { 
		"g3d/yoshi.brres", "g3d/desert.brres", "g3d/mountain.brres", "g3d/sakura.brres", "g3d/santa.brres", 
		"g3d/ghost.brres", "g3d/space.brres", "g3d/koopa.brres", "g3d/sewer.brres", "g3d/goldwood.brres" 
	};

	scaleFactor = 1.0f;
	scaleEase = 0.0f;
	this->isLakitu = true;

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	res.data = getResource("Rosalina", "g3d/rosalina.brres"/*models[id]*/);
	nw4r::g3d::ResMdl mdlRes = res.GetResMdl("rosalina");
	model.setup(mdlRes, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&model, 1);

	nw4r::g3d::ResAnmChr anmChr = res.GetResAnmChr("wait");
	animation.setup(mdlRes, anmChr, &allocator, 0);

	playAnim("wait", 1.0f, 0);
	playingNotEnough = false;

	allocator.unlink();
}

void dWMSelection_c::ShopModel_c::playAnim(const char *name, float rate, char loop) {
	nw4r::g3d::ResAnmChr anmChr = res.GetResAnmChr(name);
	animation.bind(&model, anmChr, loop);
	model.bindAnim(&animation, 0.0f);
	animation.setUpdateRate(rate);
}

void dWMSelection_c::ShopModel_c::execute() {
	model._vf1C();

	if(this->animation.isAnimationDone()) {
		OSReport("Animaiton Complete");
		if (this->isLakitu) {
			OSReport("Setting animation to idle");
			playAnim("wait", 1.0f, 0);
			this->animation.setCurrentFrame(0.0);
			if (playingNotEnough) {
				OSReport("Detected Not Enough animation as being over\n");
				playingNotEnough = false;
			}
		}
	}	
}

void dWMSelection_c::ShopModel_c::draw() {
	mMtx mtx;
	mtx.translation(x, y, 1000.0f);
	model.setDrawMatrix(mtx);

	float s = scaleFactor * scaleEase;

	Vec scale = {s, s, s};
	model.setScale(&scale);

	model.calcWorld(false);
	model.scheduleForDrawing();
}



dWMSelection_c *dWMSelection_c::instance = 0;

dWMSelection_c *dWMSelection_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dWMSelection_c));
	dWMSelection_c *c = new(buffer) dWMSelection_c;

	instance = c;
	return c;
}

dWMSelection_c::dWMSelection_c() : state(this, &StateID_Hidden) {
	layoutLoaded = false;
	visible = false;
}

int dWMSelection_c::onCreate() {
	showShop = false;
	if (!layoutLoaded) {
		bool gotFile = layout.loadArc("worldSelect.arc", false);
		if (!gotFile)
			return false;

		selected = 0;
		lastTopRowChoice = 0;

		layout.build("shop.brlyt");

		if (IsWideScreen()) {
			layout.layout.rootPane->scale.x = 0.735f;
		} else {
			layout.clippingEnabled = true;
			layout.clipX = 0;
			layout.clipY = 52;
			layout.clipWidth = 640;
			layout.clipHeight = 352;
			layout.layout.rootPane->scale.x = 0.731f;
			layout.layout.rootPane->scale.y = 0.7711f;
		}

		static const char *brlanNames[] = {
			"shop_Show.brlan",
			"shop_Hide.brlan",
			"shop_ActivateButton.brlan",
			"shop_DeactivateButton.brlan",
			"shop_CountCoin.brlan"
		};
		static const char *groupNames[] = {
			"BaseGroup", "BaseGroup",
			"GBtn00", "GBtn01", "GBtn02", "GBtn03", "GBtn1", "GBtn2",
			"GBtn00", "GBtn01", "GBtn02", "GBtn03", "GBtn1", "GBtn2",
			"GCoinCount"
		};
		static const int brlanIDs[] = {
			0, 1,
			2, 2, 2, 2, 2, 2,
			3, 3, 3, 3, 3, 3,
			4,
		};

		layout.loadAnimations(brlanNames, 5);
		layout.loadGroups(groupNames, brlanIDs, 15);
		layout.disableAllAnimations();

		layout.drawOrder = 1;

		static const char *tbNames[] = {
			"Title", "TitleShadow",
			"CoinCount", "CoinCountShadow",
			"BackText", "BuyText",
		};
		layout.getTextBoxes(tbNames, &Title, 6);

		// Warning: weird code coming up
		const char *crap = "000102031\0" "2\0";
		char name[12];
		for (int i = 0; i < 6; i++) {
			strcpy(name, "BtnLeftXX");
			name[7] = crap[i*2];
			name[8] = crap[i*2+1];
			BtnLeft[i] = layout.findPictureByName(name);

			strcpy(name, "BtnMidXX");
			name[6] = crap[i*2];
			name[7] = crap[i*2+1];
			BtnMid[i] = layout.findPictureByName(name);

			strcpy(name, "BtnRightXX");
			name[8] = crap[i*2];
			name[9] = crap[i*2+1];
			BtnRight[i] = layout.findPictureByName(name);

			strcpy(name, "BtnXX");
			name[3] = crap[i*2];
			name[4] = crap[i*2+1];
			Buttons[i] = layout.findPaneByName(name);
		}

		Btn1Base = layout.findPaneByName("Btn1_Base");
		Btn2Base = layout.findPaneByName("Btn2_Base");
		OSReport("Found btn 1,2: %p, %p\n", Btn1Base, Btn2Base);

		leftCol.setTexMap(BtnLeft[0]->material->texMaps);
		midCol.setTexMap(BtnMid[0]->material->texMaps);
		rightCol.setTexMap(BtnRight[0]->material->texMaps);

		for (int i = 1; i < 6; i++) {
			leftCol.applyAlso(BtnLeft[i]->material->texMaps);
			midCol.applyAlso(BtnMid[i]->material->texMaps);
			rightCol.applyAlso(BtnRight[i]->material->texMaps);
		}

		layoutLoaded = true;
	}

	return true;
}


int dWMSelection_c::onDelete() {
	deleteModels();
	return layout.free();
}


int dWMSelection_c::onExecute() {
	//OSReport("Shop state: %s\n", this->state.getCurrentState()->getName());
	state.execute();

	//OSReport("isFrozen: %s\n\n", isFrozen ? "true" : "false");

	if (visible) {
		lakituModel->execute();

		for (int i = 0; i < 12; i++)
			itemModels[i].execute();
	}

	layout.execAnimations();
	layout.update();

	return true;
}

int dWMSelection_c::onDraw() {
	if (visible)
		layout.scheduleForDrawing();

	return true;
}

void dWMSelection_c::specialDraw1() {
	if (visible) {
		lakituModel->scaleEase = scaleEase * 2.5f;
		lakituModel->draw();
		for (int i = 0; i < 12; i++) {
			itemModels[i].scaleEase = scaleEase;
			itemModels[i].draw();
		}
	}


//		if (wasOff) { effect.spawn("Wm_ob_greencoinkira", 0, &pos, &rot, &scale); wasOff = false; }

//		if(this->ska.isAnimationDone())
//			this->ska.setCurrentFrame(0.0);
}


void dWMSelection_c::show(int shopNumber) {
	shopKind = shopNumber;
	state.setState(&StateID_ShowWait);
}

void makeWorldSelectionShowUp() {
	dWMSelection_c::instance->showShop = true;
}

// Hidden
void dWMSelection_c::beginState_Hidden() { }
void dWMSelection_c::executeState_Hidden() {
	/*int nowPressed = Remocon_GetPressed(GetActiveRemocon());

	OSReport("PtrToWM_CS_SEQ_MNG+0x394: %x\n\n", PtrToWM_CS_SEQ_MNG + 0x394);
	OSReport("PtrToWM_CS_SEQ_MNG+0x394: %p\n\n", (u8*)(PtrToWM_CS_SEQ_MNG + 0x394));*/

	if (showShop) {
		//dActor_c* wmDirector = (dActor_c*)fBase_c::search(WM_DIRECTOR);
		showShop = false;
		//if(*(u8*)((int)(wmDirector) + 0x1A8) == 0) {			//if map is not frozen
			
			state.setState(&StateID_ShowWait);
			//FUN_801017c0(PtrToWM_CS_SEQ_MNG, 0x35, 0, 0, 0x80);
			dActor_c* csMng = (dActor_c*)fBase_c::search(COURSE_SELECT_MANAGER);
			*(u8*)((int)(csMng) + 0x53C) = 0;					//hide gameScene
			//*(u8*)((int)(csMng) + 0x545) = 1;			//startedSomeMsgThing = true
		//}
	}
}
void dWMSelection_c::endState_Hidden() { }

// ShowWait
void dWMSelection_c::beginState_ShowWait() {
	MapSoundPlayer(SoundRelatedClass, SE_SYS_DIALOGUE_IN, 1);

	layout.disableAllAnimations();
	layout.enableNonLoopAnim(SHOW_ALL);
	visible = true;
	scaleEase = 0.0;

	loadInfo();
	loadModels();
}
void dWMSelection_c::executeState_ShowWait() {
	OSReport("1");
	if (!layout.isAnimOn(SHOW_ALL)) {
	OSReport("2");
		selected = 0;
	OSReport("3");
		layout.enableNonLoopAnim(ACTIVATE_BUTTON);
	OSReport("4");
		state.setState(&StateID_ButtonActivateWait);
	OSReport("5");
	}
}
void dWMSelection_c::endState_ShowWait() {
	MapSoundPlayer(SoundRelatedClass, SE_OBJ_CLOUD_BLOCK_TO_JUGEM, 1);
	timer = 1;
}

// ButtonActivateWait
void dWMSelection_c::beginState_ButtonActivateWait() { }
void dWMSelection_c::executeState_ButtonActivateWait() {
	if (!layout.isAnyAnimOn())
		state.setState(&StateID_Wait);
}
void dWMSelection_c::endState_ButtonActivateWait() { }

// Wait
void dWMSelection_c::beginState_Wait() {
	showSelectCursor();
}
void dWMSelection_c::executeState_Wait() {
	if (timer < 90) {
		scaleEase = -((cos(timer * 3.14 /20)-0.9)/timer*10)+1;
		timer++;
		return;
	}

	int nowPressed = Remocon_GetPressed(GetActiveRemocon());

	int newSelection = -1;

	if (nowPressed & WPAD_ONE) {
		// Hide the thing
		state.setState(&StateID_HideWait);

	} else if (nowPressed & WPAD_UP) {
		// Move up
		if (selected == 4)
			newSelection = lastTopRowChoice;
		else if (selected == 5)
			newSelection = 4;

	} else if (nowPressed & WPAD_DOWN) {
		// Move down
		if (selected <= 3)
			newSelection = 4;
		else if (selected == 4)
			newSelection = 5;

	} else if (nowPressed & WPAD_LEFT) {
		// Just use the previous choice
		if (selected > 0)
			newSelection = selected - 1;

	} else if (nowPressed & WPAD_RIGHT) {
		// Just use the next choice
		if (selected < 5)
			newSelection = selected + 1;

	} else if (nowPressed & WPAD_TWO) {
		if (!lakituModel->playingNotEnough)
			buyItem(selected);
		else
			OSReport("Not Enough is still playing!\n");
	}

	if (newSelection > -1) {
		MapSoundPlayer(SoundRelatedClass, SE_SYS_CURSOR, 1);

		layout.enableNonLoopAnim(DEACTIVATE_BUTTON+selected);
		layout.enableNonLoopAnim(ACTIVATE_BUTTON+newSelection);

		selected = newSelection;
		if (newSelection <= 3)
			lastTopRowChoice = newSelection;

		showSelectCursor();
	}
}
void dWMSelection_c::endState_Wait() { }

// HideWait
void dWMSelection_c::beginState_HideWait() {
	MapSoundPlayer(SoundRelatedClass, SE_SYS_DIALOGUE_OUT_AUTO, 1);
	layout.enableNonLoopAnim(HIDE_ALL);
	layout.enableNonLoopAnim(DEACTIVATE_BUTTON+selected);

	timer = 26;
	MapSoundPlayer(SoundRelatedClass, SE_OBJ_CS_KINOHOUSE_DISAPP, 1);

	HideSelectCursor(SelectCursorPointer, 0);
}
void dWMSelection_c::executeState_HideWait() {
	if (timer > 0) {
		timer--;
		scaleEase = -((cos(timer * 3.14 /13.5)-0.9)/timer*10)+1;
		if (scaleEase < 0.0f)
			scaleEase = 0.0f;
	} else {
		dActor_c* csMng = (dActor_c*)fBase_c::search(COURSE_SELECT_MANAGER);
		dActor_c* wmDirector = (dActor_c*)fBase_c::search(WM_DIRECTOR);
		*(u8*)((int)(csMng) + 0x53C) = 1;			//unhide gameScene
		FUN_808fbd10((int)wmDirector);				//unfreeze map
		
		//*(u8*)((int)(csMng) + 0x548) = 0;			//doesStockItemSelectWait=false
		//*(u8*)((int)(csMng) + 0x546) = 1;			//endedSomeMsgThing = true
		//*(u8*)((int)(csMng) + 0x545) = 0;			//startedSomeMsgThing = false
		  
	}

	if (!layout.isAnimOn(HIDE_ALL))
		state.setState(&StateID_Hidden);
}
void dWMSelection_c::endState_HideWait() {
	deleteModels();
	visible = false;
}


// Powerup Listing:
// 0 = Mushroom		- 1
	// 1 = Fireflower	- 2
	// 2 = Iceflower	- 2
		// 3 = Penguin		- 3
		// 4 = Propeller	- 3
	// 5 = MiniShroom	- 2
	// 6 = Starman		- 2
		// 7 = Hammer		- 3
	// 8 = 1-ups		- 2
//
// Format: 1coin, 1coin, 2coins, 3coins, 5coins[3] (Value 6-9), 8coins[5] (Value 10-15)
//
// Possible 5 coin combos =  2,2,2  /  1,2,3  /  2,3,2  /  3,2,3  /  3,3,3
// Possible 8 coin combos =  1,1,2,3,3  /  1,2,2,3,3  /  1,2,3,3,3  /  2,2,2,3,3  /  2,2,3,3,3  /  1,3,3,3,3  /  2,3,3,3,3  /  3,3,3,3,3

const dWMSelection_c::ItemTypes dWMSelection_c::Inventory[10][12] = { 
	{ // Yoshi's Island
		MUSHROOM, MUSHROOM, MUSHROOM, MUSHROOM,
		MUSHROOM, MUSHROOM, MUSHROOM,
		MUSHROOM, MUSHROOM, MUSHROOM, MUSHROOM, MUSHROOM
	},
	{ // Desert
		MUSHROOM, FIRE_FLOWER, ICE_FLOWER, PROPELLER,
		FIRE_FLOWER, STARMAN, FIRE_FLOWER,
		MUSHROOM, FIRE_FLOWER, FIRE_FLOWER, PROPELLER, PROPELLER
	},
	{ // Mountain
		MUSHROOM, FIRE_FLOWER, MINI_SHROOM, PROPELLER,
		MUSHROOM, MINI_SHROOM, PROPELLER,
		MUSHROOM, MINI_SHROOM, PROPELLER, PROPELLER, HAMMER
	},
	{ // Japan
		MUSHROOM, FIRE_FLOWER, ONE_UP, HAMMER,
		ONE_UP, ONE_UP, ONE_UP,
		PROPELLER, ICE_FLOWER, ONE_UP, FIRE_FLOWER, PROPELLER
	},
	{ // FreezeFlame
		MUSHROOM, FIRE_FLOWER, ICE_FLOWER, PENGUIN,
		ICE_FLOWER, PENGUIN, ICE_FLOWER,
		ICE_FLOWER, PENGUIN, PENGUIN, PENGUIN, ICE_FLOWER
	},
	{ // Ghost
		MUSHROOM, FIRE_FLOWER, STARMAN, PROPELLER,
		MINI_SHROOM, PROPELLER, MINI_SHROOM,
		PROPELLER, PROPELLER, MUSHROOM, PROPELLER, PROPELLER
	},
	{ // Space
		MUSHROOM, STARMAN, ONE_UP, HAMMER,
		STARMAN, STARMAN, STARMAN,
		HAMMER, HAMMER, ONE_UP, HAMMER, HAMMER
	},
	{ // Koopa
		MUSHROOM, ONE_UP, PROPELLER, HAMMER,
		HAMMER, PROPELLER, HAMMER,
		PROPELLER, HAMMER, PROPELLER, HAMMER, PROPELLER
	},
	{ // Unknown
		MUSHROOM, MUSHROOM, MUSHROOM, MUSHROOM,
		MUSHROOM, MUSHROOM, MUSHROOM,
		MUSHROOM, MUSHROOM, MUSHROOM, MUSHROOM, MUSHROOM
	},
	{ // Goldwood
		MUSHROOM, FIRE_FLOWER, ONE_UP, PENGUIN,
		FIRE_FLOWER, PROPELLER, FIRE_FLOWER,
		FIRE_FLOWER, FIRE_FLOWER, STARMAN, FIRE_FLOWER, FIRE_FLOWER
	}
};

void dWMSelection_c::loadModels() {
	lakituModel = new ShopModel_c;
	lakituModel->setupLakitu(shopKind);
	lakituModel->x = 240.0f;
	lakituModel->y = 220.0f;
	if (!IsWideScreen()) {
		lakituModel->x = (0.731f * (lakituModel->x + 416.0f)) - 292.0f;
		lakituModel->y *= 0.7711f;
		lakituModel->y += 52.0f;
		lakituModel->scaleFactor = 0.77f;
	}

	static const float itemPos[ITEM_COUNT][2] = {
		{357.0f, 276.0f},
		{450.0f, 276.0f},
		{543.0f, 276.0f},
		{636.0f, 276.0f},

		{380.0f, 190.0f},
		{462.0f, 190.0f},
		{544.0f, 190.0f},

		{363.0f, 104.0f},
		{413.0f, 104.0f},
		{463.0f, 104.0f},
		{513.0f, 104.0f},
		{563.0f, 104.0f},
	};

	itemModels = new ShopModel_c[ITEM_COUNT];
	
	OSReport("new ShopModel_c\n");
	
	for (int i = 0; i < ITEM_COUNT; i++) {
		OSReport("for\n");		
		float effectiveX = itemPos[i][0];
		float effectiveY = itemPos[i][1];
		if (!IsWideScreen()) {
			effectiveX = (0.731f * (effectiveX + 416.0f)) - 296.0f;
			effectiveY *= 0.7711f;
			effectiveY += 50.0f;
			itemModels[i].scaleFactor = 1.6f;
		}
		itemModels[i].setupItem(effectiveX, effectiveY, Inventory[shopKind][i]);
		OSReport("setupItem\n");
	}
}
void dWMSelection_c::deleteModels() {
	if (lakituModel)
		delete lakituModel;
	lakituModel = 0;

	if (itemModels)
		delete[] itemModels;
	itemModels = 0;
}


void dWMSelection_c::loadInfo() {
	SaveBlock *save = GetSaveFile()->GetBlock(-1);

	//missing color information in original save file!
	s16 hue        = 138;
	s8  saturation = 50;
	s8  lightness  = 30;
	
	//leftCol.colourise(save->hudHintH, save->hudHintS, save->hudHintL);
	//midCol.colourise(save->hudHintH, save->hudHintS, save->hudHintL);
	//rightCol.colourise(save->hudHintH, save->hudHintS, save->hudHintL);
	leftCol.colourise(hue, saturation, lightness);
	midCol.colourise(hue, saturation, lightness);
	rightCol.colourise(hue, saturation, lightness);

	// find out the shop name
	dLevelInfo_c::entry_s *shopNameEntry =
		dLevelInfo_c::s_info.searchBySlot(shopKind, 98);

	wchar_t shopName[100];
	// TODO: refactor this a bit
	const char *sourceName = dLevelInfo_c::s_info.getNameForLevel(shopNameEntry);
	int charCount = 0;
	
	while (*sourceName != 0 && charCount < 99) {
		shopName[charCount] = *sourceName;
		sourceName++;
		charCount++;
	}
	shopName[charCount] = 0;

	Title->SetString(shopName);
	TitleShadow->SetString(shopName);

	// load the coin count
	int scCount = getUnspentStarCoinCount();
	WriteNumberToTextBox(&scCount, CoinCount, false);
	WriteNumberToTextBox(&scCount, CoinCountShadow, false);


	WriteBMGToTextBox(BackText, GetBMG(), 2, 58, 0);
	WriteBMGToTextBox(BuyText, GetBMG(), 302, 4, 0);
}


void dWMSelection_c::buyItem(int item) {
	static int itemDefs[6][3] = {
		// Cost, Start Index, Count
		{1, 0, 1}, {2, 1, 1}, {2, 2, 1}, {3, 3, 1},
		{5, 4, 3}, {8, 7, 5}
	};

	int cost = itemDefs[item][0], cash = getUnspentStarCoinCount();

	if (cost > cash) {
		OSReport("Started playing Not Enough\n");
		//lakituModel->playingNotEnough = true;
		//lakituModel->playAnim("notenough", 1.0f, 1);
		MapSoundPlayer(SoundRelatedClass, SE_SYS_INVALID, 1);
		return;
	}

	MapSoundPlayer(SoundRelatedClass, SE_SYS_DECIDE, 1);

	SaveFile *file = GetSaveFile();
	SaveBlock *block = file->GetBlock(file->header.current_file);

	coinsRemaining = cost;

	// Work out what we need to apply
	int appliedItems[ITEM_TYPE_COUNT];
	for (int i = 0; i < ITEM_TYPE_COUNT; i++)
		appliedItems[i] = 0;

	int invStartIndex = itemDefs[item][1], invCount = itemDefs[item][2];
	for (int i = 0; i < invCount; i++)
		appliedItems[(int)Inventory[shopKind][invStartIndex+i]]++;

	dStockItem_c* stockItemPtr = (dStockItem_c*)fBase_c::search(STOCK_ITEM);
	for (int i = 0; i < 14; i++) {
		block->new_powerups_available[i] += appliedItems[i];

		if (block->new_powerups_available[i] > 99)
			block->new_powerups_available[i] = 99;

		stockItemPtr->newCounts[i] = block->new_powerups_available[i];

	}

	// Apply lives to everyone
	for (int i = 0; i < 4; i++) {
		if (Player_Active[i]) {
			int id = Player_ID[i];
			Player_Lives[id] += appliedItems[(int)ONE_UP];
			if (Player_Lives[id] > 99)
				Player_Lives[id] = 99;
		}
	}

	if (appliedItems[(int)ONE_UP] > 0)
		MapSoundPlayer(SoundRelatedClass, SE_SYS_100COIN_ONE_UP, 1);

	dActor_c* csMng = (dActor_c*)fBase_c::search(COURSE_SELECT_MANAGER);
	dCourseSelectGuide_c__loadLives((int)(csMng) + 200);


	state.setState(&StateID_CoinCountdown);
	HideSelectCursor(SelectCursorPointer, 0);
}


void dWMSelection_c::beginState_CoinCountdown() {
	timerForCoinCountdown = 8;
}

void dWMSelection_c::endState_CoinCountdown() { }

void dWMSelection_c::executeState_CoinCountdown() {
	/* removed for testing
	timerForCoinCountdown--;
	if (timerForCoinCountdown <= 0) {

		SaveBlock *save = GetSaveFile()->GetBlock(-1);
		save->spentStarCoins++;

		// load the coin count
		int scCount = getUnspentStarCoinCount();
		WriteNumberToTextBox(&scCount, CoinCount, false);
		WriteNumberToTextBox(&scCount, CoinCountShadow, false);

		layout.enableNonLoopAnim(COUNT_COIN);
		VEC3 efPos = {
			CoinCount->effectiveMtx[0][3],
			CoinCount->effectiveMtx[1][3],
			0.0f};

		// ARGHHHHHHHHHHHHHHHHh.
		if (IsWideScreen()) {
			float div = 5.0f;
			if (scCount < 100)
				div = 3.6f;
			if (scCount < 10)
				div = 2.7f;
			efPos.x -= (CoinCount->size.x / div);
			efPos.y -= (CoinCount->size.y / 2.0f);
		} else {
			float div = 5.8f;
			if (scCount < 100)
				div = 8.2f;
			if (scCount < 10)
				div = 14.5f;
			efPos.x += (CoinCount->size.x / div);
			efPos.y -= (CoinCount->size.y / 2.8f);
		}

		VEC3 efScale = {0.7f, 0.7f, 0.7f};
		SpawnEffect("Wm_2d_moviecoinvanish", 0, &efPos, 0, &efScale);

		coinsRemaining--;
		if (coinsRemaining <= 0) {
			MapSoundPlayer(SoundRelatedClass, SE_PLY_GET_ITEM_AGAIN, 1);
			state.setState(&StateID_Wait);
		} else {
			MapSoundPlayer(SoundRelatedClass, SE_SYS_STAR_COIN_PAY, 1);
			beginState_CoinCountdown();
		}
	}*/state.setState(&StateID_Wait);
}


void dWMSelection_c::showSelectCursor() {
	switch (selected) {
		case 4: UpdateSelectCursor(Btn1Base, 0, false); break;
		case 5: UpdateSelectCursor(Btn2Base, 0, false); break;
		default: UpdateSelectCursor(Buttons[selected], 0, false);
	}
}


//
// processed\../src/worldmapScripts.cpp
//

typedef struct ScriptCommand {
    u32 type;
    u32 argument;
} ScriptCommand;


ScriptCommand Z_default_clr[] = {
    {140, 0},
    {115, 0},
    {128, 0},
    {0, 30},
    {114, 0},
    {158, 0},
    {159, 0},
    {115, 0},
    {60, 0},
    {2, 0},
    {112, 0},
    {153, 10},
    {151, 0},
    {113, 0},
    {153, 60},
    {152, 0},
    {153, 30},
    {96, 0},
    {97, 0},
    {98, 0},
    {4, 0},
    {155, 0},
    {156, 0},
    {80, 0},
    {111, 0},
    {150, 0},
    {83, 0},
    {109, 0},
    {129, 0},
    {130, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_default_fail[] = {
    {0, 1},
    {141, 0},
    {128, 0},
    {0, 30},
    {135, 0},
    {4, 0},
    {113, 0},
    {155, 0},
    {80, 0},
    {129, 0},
    {130, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_enemy_clr[] = {
    {161, 0},
    {0, 1},
    {141, 0},
    {128, 0},
    {110, 1},
    {162, 1},
    {82, 30},
    {89, 0},
    {90, 0},
    {4, 0},
    {92, 0},
    {113, 0},
    {155, 0},
    {130, 0},
    {166, 30},
    {80, 0},
    {129, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_enemy_fail[] = {
    {164, 0},
    {0, 1},
    {141, 0},
    {128, 0},
    {110, 2},
    {0, 30},
    {55, 0},
    {11, 0},
    {4, 0},
    {113, 0},
    {155, 0},
    {166, 30},
    {80, 0},
    {129, 0},
    {130, 0},
    {164, 1},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_toride_in[] = {
    {128, 0},
    {114, 0},
    {136, 0},
    {0, 10},
    {49, 0},
    {15, 0},
    {10, 0},
    {16, 0},
    {0, 5},
    {118, 0},
    {0, 20},
    {58, 0},
    {8, 5},
    {12, 0},
    {5, 0},
};

ScriptCommand Z_toride_clr[] = {
    {0, 2},
    {114, 0},
    {128, 0},
    {50, 0},
    {0, 30},
    {13, 0},
    {10, 1},
    {95, 0},
    {130, 0},
    {115, 0},
    {5, 0},
};

ScriptCommand Z_toride_fail[] = {
    {0, 2},
    {114, 0},
    {128, 0},
    {50, 0},
    {0, 30},
    {14, 0},
    {0, 20},
    {11, 1},
    {59, 0},
    {16, 0},
    {130, 0},
    {115, 0},
    {129, 0},
    {5, 0},
};

ScriptCommand Z_toride_fail2[] = {
    {0, 2},
    {114, 0},
    {128, 0},
    {50, 0},
    {0, 30},
    {14, 0},
    {0, 20},
    {11, 1},
    {130, 0},
    {115, 0},
    {129, 0},
    {5, 0},
};

ScriptCommand Z_castle_in[] = {
    {128, 0},
    {114, 0},
    {136, 0},
    {0, 10},
    {51, 0},
    {19, 0},
    {10, 0},
    {20, 0},
    {8, 5},
    {12, 0},
    {5, 0},
};

ScriptCommand Z_castle_clr[] = {
    {0, 2},
    {114, 0},
    {128, 0},
    {52, 0},
    {0, 30},
    {17, 0},
    {10, 1},
    {0, 60},
    {78, 0},
    {168, 0},
    {95, 0},
    {130, 0},
    {115, 0},
    {5, 0},
};

ScriptCommand Z_castle_fail[] = {
    {0, 2},
    {114, 0},
    {128, 0},
    {52, 0},
    {0, 30},
    {18, 0},
    {0, 20},
    {11, 1},
    {20, 0},
    {130, 0},
    {115, 0},
    {129, 0},
    {5, 0},
};

ScriptCommand Z_castle_fail2[] = {
    {0, 2},
    {114, 0},
    {128, 0},
    {52, 0},
    {0, 30},
    {18, 0},
    {0, 20},
    {11, 1},
    {130, 0},
    {115, 0},
    {129, 0},
    {5, 0},
};

ScriptCommand Z_ghost_in[] = {
    {128, 0},
    {114, 0},
    {136, 0},
    {0, 10},
    {53, 0},
    {21, 0},
    {10, 0},
    {23, 0},
    {137, 0},
    {8, 5},
    {12, 0},
    {5, 0},
};

ScriptCommand Z_ghost_clr[] = {
    {0, 2},
    {114, 0},
    {128, 0},
    {54, 0},
    {0, 30},
    {21, 0},
    {10, 1},
    {95, 0},
    {0, 60},
    {130, 0},
    {115, 0},
    {5, 0},
};

ScriptCommand Z_ghost_fail[] = {
    {0, 2},
    {114, 0},
    {128, 0},
    {54, 0},
    {0, 30},
    {22, 0},
    {0, 20},
    {11, 1},
    {139, 0},
    {24, 0},
    {130, 0},
    {115, 0},
    {129, 0},
    {5, 0},
};

ScriptCommand Z_ghost_fail2[] = {
    {0, 2},
    {114, 0},
    {128, 0},
    {54, 0},
    {0, 30},
    {22, 0},
    {0, 20},
    {11, 1},
    {25, 0},
    {130, 0},
    {115, 0},
    {129, 0},
    {5, 0},
};

ScriptCommand Z_cannon[] = {
    {0, 60},
    {26, 0},
    {27, 0},
    {28, 0},
    {0, 60},
    {29, 0},
    {30, 0},
    {65, 0},
    {5, 0},
};

ScriptCommand script_0x11[] = {
    {0, 60},
    {31, 0},
    {32, 0},
    {33, 0},
    {34, 0},
    {5, 0},
};

ScriptCommand Z_dokan[] = {
    {128, 0},
    {0, 10},
    {37, 0},
    {92, 0},
    {130, 0},
    {129, 0},
    {5, 0},
};

ScriptCommand Z_dokan_warp[] = {
    {0, 2},
    {128, 0},
    {0, 10},
    {8, 5},
    {38, 0},
    {5, 0},
};

ScriptCommand Z_dokan_start[] = {
    {0, 30},
    {36, 0},
    {130, 0},
    {5, 0},
};

ScriptCommand Z_W_Walking_in[] = {
    {0, 2},
    {140, 0},
    {128, 0},
    {0, 30},
    {40, 0},
    {41, 0},
    {0, 30},
    {42, 0},
    {43, 0},
    {64, 0},
    {84, 0},
    {113, 0},
    {155, 0},
    {81, 0},
    {92, 0},
    {80, 0},
    {79, 1},
    {109, 0},
    {129, 0},
    {130, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_W_Walking_in_Normal[] = {
    {0, 2},
    {141, 0},
    {128, 0},
    {0, 30},
    {64, 0},
    {81, 0},
    {84, 0},
    {113, 0},
    {155, 0},
    {92, 0},
    {80, 0},
    {79, 1},
    {109, 0},
    {129, 0},
    {130, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_W_Flying_in[] = {
    {0, 2},
    {140, 0},
    {128, 0},
    {0, 30},
    {40, 0},
    {41, 1},
    {0, 30},
    {42, 0},
    {43, 0},
    {64, 0},
    {113, 0},
    {81, 0},
    {84, 0},
    {155, 0},
    {92, 0},
    {80, 0},
    {79, 0},
    {129, 0},
    {130, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_W_Cannon_in[] = {
    {0, 2},
    {140, 0},
    {128, 0},
    {0, 30},
    {40, 0},
    {41, 0},
    {0, 30},
    {42, 0},
    {43, 0},
    {66, 0},
    {81, 0},
    {84, 0},
    {113, 0},
    {155, 0},
    {0, 30},
    {79, 1},
    {109, 0},
    {129, 0},
    {130, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_W_Cannon_in_Normal[] = {
    {0, 2},
    {141, 0},
    {128, 0},
    {0, 30},
    {66, 0},
    {84, 0},
    {113, 0},
    {155, 0},
    {165, 0},
    {109, 0},
    {129, 0},
    {130, 0},
    {5, 0},
};

ScriptCommand script_0x1a[] = {
    {0, 2},
    {140, 0},
    {128, 0},
    {44, 0},
    {0, 30},
    {50, 0},
    {45, 0},
    {0, 30},
    {114, 0},
    {13, 0},
    {10, 1},
    {95, 0},
    {130, 0},
    {115, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand script_0x1b[] = {
    {140, 0},
    {114, 0},
    {128, 0},
    {52, 0},
    {46, 0},
    {47, 0},
    {17, 0},
    {10, 1},
    {95, 1},
    {130, 0},
    {48, 2},
    {111, 0},
    {116, 5},
    {6, 0},
    {5, 0},
};

ScriptCommand Z_wSign_koopaCastle_in[] = {
    {140, 0},
    {114, 0},
    {128, 0},
    {52, 0},
    {46, 0},
    {47, 0},
    {0, 30},
    {67, 0},
    {17, 0},
    {10, 1},
    {92, 0},
    {95, 1},
    {130, 0},
    {115, 0},
    {0, 10},
    {69, 0},
    {70, 0},
    {68, 0},
    {71, 0},
    {92, 0},
    {0, 30},
    {3, 0},
    {129, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand script_0x1d[] = {
    {0, 120},
    {9, 0},
    {0, 60},
    {8, 0},
    {0, 30},
    {0, 60},
    {9, 0},
    {0, 60},
    {8, 0},
    {5, 0},
};

ScriptCommand Z_view_world[] = {
    {92, 0},
    {126, 0},
    {134, 0},
    {56, 0},
    {5, 0},
};

ScriptCommand Z_course_in[] = {
    {128, 0},
    {136, 0},
    {57, 0},
    {0, 30},
    {8, 5},
    {12, 0},
    {5, 0},
};

ScriptCommand Z_kinoko_out[] = {
    {128, 0},
    {0, 30},
    {60, 0},
    {5, 0},
};

ScriptCommand Z_airship_course_in[] = {
    {128, 0},
    {114, 0},
    {136, 0},
    {61, 0},
    {149, 0},
    {148, 0},
    {0, 30},
    {8, 5},
    {12, 0},
    {5, 0},
};

ScriptCommand Z_airship_course_out[] = {
    {0, 1},
    {141, 0},
    {114, 0},
    {128, 0},
    {127, 0},
    {0, 30},
    {62, 0},
    {11, 2},
    {130, 0},
    {115, 0},
    {129, 0},
    {5, 0},
};

ScriptCommand Z_start_kinoko_in[] = {
    {0, 30},
    {5, 0},
};

ScriptCommand script_0x24[] = {
    {140, 0},
    {114, 0},
    {164, 0},
    {128, 0},
    {0, 30},
    {62, 0},
    {11, 2},
    {130, 0},
    {0, 30},
    {63, 0},
    {48, 2},
    {111, 0},
    {116, 5},
    {6, 0},
    {5, 0},
};

ScriptCommand script_0x25[] = {
    {140, 0},
    {114, 0},
    {128, 0},
    {158, 0},
    {130, 0},
    {0, 30},
    {48, 2},
    {111, 0},
    {116, 5},
    {6, 0},
    {5, 0},
};

ScriptCommand Z_null[] = {
    {80, 0},
    {113, 0},
    {155, 0},
    {157, 0},
    {141, 0},
    {129, 0},
    {5, 0},
};

ScriptCommand Z_antlion[] = {
    {126, 0},
    {114, 0},
    {128, 0},
    {72, 0},
    {73, 0},
    {75, 0},
    {74, 0},
    {129, 0},
    {115, 0},
    {5, 0},
};

ScriptCommand Z_killer[] = {
    {114, 0},
    {128, 0},
    {76, 0},
    {86, 0},
    {8, 5},
    {77, 0},
    {5, 0},
};

ScriptCommand Z_start_battle[] = {
    {114, 0},
    {128, 0},
    {163, 0},
    {136, 0},
    {91, 0},
    {86, 0},
    {8, 5},
    {87, 0},
    {5, 0},
};

ScriptCommand Z_Switch[] = {
    {128, 0},
    {92, 0},
    {94, 0},
    {147, 0},
    {167, 0},
    {129, 0},
    {130, 0},
    {5, 0},
};

ScriptCommand Z_KoopaCastleAppear[] = {
    {140, 0},
    {114, 0},
    {128, 0},
    {0, 30},
    {99, 0},
    {100, 0},
    {115, 0},
    {101, 0},
    {92, 0},
    {130, 1},
    {0, 30},
    {102, 0},
    {0, 20},
    {108, 2},
    {0, 60},
    {104, 0},
    {103, 0},
    {108, 1},
    {0, 30},
    {105, 0},
    {131, 0},
    {3, 0},
    {0, 60},
    {106, 0},
    {107, 0},
    {129, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_KinopioStart[] = {
    {0, 60},
    {113, 0},
    {5, 0},
};

ScriptCommand script_0x2d[] = {
    {0, 2},
    {128, 0},
    {121, 30},
    {119, 0},
    {121, 30},
    {59, 0},
    {121, 30},
    {120, 0},
    {64, 0},
    {84, 0},
    {113, 0},
    {155, 0},
    {92, 0},
    {80, 0},
    {79, 1},
    {109, 0},
    {129, 0},
    {130, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand script_0x2e[] = {
    {0, 2},
    {128, 0},
    {121, 30},
    {119, 0},
    {121, 30},
    {59, 0},
    {121, 30},
    {120, 0},
    {66, 0},
    {84, 0},
    {113, 0},
    {155, 0},
    {92, 0},
    {80, 0},
    {79, 1},
    {109, 0},
    {129, 0},
    {130, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_Pause_Menu[] = {
    {154, 1},
    {0, 2},
    {92, 0},
    {134, 0},
    {114, 0},
    {123, 0},
    {124, 0},
    {122, 0},
    {130, 0},
    {115, 0},
    {154, 0},
    {5, 0},
};

ScriptCommand Z_airship_clear[] = {
    {140, 0},
    {114, 0},
    {128, 0},
    {127, 0},
    {0, 30},
    {62, 0},
    {11, 3},
    {130, 0},
    {115, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_Stock_Menu[] = {
    {154, 1},
    {0, 2},
    {92, 0},
    {134, 0},
    {114, 0},
    {123, 0},
    {132, 0},
    {122, 0},
    {130, 0},
    {115, 0},
    {154, 0},
    {5, 0},
};

ScriptCommand Z_WorldSelect_Menu[] = {
    {154, 1},
    {0, 2},
    {92, 0},
    {134, 0},
    {114, 0},
    {123, 0},
    
	//{170, 0}, 						//new command - added in newScriptCommands
	{133, 0},
    
	{122, 0},
    {130, 0},
    {115, 0},
    {154, 0},
    {5, 0},
};

ScriptCommand Z_antlion_star[] = {
    {126, 0},
    {114, 0},
    {128, 0},
    {72, 0},
    {73, 0},
    {143, 0},
    {142, 0},
    {74, 0},
    {144, 0},
    {129, 0},
    {115, 0},
    {5, 0},
};

ScriptCommand Z_GameStart[] = {
    {160, 0},
    {140, 0},
    {128, 0},
    {0, 0},
    {40, 0},
    {41, 0},
    {0, 30},
    {42, 0},
    {43, 0},
    {145, 0},
    {146, 0},
    {92, 0},
    {84, 0},
    {81, 0},
    {109, 0},
    {129, 0},
    {130, 0},
    {141, 0},
    {5, 0},
};

ScriptCommand Z_Shop_Menu[] = {
    {154, 1},
    {0, 2},
    {92, 0},
    {134, 0},
    {114, 0},
    {123, 0},
    {169, 0},						//new command - added in worldmapShop
    {122, 0},
    {130, 0},
    {115, 0},
    {154, 0},
    {5, 0},
};

ScriptCommand Z_boss_in[] = {
    {128, 0},
    {114, 0},
    {136, 0},
    {0, 10},
    {49, 0},
    {15, 0},
    {10, 0},
    {16, 0},
    {0, 5},
    {118, 0},
    {0, 20},
    {58, 0},
    {8, 5},
    {12, 0},
    {5, 0},
};

ScriptCommand *custom_world_map_scripts_table[] = {
    Z_default_clr,					//0x00
    Z_default_fail,					//0x01
    Z_enemy_clr,					//0x02
    Z_enemy_fail,					//0x03
    Z_toride_in,					//0x04
    Z_toride_clr,					//0x05
    Z_toride_fail,					//0x06
    Z_toride_fail2,					//0x07
    Z_castle_in,					//0x08
    Z_castle_clr,					//0x09
    Z_castle_fail,					//0x0A
    Z_castle_fail2,					//0x0B
    Z_ghost_in,						//0x0C
    Z_ghost_clr,					//0x0D
    Z_ghost_fail,					//0x0E
    Z_ghost_fail2,					//0x0F
    Z_cannon,						//0x10
    script_0x11,					//0x11
    Z_dokan,						//0x12
    Z_dokan_warp,					//0x13
    Z_dokan_start,					//0x14
    Z_W_Walking_in,					//0x15
    Z_W_Walking_in_Normal,			//0x16
    Z_W_Flying_in,					//0x17
    Z_W_Cannon_in,					//0x18
    Z_W_Cannon_in_Normal,			//0x19
    script_0x1a,					//0x1A
    script_0x1b,					//0x1B
    Z_wSign_koopaCastle_in,			//0x1C
    script_0x1d,					//0x1D
    Z_view_world,					//0x1E
    Z_course_in,					//0x1F
    Z_kinoko_out,					//0x20
    Z_airship_course_in,			//0x21
    Z_airship_course_out,			//0x22
    Z_start_kinoko_in,				//0x23
    script_0x24,					//0x24
    script_0x25,					//0x25
    Z_null,							//0x26
    Z_antlion,						//0x27
    Z_killer,						//0x28
    Z_start_battle,					//0x29
    Z_Switch,						//0x2A
    Z_KoopaCastleAppear,			//0x2B
    Z_KinopioStart,					//0x2C
    script_0x2d,					//0x2D
    script_0x2e,					//0x2E
    Z_Pause_Menu,					//0x2F
    Z_airship_clear,				//0x30
    Z_Stock_Menu,					//0x31
    Z_WorldSelect_Menu,				//0x32
    Z_antlion_star,					//0x33
    Z_GameStart,					//0x34
	
	// new scripts
	Z_Shop_Menu,					//0x35
	Z_boss_in,						//0x36
};
//
// processed\../src/worldmapGrid.cpp
//

bool showGrid = false;
dActor_c* theGrid;

int wmtest() {
	dActor_c* worldmapManager = (dActor_c*)fBase_c::search(WM_SINKSHIP);
	if(!worldmapManager) {
		dActor_c::create(WM_SINKSHIP, 0, 0, 0);
	}
	
	dActor_c* shop = (dActor_c*)fBase_c::search(WM_GRID);
	if(!shop) {
		dActor_c::create(WM_GRID, 0, 0, 0);
	}
/*	dActor_c* worldSelect = (dActor_c*)fBase_c::search(WM_NOTE);
	if(!worldSelect) {
		dActor_c::create(WM_NOTE, 0, 0, 0);
	}*/
	
	if(Remocon_GetPressed(GetActiveRemocon()) & WPAD_HOME){
		showGrid = !showGrid;
		return showGrid ? 2 : 1;
	}
	return 0;
}

void createWMGrid() {
	dActor_c* player = (dActor_c*)fBase_c::search(WM_PLAYER);
	OSReport("Player: %p\n", player);
	theGrid = dActor_c::create(WM_MANTA, 0, &player->pos, 0);
}

void deleteWMGrid() {
	theGrid->Delete();
	theGrid = NULL;
}
//
// processed\../src/cobCourse.cpp
//

#include <game.h>
#include "levelinfo.h"

extern "C" void bindAnimCobCourse(u32 thisPtr, u32 animID, float unk1, float unk2);
extern "C" u8 CurrentWorldNumForWorldMap;
extern "C" u8 CurrentWorldNumForWorldMapSub;
extern "C" int getLevelInfoWorldNumber(int world, int subWorld);

void cobCourseNewColor(u32 thisPtr, u32 animID, float unk1, float unk2) {
	uint worldNum = getLevelInfoWorldNumber(CurrentWorldNumForWorldMap, CurrentWorldNumForWorldMapSub);
	uint levelNum = *(u32*)(thisPtr + 4) & 0xFF;

	dLevelInfo_c::entry_s *level = dLevelInfo_c::s_info.searchBySlot(worldNum, levelNum);

	if(level->flags & 0x20) {
		OSReport("SExit: %02d-%02d\n", worldNum+1, levelNum+1);

		SaveBlock *save = GetSaveFile()->GetBlock(-1);
		u32 conds = save->GetLevelCondition(worldNum, levelNum);

		if(!((conds & COND_NORMAL) && (conds & COND_SECRET))) {
			bindAnimCobCourse(thisPtr, 3, unk1, unk2);
			return;
		}
	}

	bindAnimCobCourse(thisPtr, 0, unk1, unk2);
}
//
// processed\../src/worldmapManager.cpp
//

int getLevelInfoWorldNumber(int world, int subWorld) {
	/*  for WXa this returns X      (00-07)
	    for WXb this returns X + 8  (08-15)
		for WXc this returns X + 16 (16-23)
	    don't use W9!  */
	return 8 * subWorld + world;
}

extern "C" u8 CurrentWorldNumForWorldMap;
extern "C" u8 CurrentWorldNumForWorldMapSub;
extern "C" bool GetCurrentHomeToadHouseID();
u8 StartArrowRotation;

static const wchar_t *numberKinds2[] = {
	L"0",
	L"1",
	L"2",
	L"3",
	L"4",
	L"5",
	L"6",
	L"7",
	L"8",
	L"9",
	L"10",
	L"11",
	L"12",
	L"13",
	L"14",
	L"15",
	L"16",
	L"17",
	L"18",
	L"19",
	L"\x0B" L"A", // 20, alternate
	L"\x0B\x0148\xBEEF", // 21, tower
	L"\x0B\x0148\xBEEF" L"2", // 22, tower 2
	L"\x0B\x012E\xBEEF", // 23, castle
	L"\x0B\x012F\xBEEF", // 24, fortress
	L"\x0B\x013D\xBEEF", // 25, final castle
	L"\x0B\x014D\xBEEF", // 26, train
	L"\x0B\x0132\xBEEF", // 27, airship
	L"Palace", // 28, switch palace
	L"\x0B\x0147\xBEEF", // 29, yoshi's house
	L"\x0B\x014E\xBEEF" L"1", // 30, key 1
	L"\x0B\x014E\xBEEF" L"2", // 31, key 2
	L"\x0B\x014E\xBEEF" L"3", // 32, key 3
	L"\x0B\x014E\xBEEF" L"4", // 33, key 4
	L"\x0B\x014E\xBEEF" L"5", // 34, key 5
	L"\x0B\x014E\xBEEF" L"6", // 35, key 6
	L"\x0B\x0138\xBEEF", // 36, music house
	L"\x0B\x0133\xBEEF", // 37, shop
	L"\x0B\x0139\xBEEF", // 38, challenge house
	L"\x0B\x0151\xBEEF", // 39, red switch palace
	L"\x0B\x0152\xBEEF", // 40, blue switch palace
	L"\x0B\x0153\xBEEF", // 41, yellow switch palace
	L"\x0B\x0154\xBEEF", // 42, green switch palace
};

static const wchar_t *numberKinds3[] = {
	L" 1",
	L" 2",
	L" 3",
	L" 4",
	L" 5",
	L" 6",
	L" 7",
	L" 8",
	L"S1",
	L"S2",
	L"S3",
	L"S4",
	L"S5",
	L"S6",
	L"S7",
	L"S8",
	L" A",
	L" B",
	L" C",
	L" D",
};

bool getLevelNameForDisplayNums(int world, int level, wchar_t* worldString, wchar_t* levelString) {
	wcscpy(&worldString[0], numberKinds3[world-1]);
	wcscpy(&levelString[0], numberKinds2[level]);

	
	if(level < 20) return false;
	
	return true;
}

class dWMManager_c : public dActor_c {
public:
	static dWMManager_c *build();
	static dWMManager_c *instance;
	
	dWMManager_c();
	
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();
	
	u8 previousNodeNum;
	dActor_c* csMng;
	SaveBlock* save;
	
	m2d::EmbedLayout_c* layout;
	
	nw4r::lyt::TextBox
		*worldName, *shopText, *worldNum, *cSelect, *cSelectPic;
};

dWMManager_c *dWMManager_c::instance = 0;

dWMManager_c *dWMManager_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dWMManager_c));
	dWMManager_c *c = new(buffer) dWMManager_c;

	instance = c;
	return c;
}

dWMManager_c::dWMManager_c() {

}

int dWMManager_c::onCreate() {
	csMng = (dActor_c*)fBase_c::search(COURSE_SELECT_MANAGER);
	layout = (m2d::EmbedLayout_c*)((int)(csMng) + 208);
	
	save = GetSaveFile()->GetBlock(-1);
	
	worldName = layout->findTextBoxByName("T_world_name");
	shopText = layout->findTextBoxByName("T_guideViewL_00");
	worldNum = layout->findTextBoxByName("T_worldNum_00");
	cSelect = layout->findTextBoxByName("T_cSelect_00");
	cSelectPic = layout->findTextBoxByName("T_cSelect_pic");

	uint worldNumber = getLevelInfoWorldNumber(CurrentWorldNumForWorldMap, CurrentWorldNumForWorldMapSub);
	
	dLevelInfo_c::entry_s *level = dLevelInfo_c::s_info.searchByDisplayNum(worldNumber+1, 100);

	const char *worldNameText = dLevelInfo_c::s_info.getNameForLevel(level);
	wchar_t convertedWorldName[32];
	for (int i = 0; i < 32; i++) {
		convertedWorldName[i] = worldNameText[i];
		if (convertedWorldName[i] == 0)
			break;
	}
	convertedWorldName[31] = 0;

	worldName->SetString(convertedWorldName);
	shopText->SetString(L"Shop " L"\x0B\x0123");
	
	dActor_c* player = (dActor_c*)fBase_c::search(WM_PLAYER);
	OSReport("Player: %p\n", player);
	dActor_c::create(AC_ITEM_KEY, 0, &player->pos, 0);		//spawn a paratroopa
	
	return true;
}


int dWMManager_c::onDelete() {
	return true;
}



int dWMManager_c::onExecute() {
	Remocon* rem = GetActiveRemocon();
	int nowPressed = Remocon_GetPressed(rem);
	if(rem->controllerType == 0) {	//Wiimote
		shopText->SetString(L"Shop " L"\x0B\x0123");
	} else {
		shopText->SetString(L"Shop " L"\x0B\x012B");
	}
	
	if(nowPressed & WPAD_B && nowPressed & WPAD_A) DoSceneChange(0x238, 0, 0);
	
	u8 CurrentNodeNum = *(u8*)((int)(csMng) + 0x4D7);



	//OSReport("GetCurrentHomeToadHouseID: %s\n", GetCurrentHomeToadHouseID() ? "true" : "false");
	
	
	  
	/*for(int i = 0; i < 10; i++) {
		OSReport("toad_level_idx %d: %d\n", i, save->toad_level_idx[i]);
	}*/

	if(CurrentNodeNum != previousNodeNum) {
		wchar_t levelString[4];
		wchar_t worldString[4];
		uint worldNumber = getLevelInfoWorldNumber(CurrentWorldNumForWorldMap, CurrentWorldNumForWorldMapSub);

		if(CurrentNodeNum != 255) {
			if(CurrentNodeNum == 38) {
				wcscpy(&worldString[0], numberKinds3[worldNumber]);
				
				switch(save->new_toad_level_idx[worldNumber]) {
					case 0:
						switch(StartArrowRotation) {
							case 1:
								cSelectPic->SetString(L"\x0B\x0135");
								break;
							case 2:
								cSelectPic->SetString(L"\x0B\x0143");
								break;
							case 3:
								cSelectPic->SetString(L"\x0B\x0144");
								break;
							default:
								cSelectPic->SetString(L"\x0B\x0134");
								break;
						}
						break;
					case 1:
					case 4:
						cSelectPic->SetString(L"\x0B\x0138");
						//yellow?
						break;
					case 2:
					case 5:
						cSelectPic->SetString(L"\x0B\x0133");
						//red?
						break;
					default:
						cSelectPic->SetString(L"\x0B\x0139");
						//grren?
						break;
				}
				cSelect->SetString(L"");
				worldNum->SetString(worldString);
			} else {
				dLevelInfo_c::entry_s *level = dLevelInfo_c::s_info.searchBySlot(worldNumber, CurrentNodeNum);
				bool isPictureLevel = getLevelNameForDisplayNums(level->displayWorld, level->displayLevel, &worldString[0], &levelString[0]);
				
				OSReport("level: %d, world: %d, displayLevel: %d, displayWorld: %d\n", CurrentNodeNum, worldNumber, level->displayLevel, level->displayWorld);
				
				worldNum->SetString(worldString);
				if(isPictureLevel) {
					cSelectPic->SetString(levelString);
					cSelect->SetString(L"");
				} else {
					cSelect->SetString(levelString);
					cSelectPic->SetString(L"");
				}
			}
			previousNodeNum = CurrentNodeNum;
		} else {
			OSReport("is -1\n");
			wcscpy(&worldString[0], numberKinds3[worldNumber]);
			cSelectPic->SetString(L"\x0B\x0136");
			cSelect->SetString(L"");
			worldNum->SetString(worldString);
		}
	}
	
	return true;
}

int dWMManager_c::onDraw() {
	return true;
}
//
// processed\../src/worldmapParatroopa.cpp
//

class dWMParatroopa_c : public dActor_c {
public:
	static dWMParatroopa_c *build();
	
	dWMParatroopa_c();
	
	int onCreate();
	int onDelete();
	int onExecute();
	void updateModelMatrices();
	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate, bool isWing);
	bool checkCollision();
	
	mHeapAllocator_c allocator;
	
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c animationChr;
	
	nw4r::g3d::ResFile wingBrres;
	m3d::mdl_c wing;
	m3d::anmChr_c wingChr;
	
	int frames;
	Vec startPos;
	
	dStateWrapper_c<dWMParatroopa_c> state;
	
	USING_STATES(dWMParatroopa_c);
	DECLARE_STATE(Wait);
	DECLARE_STATE(Attack);
	DECLARE_STATE(PlayerLost);
	DECLARE_STATE(PlayerWon);
};

CREATE_STATE(dWMParatroopa_c, Wait);
CREATE_STATE(dWMParatroopa_c, Attack);
CREATE_STATE(dWMParatroopa_c, PlayerLost);
CREATE_STATE(dWMParatroopa_c, PlayerWon);

dWMParatroopa_c *dWMParatroopa_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(dWMParatroopa_c));
	dWMParatroopa_c *c = new(buffer) dWMParatroopa_c;

	return c;
}

dWMParatroopa_c::dWMParatroopa_c() : state(this, &StateID_Wait) {
}

int dWMParatroopa_c::onCreate() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	resFile.data = getResource("nokonokoA", "g3d/t00.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("nokonokoA");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("flyA");
	this->animationChr.setup(mdl, anmChr, &this->allocator, 0);

	wingBrres.data = getResource("wing", "g3d/wing.brres");
	nw4r::g3d::ResMdl mdl2 = this->wingBrres.GetResMdl("wing");
	wing.setup(mdl2, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&wing, 0);
	nw4r::g3d::ResAnmChr anmChr2 = this->wingBrres.GetResAnmChr("wing_pata");
	this->wingChr.setup(mdl2, anmChr2, &this->allocator, 0);

	allocator.unlink();
	
	this->scale = (Vec){2.0, 2.0, 2.0};
	this->rot.y = -0x4000;
	this->pos.x += 300;
	
	this->startPos = this->pos;
	
	return true;
}


int dWMParatroopa_c::onDelete() {
	return true;
}

extern int PtrToWM_CS_SEQ_MNG;
extern "C" bool FUN_801017c0(int, int, int, int, int);
extern "C" int dCsSeqMng_c__GetCutName(int);

int dWMParatroopa_c::onExecute() {
	state.execute();
	
	updateModelMatrices();
	bodyModel._vf1C();
	wing._vf1C();
	
	int currentCommand = dCsSeqMng_c__GetCutName(PtrToWM_CS_SEQ_MNG);
	
	if(currentCommand != -1) {
		OSReport("GetCutName: %d\n", currentCommand);
	}
	switch(currentCommand) {
		case 164:
			if(state.getCurrentState() != &StateID_PlayerLost) state.setState(&StateID_PlayerLost);
			break;
		case 161:
			if(state.getCurrentState() != &StateID_PlayerWon) state.setState(&StateID_PlayerWon);
			break;
	}
	
	return true;
}

void dWMParatroopa_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
	bodyModel.scheduleForDrawing();
	
	matrix.translation(pos.x, pos.y + 10, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);
	
	wing.setDrawMatrix(matrix);
	wing.setScale(&scale);
	wing.calcWorld(false);
	wing.scheduleForDrawing();
}


void dWMParatroopa_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate, bool isWing) {
	if(isWing) {
		nw4r::g3d::ResAnmChr anmChr = this->wingBrres.GetResAnmChr(name);
		this->wingChr.bind(&this->wing, anmChr, unk);
		this->wing.bindAnim(&this->wingChr, unk2);
		this->wingChr.setUpdateRate(rate);
	} else {
		nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
		this->animationChr.bind(&this->bodyModel, anmChr, unk);
		this->bodyModel.bindAnim(&this->animationChr, unk2);
		this->animationChr.setUpdateRate(rate);
	}
}

bool dWMParatroopa_c::checkCollision() {
	dActor_c* player = 0;
	do {
		player = (dActor_c*)fBase_c::search(WM_PLAYER, player);
		float dx = this->pos.x - player->pos.x;
		float dy = this->pos.y - player->pos.y;
		float dz = this->pos.z - player->pos.z;
		if(sqrtf(dx*dx + dy*dy + dz*dz) <= 20) {
			return true;
		}
	} while(player);
	return false;
}

void dWMParatroopa_c::beginState_Wait() {
	bindAnimChr_and_setUpdateRate("flyA", 1, 0.0, 1.0, false);
	bindAnimChr_and_setUpdateRate("wing_pata", 1, 0.0, 1.0, true);
}
void dWMParatroopa_c::executeState_Wait() {
	this->pos.y = startPos.y + (cos(this->frames * 3.14 / 200.0) * 120.0);
	this->frames++;
	if(checkCollision()) {
		state.setState(&StateID_Attack);
	}
	
	if (this->animationChr.isAnimationDone()) {
		this->animationChr.setCurrentFrame(0.0);
	}
	if (this->wingChr.isAnimationDone()) {
		this->wingChr.setCurrentFrame(0.0);
	}
}
void dWMParatroopa_c::endState_Wait() {}

void dWMParatroopa_c::beginState_Attack() {
	FUN_801017c0(PtrToWM_CS_SEQ_MNG, 0x29, 0, 0, 0x80);
}
void dWMParatroopa_c::executeState_Attack() {}
void dWMParatroopa_c::endState_Attack() {}

void dWMParatroopa_c::beginState_PlayerLost() {
	bindAnimChr_and_setUpdateRate("revival", 1, 0.0, 1.0, false);
}
void dWMParatroopa_c::executeState_PlayerLost() {
	if (this->animationChr.isAnimationDone()) {
		state.setState(&StateID_Wait);
	}
}
void dWMParatroopa_c::endState_PlayerLost() {}

void dWMParatroopa_c::beginState_PlayerWon() {
	bindAnimChr_and_setUpdateRate("revival", 1, 0.0, 1.0, false);
}
void dWMParatroopa_c::executeState_PlayerWon() {
	if (this->animationChr.isAnimationDone()) {
		this->Delete();
	}
}
void dWMParatroopa_c::endState_PlayerWon() {}
//
// processed\../src/cutsceneMgr.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>


class cutsceneMgr : public dStageActor_c {
public:
	nw4r::lyt::Picture *_1;
	nw4r::lyt::Picture *_2;
	nw4r::lyt::Picture *_3;
	nw4r::lyt::Picture *_4;
	nw4r::lyt::Picture *_5;
	nw4r::lyt::Picture *_6;
	nw4r::lyt::Picture *_7;
	nw4r::lyt::Picture *_31;
	nw4r::lyt::Picture *_8;
	nw4r::lyt::Picture *_9;
	nw4r::lyt::Picture *_10;
	nw4r::lyt::Picture *_11;
	nw4r::lyt::Picture *_12;
	nw4r::lyt::Picture *_13;
	nw4r::lyt::Picture *_14;
	nw4r::lyt::Picture *_15;
	nw4r::lyt::Picture *_16;
	nw4r::lyt::TextBox *_18;
	nw4r::lyt::TextBox *_19;
	nw4r::lyt::TextBox *_20;
	nw4r::lyt::TextBox *_21;
	nw4r::lyt::TextBox *_22;
	nw4r::lyt::TextBox *_23;
	nw4r::lyt::TextBox *_24;
	nw4r::lyt::TextBox *_25;
	nw4r::lyt::TextBox *_26;
	nw4r::lyt::TextBox *_27;
	nw4r::lyt::TextBox *_28;
	nw4r::lyt::TextBox *_29;
	nw4r::lyt::TextBox *_30;

	nw4r::lyt::Pane *_32;

	bool ran60times;
	bool visibility;																					//store the visibility bool
	bool isLuigiActive;
	bool isKinoBActive;
	bool isKinoYActive;

	void switchGameDisplayVisibility();

	int onCreate();
	int onExecute();

	static dActor_c *build();
};

const char *CutsceneMgrFileList[] = {0};
const SpriteData cutsceneMgrSpriteData = { ProfileId::CutsceneMgr, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile cutsceneMgrProfile(&cutsceneMgr::build, SpriteId::CutsceneMgr, cutsceneMgrSpriteData, ProfileId::CutsceneMgr, ProfileId::CutsceneMgr, "CutsceneMgr", CutsceneMgrFileList);


dActor_c  *cutsceneMgr::build() {
	void *buffer = AllocFromGameHeap1(sizeof(cutsceneMgr));
	cutsceneMgr *c = new(buffer) cutsceneMgr;

	return c;
}


int cutsceneMgr::onCreate() {
	return true;
}


int cutsceneMgr::onExecute() {
	if(ran60times < 60) {
		ran60times++;
	} else {
		if(ran60times == 60) {
			ran60times = 61;
			OSReport("========================================\n");
			this->_1 = dGameDisplay_c::instance->layout.findPictureByName("P_baseS_01");						//getting the panes, too lazy to name them all
			OSReport("1\n");
			this->_2 = dGameDisplay_c::instance->layout.findPictureByName("P_base_01");
			OSReport("2\n");
			this->_3 = dGameDisplay_c::instance->layout.findPictureByName("P_otasukeIcon_00");
			OSReport("3\n");
			this->_4 = dGameDisplay_c::instance->layout.findPictureByName("P_marioIcon_00");
			OSReport("4\n");
			this->_5 = dGameDisplay_c::instance->layout.findPictureByName("P_luijiIcon_00");
			OSReport("5\n");
			this->_6 = dGameDisplay_c::instance->layout.findPictureByName("P_kinoB_00");
			OSReport("6\n");
			this->_7 = dGameDisplay_c::instance->layout.findPictureByName("P_kinoY_00");
			OSReport("7\n");
			this->_31 = dGameDisplay_c::instance->layout.findPictureByName("P_baseS_00");
			OSReport("8\n");
			this->_8 = dGameDisplay_c::instance->layout.findPictureByName("P_base_00");
			OSReport("9\n");
			this->_9 = dGameDisplay_c::instance->layout.findPictureByName("P_coin_00");
			OSReport("10\n");
			this->_10 = dGameDisplay_c::instance->layout.findPictureByName("P_collectOff_00");
			OSReport("11\n");
			this->_11 = dGameDisplay_c::instance->layout.findPictureByName("P_collectOff_01");
			OSReport("12\n");
			this->_12 = dGameDisplay_c::instance->layout.findPictureByName("P_collectOff_02");
			OSReport("13\n");
			this->_13 = dGameDisplay_c::instance->layout.findPictureByName("P_collection_00");
			OSReport("14\n");
			this->_14 = dGameDisplay_c::instance->layout.findPictureByName("P_collection_01");
			OSReport("15\n");
			this->_15 = dGameDisplay_c::instance->layout.findPictureByName("P_collection_02");
			OSReport("16\n");
			this->_16 = dGameDisplay_c::instance->layout.findPictureByName("P_timer_00");
			OSReport("17\n");
			this->_18 = dGameDisplay_c::instance->layout.findTextBoxByName("T_otaChuS_00");
			OSReport("18\n");
			this->_19 = dGameDisplay_c::instance->layout.findTextBoxByName("T_otaChu_00");
			OSReport("19\n");
			this->_20 = dGameDisplay_c::instance->layout.findTextBoxByName("T_x_01");
			OSReport("20\n");
			this->_21 = dGameDisplay_c::instance->layout.findTextBoxByName("T_x_02");
			OSReport("21\n");
			this->_22 = dGameDisplay_c::instance->layout.findTextBoxByName("T_x_03");
			OSReport("22\n");
			this->_23 = dGameDisplay_c::instance->layout.findTextBoxByName("T_x_04");
			OSReport("23\n");
			this->_24 = dGameDisplay_c::instance->layout.findTextBoxByName("T_left_00");
			OSReport("24\n");
			this->_25 = dGameDisplay_c::instance->layout.findTextBoxByName("T_left_01");
			OSReport("25\n");
			this->_26 = dGameDisplay_c::instance->layout.findTextBoxByName("T_left_02");
			OSReport("26\n");
			this->_27 = dGameDisplay_c::instance->layout.findTextBoxByName("T_left_03");
			OSReport("27\n");
			this->_28 = dGameDisplay_c::instance->layout.findTextBoxByName("T_coin_00");
			OSReport("28\n");
			this->_29 = dGameDisplay_c::instance->layout.findTextBoxByName("T_score_00");
			OSReport("29\n");
			this->_30 = dGameDisplay_c::instance->layout.findTextBoxByName("T_time_00");
			OSReport("30\n");
			this->_32 = dGameDisplay_c::instance->layout.findPaneByName("N_collection_00");
			OSReport("31\n");

			if(_5->flag == 1) {																					//if luigi's pane is visible, luigi is active
				isLuigiActive = true;
			}
			if(_6->flag == 1) {																					//if kinob's pane is visible, kinob is active
				isKinoBActive = true;
			}
			if(_7->flag == 1) {																					//if kinoy's pane is visible, kinoy is active
				isKinoYActive = true;
			}
			
			this->visibility = true;

		} else {
			OSReport("trigger");
			if((dFlagMgr_c::instance->flags & spriteFlagMask) != 0)
				if(visibility)
					switchGameDisplayVisibility();
			else
				if(!visibility)
					switchGameDisplayVisibility();
		}
	}
	return true;
}


void cutsceneMgr::switchGameDisplayVisibility() {
	visibility != visibility;
	_1->SetVisible(visibility);																			//set the panes visibilities
	_2->SetVisible(visibility);
	_3->SetVisible(visibility);
	_4->SetVisible(visibility);
	if(isLuigiActive) {																					//if luigi is active, affect his panes
		_5->SetVisible(visibility);
		_21->SetVisible(visibility);
		_25->SetVisible(visibility);
	}
	
	if(isKinoBActive) {																					//if kinob is active, affect his panes
		_6->SetVisible(visibility);
		_22->SetVisible(visibility);
		_26->SetVisible(visibility);
	}
	
	if(isKinoYActive) {																					//if kinoy is active, affect his panes
		_7->SetVisible(visibility);
		_23->SetVisible(visibility);
		_27->SetVisible(visibility);
	}
	_8->SetVisible(visibility);
	_9->SetVisible(visibility);
	_10->SetVisible(visibility);
	_11->SetVisible(visibility);
	_12->SetVisible(visibility);
	_13->SetVisible(visibility);
	_14->SetVisible(visibility);
	_15->SetVisible(visibility);
	_16->SetVisible(visibility);
	_18->SetVisible(visibility);
	_19->SetVisible(visibility);
	_20->SetVisible(visibility);
	_24->SetVisible(visibility);
	_28->SetVisible(visibility);
	_29->SetVisible(visibility);
	_30->SetVisible(visibility);
	_31->SetVisible(visibility);
	_32->SetVisible(visibility);
}
//
// processed\../src/secretGem.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

const char *SecretGemFileList[] = {"supergem", 0};

bool secretGemCollected = false;
bool secretGemAfterMidwayFlag = false;

class daEnSecretGem_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c anm;
	
	bool type8fastJump;
	int type8timer;
	int type8timer2;

	static dActor_c* build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	
	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	
	USING_STATES(daEnSecretGem_c);
	
	DECLARE_STATE(Wait);
	DECLARE_STATE(Collect);
};

CREATE_STATE(daEnSecretGem_c, Wait);
CREATE_STATE(daEnSecretGem_c, Collect);

void daEnSecretGem_c::beginState_Wait() {}
void daEnSecretGem_c::executeState_Wait() {
	
	if (this->anm.isAnimationDone()) {
		this->anm.setCurrentFrame(0.0);
	}
	//doStateChange(&StateID_Fly);
}
void daEnSecretGem_c::endState_Wait() {}

void daEnSecretGem_c::beginState_Collect() {
	bindAnimChr_and_setUpdateRate("GotLow", 1, 0.0, 1.0);
}
void daEnSecretGem_c::executeState_Collect() {
	if (this->anm.isAnimationDone()) {
		secretGemCollected = true;
		secretGemAfterMidwayFlag = (GameMgrP->eight.checkpointEntranceID != 255);
		OSReport("secretGemAfterMidwayFlag: %s\n", secretGemAfterMidwayFlag ? "true" : "false");
		this->Delete(1);
	}
}
void daEnSecretGem_c::endState_Collect() {}


void daEnSecretGem_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->anm.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->anm, unk2);
	this->anm.setUpdateRate(rate);
}



const SpriteData SecretGemSpriteData = { ProfileId::SecretGem, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile SecretGemProfile(&daEnSecretGem_c::build, SpriteId::SecretGem, SecretGemSpriteData, ProfileId::SecretGem, ProfileId::SecretGem, "SecretGem", SecretGemFileList);



u8 hijackMusicWithSongName(const char *songName, int themeID, bool hasFast, int channelCount, int trackCount, int *wantRealStreamID);

void daEnSecretGem_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	doStateChange(&StateID_Collect);
}
void daEnSecretGem_c::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->type8fastJump = true;
}
bool daEnSecretGem_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->type8fastJump = true;
	return false;
}
bool daEnSecretGem_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->type8fastJump = true;
	return false;
}
bool daEnSecretGem_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnSecretGem_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}

bool daEnSecretGem_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnSecretGem_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {

	return false;
}
bool daEnSecretGem_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {

	return false;
}
bool daEnSecretGem_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}
bool daEnSecretGem_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}

bool daEnSecretGem_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther) {
	return false;
}


dActor_c *daEnSecretGem_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daEnSecretGem_c));
	daEnSecretGem_c *c = new(buffer) daEnSecretGem_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

int daEnSecretGem_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("supergem", "g3d/supergem.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("SuperGem");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Item(&bodyModel, 0);

	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("Wait");
	this->anm.setup(mdl, anmChr, &this->allocator, 0);

	this->anm.bind(&this->bodyModel, anmChr, 1);
	this->bodyModel.bindAnim(&this->anm, 0.0);
	this->anm.setUpdateRate(1.0);
	

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	// Stuff I do understand
	this->scale = (Vec){0.15f, 0.15f, 0.15f};

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;

	//this->pos.z = 4000;

	SaveBlock* save = GetSaveFile()->GetBlock(-1);
	OSReport("Secret Gems: %d\n", save->secretGems);
	if(save->secretGems != this->settings & 0xFF) this->Delete(1);
	if(secretGemCollected) this->Delete(1);

	doStateChange(&StateID_Wait);

	this->onExecute();
	return true;
}


int daEnSecretGem_c::onDelete() {
	return true;
}

int daEnSecretGem_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnSecretGem_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y - 8, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnSecretGem_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();
	acState.execute();

	//this->rot.y += 100;

	/*if (this->anm.isAnimationDone()) {
		this->anm.setCurrentFrame(0.0);
	}*/

	//this->removeMyActivePhysics();
	//this->Delete(1);

	return true;
}
//
// processed\../src/shroobUfo.cpp
//

const char* ShroobUFOFileList [] = { "shroobUfo", NULL };
const char* ShroobUFOLaserBallFileList [] = { NULL };

class daShroobUFOLaserBall_c : public dStageActor_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	static dActor_c* build();

	Vec moveVec;
	float speed;

	mEf::es2 effect;

	//void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	//bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat8_FencePunch(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);

};

class daShroobUFO_c : public dEn_c {
public:

	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	void updateModelMatrices();
	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	static dActor_c* build();

	//void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	//bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat8_FencePunch(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);

	int cooldown;

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c animationChr;
	m3d::anmChr_c animationChr2;
	m3d::anmChr_c animationChr3;
	nw4r::g3d::ResFile resFile;

	USING_STATES(daShroobUFO_c);
	DECLARE_STATE(Wait);
	DECLARE_STATE(Arm);
	DECLARE_STATE(Shoot);
	DECLARE_STATE(FlyAway);
};

CREATE_STATE(daShroobUFO_c, Wait);
CREATE_STATE(daShroobUFO_c, Arm);
CREATE_STATE(daShroobUFO_c, Shoot);
CREATE_STATE(daShroobUFO_c, FlyAway);

void daShroobUFO_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


void daShroobUFO_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->animationChr.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->animationChr, unk2);
	this->animationChr.setUpdateRate(rate);
}

dActor_c* daShroobUFO_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daShroobUFO_c));
	return new(buffer) daShroobUFO_c;
}

const SpriteData ShroobUFOSpriteData = { ProfileId::ShroobUfo, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile ShroobUFOProfile(&daShroobUFO_c::build, SpriteId::ShroobUfo, ShroobUFOSpriteData, ProfileId::ShroobUfo, ProfileId::ShroobUfo, "Shroob UFO", ShroobUFOFileList);


int daShroobUFO_c::onCreate() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	resFile.data = getResource("shroobUfo", "g3d/shroobUfo.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("shroobUfo");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("FlyNoTurret");
	this->animationChr.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink(); 

	ActivePhysics::Info HitMeBaby; 
	HitMeBaby.xDistToCenter = 0.0; 
	HitMeBaby.yDistToCenter = 0.0; 
	HitMeBaby.xDistToEdge = 0.0; 
	HitMeBaby.yDistToEdge = 0.0; 
	HitMeBaby.category1 = 0x3; 
	HitMeBaby.category2 = 0x0; 
	HitMeBaby.bitfield1 = 0x4F; 
	HitMeBaby.bitfield2 = 0xFFFFFFFF; 
	HitMeBaby.unkShort1C = 0; 
	HitMeBaby.callback = &dEn_c::collisionCallback; 
	this->aPhysics.initWithStruct(this, &HitMeBaby); 
	this->aPhysics.addToList(); 

	this->scale = (Vec){0.1, 0.1, 0.1};
	
	this->rot.y = -0x2000;
	
	//this->disableEatIn();

	//MakeMarioEnterDemoMode();

	doStateChange(&StateID_Wait);

	return true;
}

int daShroobUFO_c::onExecute() {
	acState.execute();

	updateModelMatrices();
	bodyModel._vf1C();

	/*if (this->animationChr.isAnimationDone()) {
		this->animationChr.setCurrentFrame(0.0);
	}*/

	return true;
}

int daShroobUFO_c::onDelete() {
	return true;
}

int daShroobUFO_c::onDraw() {
	bodyModel.scheduleForDrawing();

	return true;
}

void daShroobUFO_c::beginState_Wait() {
	bindAnimChr_and_setUpdateRate("FlyNoTurret", 1, 0.0, 1.0);
	cooldown = 120;											//I'm reusing cooldown here since I don't want to add new integers if I don't need them \_()_/
}
void daShroobUFO_c::executeState_Wait() {
	if(this->animationChr.isAnimationDone()) {
		this->animationChr.setCurrentFrame(0.0);
	}
	
	if(/*GenerateRandomNumber(33) == 0 ||*/ cooldown < 1) {
		doStateChange(&StateID_Arm);
	} else {
		cooldown--;
		this->pos.x -= 2;
		if(this->animationChr.isAnimationDone()) {
			this->animationChr.setCurrentFrame(0.0);
		}
	}
}
void daShroobUFO_c::endState_Wait() {
	bindAnimChr_and_setUpdateRate("ArmOut", 1, 0.0, 1.0);
}

void daShroobUFO_c::beginState_Arm() {}
void daShroobUFO_c::executeState_Arm() {
	if(this->animationChr.isAnimationDone()) {
		if(GenerateRandomNumber(10) == 0) {
			doStateChange(&StateID_FlyAway);
		} else {
			doStateChange(&StateID_Shoot);
		}	
	}
}
void daShroobUFO_c::endState_Arm() {}

void daShroobUFO_c::beginState_Shoot() {
	bindAnimChr_and_setUpdateRate("GunOutFire", 1, 0.0, 1.0);
}
void daShroobUFO_c::executeState_Shoot() {
	if(this->animationChr.isAnimationDone()) {
		daShroobUFOLaserBall_c* laserBall = (daShroobUFOLaserBall_c*)dStageActor_c::create(ShroobUFOLaserBall, 0, &(Vec){pos.x-10.5, pos.y-10, 6000}, 0, this->currentLayerID);
		laserBall->moveVec.x = -0.5;
		laserBall->moveVec.y = -0.5;
		doStateChange(&StateID_Arm);
	}
}
void daShroobUFO_c::endState_Shoot() {}

void daShroobUFO_c::beginState_FlyAway() {
	bindAnimChr_and_setUpdateRate("ArmIn", 1, 0.0, 1.0);
}
void daShroobUFO_c::executeState_FlyAway() {
	if(this->animationChr.isAnimationDone()) {
		cooldown = 0;
		doStateChange(&StateID_Wait);
	}
}
void daShroobUFO_c::endState_FlyAway() {}





dActor_c* daShroobUFOLaserBall_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daShroobUFOLaserBall_c));
	return new(buffer) daShroobUFOLaserBall_c;
}

const SpriteData ShroobUFOLaserBallSpriteData = { ProfileId::ShroobUFOLaserBall, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile ShroobUFOLaserBallProfile(&daShroobUFOLaserBall_c::build, SpriteId::ShroobUFOLaserBall, ShroobUFOLaserBallSpriteData, ProfileId::ShroobUFOLaserBall, ProfileId::ShroobUFOLaserBall, "ShroobUFOLaserBall", ShroobUFOLaserBallFileList);

int daShroobUFOLaserBall_c::onCreate() {
	speed = (this->settings >> 8 & 0xF) * 0.25;
	moveVec.x = cos(0.024543692606 * (this->settings & 0xF)) * speed;
	moveVec.y = sin(0.024543692606 * (this->settings & 0xF)) * speed;
	
	return true;
}

int daShroobUFOLaserBall_c::onExecute() {
	this->pos.x += moveVec.x;
	this->pos.y += moveVec.y;
	
	S16Vec nullRot = {0,0,0};
	Vec oneVec = {1.0f, 1.0f, 1.0f};
	effect.spawn("Ufo_Laser", 0, &pos, &nullRot, &oneVec);
	
	return true;
}

int daShroobUFOLaserBall_c::onDelete() {
	return true;
}

int daShroobUFOLaserBall_c::onDraw() {
	return true;
}
//
// processed\../src/shyCart.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "baddy.h"

const char* ShyCartFileList[] = { "shyCart", 0 };


class daEnShyCart_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;

	dPlayer* passenger;
	bool done;
	int timerDone;

	int alreadyOnTop;

	bool isOnTopOfTile;
	u32 cmgr_returnValue;

	int driveSpeed;
	bool moveable;
	
	//int last_speed_y;
	//int last_speed_x;

	static dActor_c* build();

	void updateModelMatrices();

	bool calculateTileCollisions();

	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);
};

const SpriteData ShyCartSpriteData = { ProfileId::ShyCart, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile ShyCartProfile(&daEnShyCart_c::build, SpriteId::ShyCart, ShyCartSpriteData, ProfileId::ShyCart, ProfileId::ShyCart, "ShyCart", ShyCartFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);


bool daEnShyCart_c::calculateTileCollisions() {

	/****************************/
	/***Tile collision detector**/
	/*Returns true if hit a wall*/
	/****************************/

	HandleYSpeed();    
	HandleXSpeed();                                      //consider the X speed
	                                  //consider the Y speed
	doSpriteMovement();                                  //execute the speed movements

	cmgr_returnValue = collMgr.isOnTopOfTile();          //check if the sprite is on top of a tile
	collMgr.calculateBelowCollisionWithSmokeEffect();    //duh

	stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);      //literally stuff related to collisions

	float xDelta = pos.x - last_pos.x;                   //just read dude

	if (xDelta >= 0.0f) {                                //change of direction if needed
		direction = 0;
	}
	else {
		direction = 1;
	}

	if (collMgr.isOnTopOfTile()) {                       //if the sprite is on top of a tile
		if (alreadyOnTop == 0) {                          //if it just landed
			PlaySound(this, SE_OBJ_ROCK_LAND);           //play SFX
			alreadyOnTop = 1;                            //now it's already on the to^p
		}

		if (cmgr_returnValue == 0)                       //just read ?
			isOnTopOfTile = true;

		speed.y = 0.0f;                                  //no Y speed anymore cuz it's on the ground
		max_speed.x = (direction == 1) ? -1.5f : 1.5f;   //maximum X speed re-setting
		this->x_speed_inc = 0.0f;                        //no X speed incrementation
		this->speed.x = (direction == 1) ? -1.5f : 1.5f; //X speed re-setting
	}
	else {                                               //if the sprite in in mid-air
		alreadyOnTop = 0;                                //it's no loner on the top of a tile
	}

	collMgr.calculateAdjacentCollision(0);               //literally calculate the adjacent collision

	if (collMgr.outputMaybe & (0x15 << direction)) {     //if hit a wall
		if (collMgr.isOnTopOfTile()) {                   //if on the top of a tile
			isOnTopOfTile = true;
		}
		return true;                                     //returns true duh
	}
	return false;                                        //if didn't hit a wall
}




void daEnShyCart_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	/*//OSReport("Collided\n");
	//OSReport("Which_Player: %d\n", apOther->owner->which_player);
	if (this->passenger == (dPlayer*)apOther->owner || playerInWork[apOther->owner->which_player] || this->done)
	{
		return;
	}*/
	if (this->passenger == 0 && playerStatus[apOther->owner->which_player] == 0)
	{
		OSReport("Yes\n");
		this->passenger = (dPlayer*)apOther->owner;
		playerStatus[apOther->owner->which_player] = 2;
		//playerInWork[apOther->owner->which_player] = true;
		//playerRiding[apOther->owner->which_player] = true;
		return;
	}
}
void daEnShyCart_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	//this->playerCollision(apThis, apOther);
}
bool daEnShyCart_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnShyCart_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnShyCart_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnShyCart_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnShyCart_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnShyCart_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnShyCart_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnShyCart_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnShyCart_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnShyCart_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daEnShyCart_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnShyCart_c));
	daEnShyCart_c* c = new(buffer) daEnShyCart_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

int daEnShyCart_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("shyCart", "g3d/shyCart.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("ShyCart");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;
	HitMeBaby.xDistToEdge = 8.0;
	HitMeBaby.yDistToEdge = 10.0;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0x8028E;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	// Stuff I do understand
	this->scale = (Vec){ 20.0, 20.0, 20.0 };

	this->rot.x = 0; // X is vertical axis
	this->rot.y = 0xD800; // Y is horizontal axis
	this->rot.z = 0; // Z is ... an axis >.>

	this->rot.y *= -1;


	this->driveSpeed = this->settings >> 25 & 0b11111111;
	this->moveable = true;


	this->max_speed.x = 10;
	this->speed.x = 0.0;             //set the current X speed depending of the spawning direction
	this->x_speed_inc = -0.6;                   //set the X speed increment depending of the spawning direction

	this->max_speed.y = -4;                                               //set the maximum Y speed
	this->speed.y = 0.0;                                                  //set the current Y speed
	this->y_speed_inc = -0.5;



	// These fucking rects do something for the tile rect
	spriteSomeRectX = 28.0f;
	spriteSomeRectY = 32.0f;
	_320 = 0.0f;
	_324 = 16.0f;

	static const lineSensor_s below(-5 << 12, 5 << 12, -9 << 12);            //Below collider:    unk, unk, y pos 
	static const pointSensor_s above(0 << 12, 12 << 12);                   //Above collider:    unk, unk, unk
	static const lineSensor_s adjacent(3 << 12, 6 << 12, 6 << 12);           //Adjacent collider: unk, unk, unk

	collMgr.init(this, &below, &above, &adjacent);                     //initating colliders
	collMgr.calculateBelowCollisionWithSmokeEffect();                  //dude, the description of this line IS in the line, so what are you reading ?

	cmgr_returnValue = collMgr.isOnTopOfTile();                        //get if the sprite is in top of a tile (GOD DAMMIT IT IS WROTE)

	if (collMgr.isOnTopOfTile())                                       //just... read !
		isOnTopOfTile = false;
	else
		isOnTopOfTile = true;

	//this->last_speed_x = passenger->speed.x;
	//this->last_speed_y = passenger->speed.y;

	this->done = false;
	this->timerDone = 0;

	for (int i = 0; i < 4; i++)
	{
		if (playerCart[i] == 0)
		{
			playerCart[i] = this;
			break;
		}
	}

	this->onExecute();
	return true;
}


int daEnShyCart_c::onDelete() {
	return true;
}

int daEnShyCart_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnShyCart_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnShyCart_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();

	if (this->passenger != 0)
	{
		if (!this->done)
		{

			this->passenger->pos = this->pos;
			this->passenger->last_pos = this->pos;


			//this->speed.x += this->x_speed_inc;
			//this->speed.y += this->y_speed_inc;


			/*if (this->last_speed_x < 0 && passenger->speed.x > 0)
			{
				this->speed.x = 5;
			}
			else if (this->last_speed_x > 0 && passenger->speed.x < 0)
			{
				this->speed.x = -5;
			}


			if (this->last_speed_y < 0 && passenger->speed.y > 0)
			{
				this->speed.y = 3;
			}
			else if (this->last_speed_y > 0 && passenger->speed.y < 0)
			{

			}*/


			/*this->speed.x = this->passenger->speed.x * 2;
			if (this->passenger->speed.y > 0)
			{
				this->speed.y = this->passenger->speed.y * 2;
			}
			else
			{
				this->speed.y = -4;
			}


			if (this->speed.x < 0)
			{
				this->max_speed.x = -10;
			}
			else
			{
				this->max_speed.x = 10;
			}

			if (this->speed.x < 0)
			{
				this->x_speed_inc = 0.6;
			}
			else {
				this->x_speed_inc = -0.6;
			}

			this->max_speed.y = -4;
			this->y_speed_inc = -0.5;*/

			/*if (this->speed.y >= -4)
			{
				this->speed.y -= 0.05;
			}*/


			Remocon* pIn = RemoconMng->controllers[this->passenger->which_player];

			//OSReport("Drivespeed: %d\n", this->driveSpeed);
			//OSReport("Held Buttons: %d\n", pIn->heldButtons);
			if (this->moveable)
			{
				if (pIn->heldButtons & WPAD_LEFT)
				{
					//OSReport("Left Pressed\n");
					this->speed.x = (this->driveSpeed / 2) * 1;
				}
				else
				{
					this->speed.x = this->driveSpeed;
				}
			}
			else
			{
				/*if (this->speed.x > 0)
				{
					this->speed.x -= 0.05;
				}
				else
				{
					this->speed.x = 0;
				}*/
				this->speed.x = 0;
			}

			if (Remocon_GetPressed(pIn) & WPAD_TWO && this->collMgr.isOnTopOfTile())
			{
				this->speed.y += 9;
			}

			//OSReport("Is Shaking: %d\n", pIn->isShaking);

			if (pIn->isShaking >= 1)
			{
				this->done = true;
			}

			//if (this->done) {
			//	i
			//}
			//else {
				passenger->speed.x = this->speed.x;

				this->passenger->pos = this->pos;
				this->passenger->last_pos = this->pos;
			//}

			bool ret = calculateTileCollisions();

			//this->last_speed_x = this->passenger->speed.x;
			//this->last_speed_y = this->passenger->speed.y;
		}
	}
	else
	{
		this->speed.x = 0;
		this->speed.y = -2;
		bool ret = calculateTileCollisions();
	}

	if (this->done && this->passenger != 0)
	{
		this->passenger->speed.x = this->speed.x * 3;
		this->passenger->speed.y += 9;
		playerStatus[this->passenger->which_player] = 0;
		this->passenger = 0;
	}

	if (this->done)
	{
		this->timerDone += 1;
		//OSReport("Timer: %d\n", timerDone);
		if (this->timerDone == 100)
		{
			this->timerDone = 0;
			this->done = false;
		}
		//OSReport("Timer: %d\n", timerDone);
	}

	return true;
}
//
// processed\../src/rail.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "baddy.h"

const char* RailFileList[] = { "rail", 0 };


class daEnRail_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	/*mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;*/

	static dActor_c* build();


	int breite;
	int hoehe;
	int type;


	//void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);
};

const SpriteData RailSpriteData = { ProfileId::Rail, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile RailProfile(&daEnRail_c::build, SpriteId::Rail, RailSpriteData, ProfileId::Rail, ProfileId::Rail, "Rail", RailFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnRail_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	switch (type)
	{
	case 0:
		if (playerStatus[apOther->owner->which_player] == 2)
		{
			playerCart[apOther->owner->which_player]->done = true;
		}
		break;
	case 1:
		break;
	case 2:
		if (playerStatus[apOther->owner->which_player] == 2)
		{
			playerCart[apOther->owner->which_player]->moveable = false;
		}
		break;
	case 3:
		if (playerStatus[apOther->owner->which_player] == 2)
		{
			playerCart[apOther->owner->which_player]->moveable = true;
		}
		break;
	default:
		break;
	}
}
void daEnRail_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->playerCollision(apThis, apOther);
}
bool daEnRail_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnRail_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnRail_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnRail_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnRail_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnRail_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnRail_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnRail_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnRail_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnRail_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daEnRail_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnRail_c));
	daEnRail_c* c = new(buffer) daEnRail_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

int daEnRail_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	/*allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("rail", "g3d/rail.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("Rail");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	allocator.unlink();*/


	this->breite = this->settings >> 23 & 0b11111111;					
	this->hoehe = this->settings >> 15 & 0b11111111;							
	this->type = this->settings >> 0 & 0b1111111111111111;

	OSReport("Type: %d\n", this->type);


	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;
	HitMeBaby.xDistToEdge = breite;
	HitMeBaby.yDistToEdge = hoehe;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0x8028E;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	// Stuff I do understand
	this->scale = (Vec){ 20.0, 20.0, 20.0 };

	this->rot.x = 0; // X is vertical axis
	this->rot.y = 0; // Y is horizontal axis
	this->rot.z = 0; // Z is ... an axis >.>


	this->onExecute();
	return true;
}


int daEnRail_c::onDelete() {
	return true;
}

int daEnRail_c::onDraw() {
	//bodyModel.scheduleForDrawing();
	return true;
}


/*void daEnRail_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}*/

int daEnRail_c::onExecute() {
	//bodyModel._vf1C();
	//updateModelMatrices();

	return true;
}
//
// processed\../src/whereAmIGoing.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include <dCourse.h> 

class whereAmIGoing : public dStageActor_c {
public:
	float width;
	float height;
	float posY;
	float posX;
	u8 type;

	
	int zoneNum;

	

	dStageActor_c* moving[8];
	u8 movingDone[8];
	bool movingDirection[8];

	int yayCameraID;
	nw4r::g3d::CameraData* yayCameraData;

	int onCreate();
	int onExecute();

	static dActor_c* build();
};

const char* WhereAmIGoingFileList[] = { 0 };
const SpriteData WhereAmIGoingSpriteData = { ProfileId::WhereAmIGoing, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile WhereAmIGoingProfile(&whereAmIGoing::build, SpriteId::WhereAmIGoing, WhereAmIGoingSpriteData, ProfileId::WhereAmIGoing, ProfileId::WhereAmIGoing, "WhereAmIGoing", WhereAmIGoingFileList);


dActor_c* whereAmIGoing::build() {
	void* buffer = AllocFromGameHeap1(sizeof(whereAmIGoing));
	whereAmIGoing* c = new(buffer) whereAmIGoing;

	return c;
}

int whereAmIGoing::onCreate() {

	this->yayCameraID = GetCurrentCameraID();

	this->yayCameraData = GetCameraByID(this->yayCameraID);

	OSReport("Camera ID: %d\n", this->yayCameraID);

	this->type = this->settings >> 28 & 0xF;

	if (this->type == 0)
	{
		this->posX = this->settings >> 18 & 0b1111111111;
		this->posX *= -1;
	}
	else if (this->type == 1)
	{
		this->posY = this->settings >> 18 & 0b1111111111;
		this->posY *= -1;
	}

	if (this->type == 0)
	{
		this->width = this->settings >> 0 & 0xFFFF;
	}
	else if (this->type == 1)
	{
		this->height = this->settings >> 0 & 0xFFFF;
	}


	OSReport("Where Created Type:%d\n", this->type);
	OSReport("Where Created PosY:%d\n", this->posY);
	OSReport("Where Created Height:%d\n", this->height);


	dCourse_c* course = dCourseFull_c::instance->get(GetAreaNum());
	zoneNum = GetZoneNum();
	//dCourse_c::bounding_s* boundings = &course->getBoundingByID(zoneNum);
	dCourse_c::zone_s* zone = course->getZoneByID(zoneNum);

	for (int i = 0; i < 8; i++) {
		moving[i] = 0;
		movingDirection[i] = false;
		movingDone[i] = 31;
	}

	this->onExecute();
	return true;
}

int whereAmIGoing::onExecute() {

	dStageActor_c* current;
	Actor* currentActor;

	currentActor = FindActorByType(PLAYER, 0);
	current = (dStageActor_c*)currentActor;

	OSReport("Type: %d\n", this->type);

	/*Actor* cameraActor;
	cameraActor = FindActorByType(CAMERA, 0);
	int i = 0;

	nw4r::g3d::Camera* cami;

	while (cameraActor != 0)
	{
		cami = (nw4r::g3d::Camera*)cameraActor;



		//OSReport("camera class: %s    ID: %d\n", cameraActor->class_name, i);
		cameraActor = FindActorByType(CAMERA, cameraActor);
		i++;
	}*/

	//currentZoneID

	while (current != 0)
	{
		//OSReport("Where Found Player\n");
		/*OSReport("Active: %d\n", yayCameraData != 0);

		OSReport("Camera Data Pos x: %f\n", this->yayCameraData->cameraPos.x);
		OSReport("Camera Data Pos y: %f\n", this->yayCameraData->cameraPos.y);
		OSReport("Camera Data Pos z: %f\n", this->yayCameraData->cameraPos.z);

		OSReport("Camera Data Up x: %f\n", this->yayCameraData->cameraUp.x);
		OSReport("Camera Data Up y: %f\n", this->yayCameraData->cameraUp.y);
		OSReport("Camera Data Up z: %f\n", this->yayCameraData->cameraUp.z);

		OSReport("Camera Data Target x: %f\n", this->yayCameraData->cameraTarget.x);
		OSReport("Camera Data Target y: %f\n", this->yayCameraData->cameraTarget.y);
		OSReport("Camera Data Target z: %f\n", this->yayCameraData->cameraTarget.z);

		OSReport("Camera Data Twist x: %f\n", this->yayCameraData->cameraRotate.x);
		OSReport("Camera Data Twist y: %f\n", this->yayCameraData->cameraRotate.y);
		OSReport("Camera Data Twist z: %f\n", this->yayCameraData->cameraRotate.z);*/


		/*OSReport("ClassWithCameraInfo _34: %f\n", ClassWithCameraInfo::instance->_34);

		OSReport("ClassWithCameraInfo screenLeft: %f\n", ClassWithCameraInfo::instance->screenLeft);
		OSReport("ClassWithCameraInfo screenTop: %f\n", ClassWithCameraInfo::instance->screenTop);

		OSReport("ClassWithCameraInfo screen Width: %f\n", ClassWithCameraInfo::instance->screenWidth);
		OSReport("ClassWithCameraInfo screen Height: %f\n", ClassWithCameraInfo::instance->screenHeight);

		OSReport("ClassWithCameraInfo centre X: %f\n", ClassWithCameraInfo::instance->screenCentreX);
		OSReport("ClassWithCameraInfo centre y: %f\n", ClassWithCameraInfo::instance->screenCentreY);

		OSReport("ClassWithCameraInfo offset X: %f\n", ClassWithCameraInfo::instance->xOffset);

		current->pos.x += current->speed.x + 2;

		OSReport("Player X: %f\n", current->pos.x);

		//ClassWithCameraInfo::instance->screenCentreY += 0.001;


		/*if (outOfZone(current->pos, false, current->currentZoneID))
		{
			if (this->type == 0)
			{
				if (current->pos.x < this->posX + (this->width / 2))
				{
					OSReport("Where moved Player\n");
					current->pos.x = this->width + this->posX - 10;
				}
				else if (current->pos.x > this->posX + (this->width / 2))
				{
					current->pos.x = this->posX + 10;
					OSReport("Where moved Player\n");
				}
			}
			else if (this->type == 1)
			{
				if (current->pos.y < this->posY - this->height)
				{
					OSReport("Where moved Player\n");
					current->pos.y = this->posY;
				}
				else if (current->pos.y > this->posY)
				{
					current->pos.y = this->posY - this->height;
					OSReport("Where moved Player\n");
				}
			}
		}*/

		Remocon* pIn = RemoconMng->controllers[current->which_player];

		if (this->type == 0) {
			OSReport("Speed: %f\n", current->speed.x);
			OSReport("x: %f\n", current->pos.x);
			OSReport("last x: %f\n", current->last_pos.x);

			if (pIn->heldButtons & WPAD_LEFT && current->speed.x > -0.11 && current->speed.x < 0) {
				if (!((current->collMgr.outputMaybe & (0x15 << 0)) || (current->collMgr.outputMaybe & (0x15 << 1)))) {
					OSReport("End of Zone\n");
				}
			}
		}
		else if (this->type == 1) {
			/*OSReport("Y: %f \n", current->pos.y);
			OSReport("screen centre: %f \n", ClassWithCameraInfo::instance->screenCentreY);
			OSReport("screen centre: %f \n", ClassWithCameraInfo::instance->screenHeight);
			OSReport("rechnen: %f \n", ClassWithCameraInfo::instance->screenCentreY - (ClassWithCameraInfo::instance->screenHeight / 2));*/

			OSReport("Where Created Type:%d\n", this->type);
			OSReport("Where Created PosY:%f\n", this->posY);
			OSReport("Where Created Height:%f\n", this->height);
			OSReport("PosY:%f\n", current->pos.y);

			if (current->pos.y < this->posY - height) {
				OSReport("End of Zone Bottom\n");


				/*bool jap = false;
				for (int i = 0; i < 8; i++)
				{
					if (current == moving[i])
					{
						jap = true;
					}
				}
				if (jap == false) {
					for (int i = 0; i < 8; i++)
					{
						if (moving[i] == 0) {
							moving[i] = current;
							movingDirection[i] = false;
							movingDone[i] = 0;
							break;
						}
					}
				}*/


				current->pos.y = this->posY;
			}
			else if (current->pos.y > this->posY - 48) {
				OSReport("End of Zone Top\n");


				/*bool jap = false;
				for (int i = 0; i < 8; i++)
				{
					if (current == moving[i])
					{
						jap = true;
					}
				}
				if (jap == false) {
					for (int i = 0; i < 8; i++)
					{
						if (moving[i] == 0) {
							moving[i] = current;
							movingDirection[i] = true;
							movingDone[i] = 0;
							break;
						}
					}
				}*/


				current->pos.y = this->posY - height + 48;
			}

			OSReport("PosY:%f\n", current->pos.y);
		}

		currentActor = FindActorByType(PLAYER, currentActor);
		current = (dStageActor_c*)currentActor;
	}

	/*for (int i = 0; i < 8; i++)
	{
		if (moving[i] != 0) {
			OSReport("JAAAAAA\n");
			if (movingDirection[i] == false) {
				OSReport("JOOOOO\n");
				if (movingDone[i] < 127) {
					OSReport("YEEEEEET\n");
					moving[i]->pos.y = this->posY;
					movingDone[i] += 1;
				}
				else {
					moving[i]->pos.y = this->posY;
					movingDone[i] = 0;
					moving[i] = 0;
					OSReport("YAAAAAATT\n");
				}
			}
			else {
				OSReport("JOOOOOOOOOOOOOOOOOOOOOO\n");
				if (movingDone[i] < 127) {
					OSReport("YEEEEEEEEEEEEEEEEEEEEET\n");
					moving[i]->pos.y = this->posY - this->height + 200;
					movingDone[i] = 0;
					moving[i] = 0;
					OSReport("YAAAAAAAAAAAAAAAAAAAAAAATT\n");
				}
			}
		}
	}*/				

	return true;
}
//
// processed\../src/warpBox.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

const char* WarpBoxFileList[] = { "warpBox", 0 };


class daEnWarpBox_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;

	daEnWarpBox_c* otherBox;
	int id;

	static dActor_c* build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);
};

const SpriteData WarpBoxSpriteData = { ProfileId::WarpBox, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile WarpBoxProfile(&daEnWarpBox_c::build, SpriteId::WarpBox, WarpBoxSpriteData, ProfileId::WarpBox, ProfileId::WarpBox, "WarpBox", WarpBoxFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnWarpBox_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
}
void daEnWarpBox_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
}
bool daEnWarpBox_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnWarpBox_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnWarpBox_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnWarpBox_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnWarpBox_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnWarpBox_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnWarpBox_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnWarpBox_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnWarpBox_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnWarpBox_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daEnWarpBox_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnWarpBox_c));
	daEnWarpBox_c* c = new(buffer) daEnWarpBox_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

int daEnWarpBox_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("warpBox", "g3d/warpBox.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("WarpBox");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	// Stuff I do understand
	this->scale = (Vec){ 0.2, 0.2, 0.2 };

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;

	this->pos.z = -4000;


	this->id = this->settings >> 24 & 0xFF;

	OSReport("Box ID: %d\n", this->id);
	
	this->otherBox = (daEnWarpBox_c*)FindActorByType(WarpBox, 0);

	while (this->otherBox != 0)
	{
		if (this->otherBox->id == this->id && this->otherBox != this) {
			break;
		}
		else {
			this->otherBox = (daEnWarpBox_c*)FindActorByType(WarpBox, (Actor*)this->otherBox);
		}
	}

	OSReport("Other Box: %p\n", this->otherBox);

	//this->onExecute();
	return true;
}


int daEnWarpBox_c::onDelete() {
	return true;
}

int daEnWarpBox_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnWarpBox_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnWarpBox_c::onExecute() {

	dStageActor_c* current = (dStageActor_c*)FindActorByType(PLAYER, 0);

	while (current != 0)
	{
		//OSReport("Speed: %f\n", current->speed.y);
		//OSReport("Inc Speed: %f\n", current->y_speed_inc);

		//current->y_speed_inc = -0.17;
		//current->speed.y *= -1;
		//current->y_speed_inc *= -1;
		//current->speed.y -= (current->speed.y + current->y_speed_inc) * 2;

		Remocon* pIn = RemoconMng->controllers[current->which_player];

		if (Remocon_GetPressed(pIn) & WPAD_TWO)
		{
			OSReport("2 Pressed\n");
			this->speed.y += 4;
		}

		//OSReport("Tileset 1: %08x \n", current->collMgr.getTileBehaviour1At(current->pos.x, current->pos.y - 32, 0));
		//OSReport("Tileset 2: %08x \n", current->collMgr.getTileBehaviour2At(current->pos.x, current->pos.y - 32, 0));
		//OSReport("Tileset 1: %08x \n", current->collMgr.getTileBehaviour1At(current->pos.x, current->pos.y - 32, 1));
		//OSReport("Tileset 2: %08x \n", current->collMgr.getTileBehaviour2At(current->pos.x, current->pos.y - 32, 1));
		//OSReport("Tileset 1: %08x \n", current->collMgr.getTileBehaviour1At(current->pos.x, current->pos.y - 32, 2));
		//OSReport("Tileset 2: %08x \n", current->collMgr.getTileBehaviour2At(current->pos.x, current->pos.y - 32, 2));
		//OSReport("Pos Y: %f \n", current->pos.y);

		//current->aPhysics.unkArray[0].y += 1;
		//current->aPhysics.update();

		//OSReport("Speed Post: %f\n", current->speed.y);
		//OSReport("Inc Speed Post: %f\n", current->y_speed_inc);
		current = (dStageActor_c*)FindActorByType(PLAYER, (Actor*)current);
	}




	if (this->otherBox == 0) {
		/*daEnWarpBox_c* currentBox;

		currentBox = (daEnWarpBox_c*)FindActorByType(WarpBox, 0);

		while (currentBox != 0)
		{
			if (currentBox->id == this->id && currentBox != this) {
				this->otherBox = currentBox;
			}
			currentBox = (daEnWarpBox_c*)FindActorByType(WarpBox, (Actor*)currentBox);
		}

		OSReport("Other Box: %p\n", this->otherBox);*/

		this->otherBox = (daEnWarpBox_c*)FindActorByType(WarpBox, 0);

		while (this->otherBox != 0)
		{
			if (this->otherBox->id == this->id && this->otherBox != this) {
				break;
			}
			else {
				this->otherBox = (daEnWarpBox_c*)FindActorByType(WarpBox, (Actor*)this->otherBox);
			}
		}

		OSReport("Other Box: %p\n", this->otherBox);
	}
	else {

		bodyModel._vf1C();

		dStageActor_c* current;
		Actor* currentActor;

		currentActor = FindActorByType(PLAYER, 0);
		current = (dStageActor_c*)currentActor;

		while (current != 0)
		{
			if (current->pos.y <= this->pos.y + 7.5 && current->pos.y >= this->pos.y - 7.5 && current->pos.x <= this->pos.x + 7.5 && current->pos.x >= this->pos.x - 7.5) {
				OSReport("Warp Collide\n");

				current->pos.y = otherBox->pos.y;
				current->pos.x = otherBox->pos.x;
				current->last_pos.y = otherBox->pos.y;
				current->last_pos.x = otherBox->pos.x;
			}

			currentActor = FindActorByType(PLAYER, currentActor);
			current = (dStageActor_c*)currentActor;
		}
	}

	return true;
}
//
// processed\../src/boshi.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

extern "C" dCourse_c::rail_s * GetRail(int id);

const char* BoshiFileList[] = { "boshi", 0 };


class daEnBoshi_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile resFileAnim;
	m3d::mdl_c bodyModel;

	m3d::anmChr_c chrAnimation;

	//1,3,4 may be unecesary
	u8 moveDirection;
	float aTestFloat;
	s16 leftRotPtr;
	s16 rightRotPtr;

	dCourse_c* course;
	dCourse_c::rail_s* rail;
	dCourse_c::railNode_s* currentNode;
	dCourse_c::railNode_s* nextNode;
	int currentNodeNum;
	int steps;
	int speed;
	float moveX, moveY;

	bool done;

	static dActor_c* build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);

	USING_STATES(daEnBoshi_c);

	DECLARE_STATE(Wait);
	DECLARE_STATE(Run);
};


CREATE_STATE(daEnBoshi_c, Wait);
CREATE_STATE(daEnBoshi_c, Run);


void daEnBoshi_c::beginState_Wait() { OSReport("HI 0.7 \n"); bindAnimChr_and_setUpdateRate("YB_Rwait", 1, 0.0, 1.0); }
void daEnBoshi_c::executeState_Wait() {
	if (!done)
	{
		dStageActor_c* player = (dStageActor_c*)FindActorByType(PLAYER, 0);

		OSReport("HI 1\n");

		if (player->pos.x >= this->pos.x - 64)
		{
			OSReport("HI 2\n");
			doStateChange(&StateID_Run);
		}
	}
	else
	{
		dStageActor_c* player = (dStageActor_c*)FindActorByType(PLAYER, 0);

		if (player->pos.x < this->pos.x && player->pos.x > this->pos.x - 64)
		{
			//boss::OutroSetup(0);
		}
	}
}
void daEnBoshi_c::endState_Wait() { OSReport("HI 2.3\n"); }


void daEnBoshi_c::beginState_Run() 
{
	OSReport("HI 2.7\n"); 

	switch ((int)currentNode->speed)
	{
	case 0:
		bindAnimChr_and_setUpdateRate("YB_Rwait", 1, 0.0, 1.5);
		break;
	case 1:
		bindAnimChr_and_setUpdateRate("YB_Rrun", 1, 0.0, 1.5);
		break;
	case 2:
		bindAnimChr_and_setUpdateRate("YB_Rb_dash", 1, 0.0, 1.5);
		break;
	case 3:
		bindAnimChr_and_setUpdateRate("YB_Rb_dash2", 1, 0.0, 1.5);
		break;
	}
}
void daEnBoshi_c::executeState_Run() {
	OSReport("HI 3\n");

	if (!done)
	{
		float dx = nextNode->xPos - currentNode->xPos;
		float dy = (-nextNode->yPos) - (-currentNode->yPos);

		float ux = (dx / sqrtf((dx * dx) + (dy * dy)));
		float uy = (dy / sqrtf((dx * dx) + (dy * dy)));

		this->pos.y += uy * speed;
		this->pos.x += ux * speed;

		if (dx <= 0)
		{
			this->rot.y = 0x4000;
			this->rot.y *= -1;
		}
		else
		{
			this->rot.y = 0x4000;
		}

		OSReport("x: %f; y: %f\n", this->pos.x, this->pos.y);
		OSReport("nx: %f; ny: %f\n", currentNode->xPos, -currentNode->yPos);
		OSReport("dx: %f; dy: %f\n", dx, dy);
		OSReport("ux: %f; uy: %f\n", ux, uy);

		if (this->pos.x > dx + currentNode->xPos - 2 && this->pos.x < dx + currentNode->xPos + 2 && this->pos.y > dy - currentNode->yPos - 2 && this->pos.y < dy - currentNode->yPos + 2)
		{
			done = true;
		}
	}
	else
	{
		currentNodeNum++;
		currentNode = nextNode;
		nextNode = &course->railNode[rail->startNode + 1 + currentNodeNum];
		this->pos.x = currentNode->xPos;
		this->pos.y = -currentNode->yPos;

		if (rail->nodeCount == currentNodeNum + 1)
		{
			doStateChange(&StateID_Wait);
			this->rot.y = 0x4000;
			this->rot.y *= -1;
		}
		else
		{
			done = false;
		}

		switch ((int)currentNode->speed)
		{
		case 0:
			bindAnimChr_and_setUpdateRate("YB_Rwait", 1, 0.0, 1.5);
			break;
		case 1:
			bindAnimChr_and_setUpdateRate("YB_Rrun", 1, 0.0, 1.5);
			break;
		case 2:
			bindAnimChr_and_setUpdateRate("YB_Rb_dash", 1, 0.0, 1.5);
			break;
		case 3:
			bindAnimChr_and_setUpdateRate("YB_Rb_dash2", 1, 0.0, 1.5);
			break;
		}

		dStageActor_c* spawner = CreateActor(51, 0, this->pos, 0, 0);
	}

	/*if (steps) {
		this->pos.x += moveX;
		this->pos.y += moveY;
		this->steps--;
		OSReport("HI 4\n");
	}
	else {
		OSReport("HI 5\n");
		float remainX = (nextNode->xPos - this->pos.x);
		float remainY = (nextNode->yPos - this->pos.y);
		float nextL = this->speed - sqrtf((remainX * remainX) + (remainY * remainY));
		currentNodeNum++;
		currentNode = nextNode;
		nextNode = &course->railNode[rail->startNode + 1 + currentNodeNum];
		float dx = (nextNode->xPos - currentNode->xPos);
		float dy = (nextNode->yPos - currentNode->yPos);
		float distance = sqrtf((dx * dx) + (dy * dy));
		this->pos.x = currentNode->xPos + (nextL / distance * dx);
		this->pos.y = currentNode->yPos - (nextL / distance * dy);
		moveX = this->speed / distance * dx;
		moveY = -(this->speed / distance * dy);
		dx = (nextNode->xPos - this->pos.x);
		dy = (-nextNode->yPos - this->pos.y);
		distance = sqrtf((dx * dx) + (dy * dy));
		this->steps = (int)floor(distance / speed);
	}*/
}
void daEnBoshi_c::endState_Run() { OSReport("HI 5.3\n"); }


const SpriteData BoshiSpriteData = { ProfileId::Boshi, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile BoshiProfile(&daEnBoshi_c::build, SpriteId::Boshi, BoshiSpriteData, ProfileId::Boshi, ProfileId::Boshi, "Boshi", BoshiFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnBoshi_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
}
void daEnBoshi_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
}
bool daEnBoshi_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnBoshi_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnBoshi_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnBoshi_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnBoshi_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnBoshi_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnBoshi_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnBoshi_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnBoshi_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnBoshi_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daEnBoshi_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnBoshi_c));
	daEnBoshi_c* c = new(buffer) daEnBoshi_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

void daEnBoshi_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate)
{
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daEnBoshi_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("Yoshi", "g3d/model.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("YB_model");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);


	this->resFileAnim.data = getResource("Y_rcha", "g3d/model.brres");
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr("YB_Rwait");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	this->disableEatIn();

	OSReport("HI 0\n");


	this->aTestFloat = 0.25f;

	done = false;


	speed = this->settings >> 16 & 0b1111;						    //Bit 29-32
	//speed += 1;
	//speed *= 2;
	//speed = 8;
	currentNodeNum = this->settings >> 8 & 0b11111111;						//Bit 33-40
	int pathID = this->settings >> 0 & 0b11111111;                               //Bit 41-48
	OSReport("speed: %d, currentNodeNum: %d, pathID: %d\n", speed, currentNodeNum, pathID);
	if (pathID) {
		rail = GetRail(pathID);
		course = dCourseFull_c::instance->get(GetAreaNum());
		currentNode = &course->railNode[rail->startNode + currentNodeNum];
		nextNode = &course->railNode[rail->startNode + 1 + currentNodeNum];
		OSReport("pathID: %d\n", pathID);
		OSReport("startNode: %d\n", currentNodeNum);
		OSReport("N1.x: %d, N1.y: %d, N2.x: %d, N2.y: %d\n", currentNode->xPos, currentNode->yPos, nextNode->xPos, nextNode->yPos);
		//OSReport("Ballon: %f, %f\n", this->pos.x, this->pos.y);
		this->pos.x = currentNode->xPos;
		this->pos.y = -currentNode->yPos;
		//OSReport("Ballon: %f, %f\n", this->pos.x, this->pos.y);
		OSReport("HI 0.1\n");
	}
	else {
		OSReport("HI 0.2\n");
	}



	// Stuff I do understand
	this->scale = (Vec){ 1, 1, 1 };

	this->rot.x = 0;
	this->rot.y = 0x4000;
	this->rot.y *= -1;
	this->rot.z = 0;

	this->pos.z = 4000;

	bindAnimChr_and_setUpdateRate("YB_Rwait", 1, 0.0, 1.0);

	OSReport("HI 0.3\n");

	doStateChange(&StateID_Wait);

	OSReport("HI 0.4\n");

	this->onExecute();
	return true;
}


int daEnBoshi_c::onDelete() {
	return true;
}

int daEnBoshi_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnBoshi_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnBoshi_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();
	acState.execute();

	OSReport("HI 6\n");

	if (this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	return true;
}
//
// processed\../src/cloudPlattform.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "boomeranghax.h"
#include "path.h"

const char* CloudPlattformFileList[] = { "cloudM", 0 };


class daEnCloudPlattform_c : public dEnPath_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();


	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;

	m3d::mdl_c bodyModel;

	int alreadyOnTop;

	float XSpeed;
	bool canI;
	u32 cmgr_returnValue;
	bool isOnTopOfTile;
	bool active;
	u16 timer;

	StandOnTopCollider sotCollider;


	/*u8 moveDirection;
	float aTestFloat;
	s16 leftRotPtr;
	s16 rightRotPtr;

	dCourse_c* course;
	dCourse_c::rail_s* rail;
	dCourse_c::railNode_s* currentNode;
	dCourse_c::railNode_s* nextNode;
	int currentNodeNum;
	int steps;
	int speed;
	float moveX, moveY;

	bool done;


	bool followPath;
	bool loop;
	int pathID;


	float dx;
	float dy;

	int distance;

	float ux;
	float uy;

	Vec stepVector;

	int stepCount;
	int stepsDone;

	bool playerCollides;*/


	static dActor_c* build();

	void updateModelMatrices();

	void spriteCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	/*USING_STATES(daEnCloudPlattform_c);

	DECLARE_STATE(Wait);
	DECLARE_STATE(Run);*/
};


//CREATE_STATE(daEnCloudPlattform_c, Wait);
//CREATE_STATE(daEnCloudPlattform_c, Run);


/*void daEnCloudPlattform_c::beginState_Wait() { OSReport("HI 0.7 \n");}
void daEnCloudPlattform_c::executeState_Wait() {
	if (stepsDone == 0 && followPath)
	{
		dStageActor_c* player = (dStageActor_c*)FindActorByType(PLAYER, 0);

		OSReport("HI 1\n");

		this->pos.x = currentNode->xPos;
		this->pos.y = (-currentNode->yPos);

		if (!loop)
		{
			if (playerCollides && player->pos.y > this->pos.y && player->speed.y <= 0)
			{
				OSReport("HI 2\n");
				doStateChange(&StateID_Run);
			}
		}
		else
		{
			doStateChange(&StateID_Run);
		}
	}
}
void daEnCloudPlattform_c::endState_Wait() { OSReport("HI 2.3\n"); }


void daEnCloudPlattform_c::beginState_Run()
{
	OSReport("HI 2.7\n");
}
void daEnCloudPlattform_c::executeState_Run() {
	OSReport("HI 3\n");

	if (stepsDone == stepCount)
	{
		currentNodeNum++;
		currentNode = nextNode;
		nextNode = &course->railNode[rail->startNode + 1 + currentNodeNum];

		OSReport("RailNodeCount: %daaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, CNN: %d\n", rail->nodeCount, currentNodeNum);

		if (rail->nodeCount == currentNodeNum + 1)
		{
			if (!loop)
			{
				doStateChange(&StateID_Wait);
			}
			else
			{
				int nextNodeNum = this->settings >> 8 & 0b11111111;

				nextNode = &course->railNode[rail->startNode + nextNodeNum];


				dx = nextNode->xPos - currentNode->xPos;
				dy = (-nextNode->yPos) - (-currentNode->yPos);

				distance = sqrtf(pow(dx, 2) + pow(dy, 2));

				ux = (dx / sqrtf((dx * dx) + (dy * dy)));
				uy = (dy / sqrtf((dx * dx) + (dy * dy)));

				stepVector.x = ux * speed;
				stepVector.y = uy * speed;

				stepCount = floor(distance / speed);

				stepsDone = 0;

				this->pos.x = currentNode->xPos;
				this->pos.y = (-currentNode->yPos);
			}
		}
		else if (rail->nodeCount < currentNodeNum + 1)
		{
			currentNodeNum = this->settings >> 8 & 0b11111111;
			currentNode = &course->railNode[rail->startNode + currentNodeNum];
			nextNode = &course->railNode[rail->startNode + 1 + currentNodeNum];


			dx = nextNode->xPos - currentNode->xPos;
			dy = (-nextNode->yPos) - (-currentNode->yPos);

			distance = sqrtf(pow(dx, 2) + pow(dy, 2));

			ux = (dx / sqrtf((dx * dx) + (dy * dy)));
			uy = (dy / sqrtf((dx * dx) + (dy * dy)));

			stepVector.x = ux * speed;
			stepVector.y = uy * speed;

			stepCount = floor(distance / speed);

			stepsDone = 0;

			this->pos.x = currentNode->xPos;
			this->pos.y = (-currentNode->yPos);
		}
		else
		{
			dx = nextNode->xPos - currentNode->xPos;
			dy = (-nextNode->yPos) - (-currentNode->yPos);

			distance = sqrtf(pow(dx, 2) + pow(dy, 2));

			ux = (dx / sqrtf((dx * dx) + (dy * dy)));
			uy = (dy / sqrtf((dx * dx) + (dy * dy)));

			stepVector.x = ux * speed;
			stepVector.y = uy * speed;

			stepCount = floor(distance / speed);

			stepsDone = 0;

			this->pos.x = currentNode->xPos;
			this->pos.y = (-currentNode->yPos);
		}
	}
	else
	{
		stepsDone++;

		this->pos.x += stepVector.x;
		this->pos.y += stepVector.y;
	}
}

void daEnCloudPlattform_c::endState_Run() { OSReport("HI 5.3\n"); }*/




const SpriteData CloudPlattformSpriteData = { ProfileId::CloudPlattform, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile CloudPlattformProfile(&daEnCloudPlattform_c::build, SpriteId::CloudPlattform, CloudPlattformSpriteData, ProfileId::CloudPlattform, ProfileId::CloudPlattform, "CloudPlattform", CloudPlattformFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnCloudPlattform_c::spriteCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	if (this->active == true)
	{
		this->active = false;
	}
}
void daEnCloudPlattform_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	daPlBase_c* player = (daPlBase_c*)apOther->owner;

	OSReport("PLLLAYERUP %d\n", CheckExistingPowerup(player));

	if (this->active == true && CheckExistingPowerup(player) != 13 && CheckExistingPowerup(player) != 3)
	{
		this->active = false;
	}

	playerCollides = true;
}
void daEnCloudPlattform_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	daPlBase_c* player = (daPlBase_c*)apOther->owner;

	if (this->active == true && CheckExistingPowerup(player) != 13 && CheckExistingPowerup(player) != 3)
	{
		this->active = false;
	}

	playerCollides = true;
}
bool daEnCloudPlattform_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	daPlBase_c* player = (daPlBase_c*)apOther->owner;

	if (this->active == true)
	{
		this->active = false;
	}
	return false;
}
bool daEnCloudPlattform_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	daPlBase_c* player = (daPlBase_c*)apOther->owner;

	if (this->active == true)
	{
		this->active = false;
	}
	return false;
}
bool daEnCloudPlattform_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnCloudPlattform_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnCloudPlattform_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnCloudPlattform_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnCloudPlattform_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnCloudPlattform_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnCloudPlattform_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daEnCloudPlattform_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daEnCloudPlattform_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnCloudPlattform_c));
	daEnCloudPlattform_c* c = new(buffer) daEnCloudPlattform_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

int daEnCloudPlattform_c::onCreate() {
	this->alreadyOnTop = 0;
	this->canI = false;
	OSReport("daCloudPlattform_c::onCreate()!!!\n");

	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("cloudM", "g3d/power_cloud.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("spincloud");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_MapObj(&bodyModel, 0);

	allocator.unlink();

	/*this->followPath = this->settings >> 31 & 1;

	this->loop = this->settings >> 30 & 1;

	this->aTestFloat = 0.25f;

	done = false;

	speed = this->settings >> 16 & 0b1111;						    //Bit 29-32
	currentNodeNum = this->settings >> 8 & 0b11111111;						//Bit 33-40
	int pathID = this->settings >> 0 & 0b11111111;                               //Bit 41-48
	OSReport("speed: %d, currentNodeNum: %d, pathID: %d\n", speed, currentNodeNum, pathID);
	if (pathID) {
		rail = GetRail(pathID);
		course = dCourseFull_c::instance->get(GetAreaNum());
		currentNode = &course->railNode[rail->startNode + currentNodeNum];
		nextNode = &course->railNode[rail->startNode + 1 + currentNodeNum];


		dx = nextNode->xPos - currentNode->xPos;
		dy = (-nextNode->yPos) - (-currentNode->yPos);

		distance = sqrtf(pow(dx, 2) + pow(dy, 2));

		ux = (dx / sqrtf((dx * dx) + (dy * dy)));
		uy = (dy / sqrtf((dx * dx) + (dy * dy)));

		stepVector.x = ux * speed;
		stepVector.y = uy * speed;

		stepCount = floor(distance / speed);

		stepsDone = 0;


		OSReport("pathID: %d\n", pathID);
		OSReport("startNode: %d\n", currentNodeNum);
		OSReport("N1.x: %d, N1.y: %d, N2.x: %d, N2.y: %d\n", currentNode->xPos, currentNode->yPos, nextNode->xPos, nextNode->yPos);
		//OSReport("Ballon: %f, %f\n", this->pos.x, this->pos.y);
		this->pos.x = currentNode->xPos;
		this->pos.y = -currentNode->yPos;
		//OSReport("Ballon: %f, %f\n", this->pos.x, this->pos.y);
		OSReport("HI 0.1\n");
	}
	else {
		OSReport("HI 0.2\n");
	}


	playerCollides = false;*/


	// Stuff I do understand
	this->scale = (Vec){1.2, 1.2, 1.2};
	// this->scale = (Vec){ 0.0, 0.0, 0.0 };

	this->rot.x = 0;
	this->rot.y = 0;
	this->rot.z = 0;
	//this->direction = (this->settings >> 8) & 0xF; // Heading where the player look.


	float fWidth = 3 * 16.0f;
	sotCollider.init(this,
		/*xOffset=*/-23.0f, /*yOffset=*/7.0f,
		/*topYOffset=*/0,
		/*rightSize=*/fWidth, /*leftSize=*/0,
		/*rotation=*/0, /*_45=*/1
	);

	// What is this for. I dunno
	sotCollider._47 = 0xA;
	sotCollider.flags = 0x80180 | 0xC00;

	sotCollider.addToList();


	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 8.0;

	HitMeBaby.xDistToEdge = 24;
	HitMeBaby.yDistToEdge = 1;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	this->pos.y += 16;
	this->pos.z = 4000;

	this->active = true;
	this->timer = 0;

	doStateChange(&StateID_Init);

	this->onExecute();
	return true;
}


int daEnCloudPlattform_c::onDelete() {
	this->Delete(1);
	return true;
}

int daEnCloudPlattform_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnCloudPlattform_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


int daEnCloudPlattform_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();
	acState.execute();

	//OSReport("Execute\n");

	if (!active)
	{
		timer += 1;
		if (timer == 1)
		{
			float fWidth = 0;
			sotCollider.init(this,
				/*xOffset=*/-23.0f, /*yOffset=*/7.0f,
				/*topYOffset=*/0,
				/*rightSize=*/fWidth, /*leftSize=*/0,
				/*rotation=*/0, /*_45=*/1
			);

			// What is this for. I dunno
			sotCollider._47 = 0xA;
			sotCollider.flags = 0x80180 | 0xC00;

			sotCollider.addToList();
		}
		if (timer < 25)
		{
			this->scale.x -= 0.05;
			this->scale.y -= 0.05;
			this->scale.z -= 0.05;
		}
		if (timer == 25)
		{
			this->scale.x = 0;
			this->scale.y = 0;
			this->scale.z = 0;
		}
		if (timer > 104)
		{
			this->scale.x += 0.05;
			this->scale.y += 0.05;
			this->scale.z += 0.05;
		}
		if (timer == 128)
		{
			this->scale.x = 1.2;
			this->scale.y = 1.2;
			this->scale.z = 1.2;

			float fWidth = 3 * 16.0f;
			sotCollider.init(this,
				/*xOffset=*/-23.0f, /*yOffset=*/7.0f,
				/*topYOffset=*/0,
				/*rightSize=*/fWidth, /*leftSize=*/0,
				/*rotation=*/0, /*_45=*/1
			);

			// What is this for. I dunno
			sotCollider._47 = 0xA;
			sotCollider.flags = 0x80180 | 0xC00;

			sotCollider.addToList();

			timer = 0;
			active = true;
		}
	}

	/*OSReport("speed: %d, followPath: %d, pathID: %d, currentNodeNum: %d, loop: %d, posxy: %f|%f\n", this->speed, this->followPath, this->pathID, this->currentNodeNum, this->loop, this->pos.x, this->pos.y);

	if (this->followPath)
	{
		OSReport("FollowsPath\n");
		if (!done)
		{
			OSReport("NotDone\n");

			float dx = nextNode->xPos - currentNode->xPos;
			float dy = (-nextNode->yPos) - (-currentNode->yPos);

			float ux = (dx / sqrtf((dx * dx) + (dy * dy)));
			float uy = (dy / sqrtf((dx * dx) + (dy * dy)));

			this->pos.y += uy * speed;
			this->pos.x += ux * speed;

			if (dx <= 0)
			{
				//this->rot.y = 0x4000;
				//this->rot.y *= -1;
			}
			else
			{
				//this->rot.y = 0x4000;
			}

			OSReport("x: %f; y: %f\n", this->pos.x, this->pos.y);
			OSReport("nx: %f; ny: %f\n", nextNode->xPos, -nextNode->yPos);
			OSReport("dx: %f; dy: %f\n", dx, dy);
			OSReport("ux: %f; uy: %f\n", ux, uy);

			if (this->pos.x > dx + currentNode->xPos - 4 && this->pos.x < dx + currentNode->xPos + 4 && this->pos.y > dy - currentNode->yPos - 4 && this->pos.y < dy - currentNode->yPos + 4)
			{
				done = true;
			}
		}
		else
		{
			OSReport("nodecount: %d, currentnodenum: %d\n", rail->nodeCount, currentNodeNum);
			//if (rail->nodeCount > currentNodeNum + 1)
			//{
				currentNodeNum++;
				currentNode = nextNode;
				nextNode = &course->railNode[rail->startNode + 1 + currentNodeNum];
				this->pos.x = currentNode->xPos;
				this->pos.y = -currentNode->yPos;
			//}

			if (rail->nodeCount != currentNodeNum + 1)
			{
				done = false;
			}
		}
	}*/

	//playerCollides = false;

	sotCollider.update();
	return true;
}
//
// processed\../src/goombaTower.cpp
//

extern "C" bool daEnKuriboBase_c__isFrozen(int);

#include <common.h>
#include <game.h>
#include <profile.h>

const char* GoombaTowerFileList[] = { "kuribo", 0 };


class daEnGoombaTower_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	static dActor_c* build();

	dStageActor_c* goombas[16];
	int goombasDirection[16];

	u8 stackSize;

	int goombaTurn;
	dStateBase_c* turnstate;

	bool starting;
};

const SpriteData GoombaTowerSpriteData = { ProfileId::GoombaTower, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile GoombaTowerProfile(&daEnGoombaTower_c::build, SpriteId::GoombaTower, GoombaTowerSpriteData, ProfileId::GoombaTower, ProfileId::GoombaTower, "GoombaTower", GoombaTowerFileList);

dActor_c* daEnGoombaTower_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnGoombaTower_c));
	daEnGoombaTower_c* c = new(buffer) daEnGoombaTower_c;

	return c;
}

int daEnGoombaTower_c::onCreate() {

	this->stackSize = (this->settings >> 12 & 0xF) + 1;

	this->starting = true;

	this->onExecute();
	return true;
}


int daEnGoombaTower_c::onDelete() {
	return true;
}

int daEnGoombaTower_c::onDraw() {
	return true;
}

extern dStateBase_c StateID_Turn__Goomba;
extern dStateBase_c StateID_Ice__Goomba;
extern dStateBase_c StateID_DieFall__Goomba;
extern dStateBase_c StateID_DieOther__Goomba;
extern dStateBase_c StateID_Walk__Goomba;

int daEnGoombaTower_c::onExecute() {

	//OSReport("Goomba 0 x,y,z: %f, %f, %f\n", this->goombas[0]->pos.x, this->goombas[0]->pos.y, this->goombas[0]->pos.z);

	OSReport("Goomba alive: %d, %d, %d, %d, %d, %d, %d, %d\n", goombas[0], goombas[1], goombas[2], goombas[3], goombas[4], goombas[5], goombas[6], goombas[7]);
	//OSReport("Goomba state: %d, %d, %d, %d, %d, %d, %d, %d\n", goombas[0]->acState.getCurrentState()->getName(), goombas[1]->acState.getCurrentState()->getName(), goombas[2]->acState.getCurrentState()->getName(), goombas[3]->acState.getCurrentState()->getName(), goombas[4]->acState.getCurrentState()->getName(), goombas[5]->acState.getCurrentState()->getName(), goombas[6]->acState.getCurrentState()->getName(), goombas[7]->acState.getCurrentState()->getName());
	OSReport("Goomba rot: %f, %f, %f\n", goombas[3]->rot.x, goombas[3]->rot.y, goombas[3]->rot.z);

	dStageActor_c* player = (dStageActor_c*)FindActorByType(PLAYER, 0);

	OSReport("StackSize: %d\n", this->stackSize);

	OSReport("111111111111111\n");

	if (this->starting) //&& player->pos.x >= this->pos.x - 128 && player->pos.x <= this->pos.x + 128)
	{
		OSReport("222222222222222222222222222222222\n");
		Vec3 goombaPos;
		OSReport("2.55555555555555555555555\n");
		for (int i = 0; i < this->stackSize; i++)
		{
			OSReport("333333333333333333333333333333333\n");
			if (this->goombas[i] == 0)
			{
				OSReport("4444444444444444444444\n");
				for (int j = i + 1; j < this->stackSize; j++)
				{
					OSReport("5555555555555555555555555555555555\n");
					this->goombas[j - 1] = this->goombas[j];
				}
			}
			OSReport("2266666666666666666666666666666662\n");
			goombaPos.x = this->pos.x;
			OSReport("2222777777777777777777777777777777\n");
			goombaPos.y = this->pos.y + (16 * i);
			OSReport("28888888888888888888888888888888888888\n");
			goombaPos.z = this->pos.z;
			OSReport("2229999999999999999999999999999999992\n");
			this->goombas[i] = (dStageActor_c*)CreateActor(51, 0, goombaPos, 0, 0);
			OSReport("222221010110101010101010101010\n");
		}
		starting = false;

		goombaTurn = goombas[0]->direction;
	
		u8 nulloombas = 0;
		for (int i = 1; i < this->stackSize; i++)
		{
			if (this->goombas[i])
			{
				nulloombas += 1;
			}
			else
			{
				this->goombas[i]->pos.x = this->goombas[0]->pos.x;
				this->goombas[i]->pos.y = this->goombas[0]->pos.y + (17 * (i - nulloombas));
				this->goombas[i]->pos.z = this->goombas[0]->pos.z - (500 * (i - nulloombas));

				this->goombas[i]->speed.x = this->goombas[0]->speed.x;
				this->goombas[i]->speed.y = this->goombas[0]->speed.y;
				this->goombas[i]->speed.z = this->goombas[0]->speed.z;

				this->goombas[i]->direction = this->goombas[0]->direction;
				this->goombasDirection[i] = this->goombas[i]->direction;
			}
		}
	}

	if (!starting)
	{
		bool hasAlreadyTurned = false;
		for (int i = 0; i < this->stackSize; i++)
		{
			OSReport("1 Goomba %d: %f, %f, %d \n", i, this->goombas[i]->rot.x, this->goombas[i]->rot.y, this->goombas[i]->direction);

			turnstate = ((dEn_c*)this->goombas[i])->acState.getCurrentState();

			if (turnstate == &StateID_DieFall__Goomba || turnstate == &StateID_DieOther__Goomba || turnstate == &StateID_Ice__Goomba)
			{
				this->goombas[i] = 0;

				/* OSReport("2 Goomba %d: %f, %f \n", i, this->goombas[i]->rot.x, this->goombas[i]->rot.y);
				this->goombas[i]->scale.x = 0;
				this->goombas[i]->scale.y = 0;
				this->goombas[i]->scale.z = 0;

				OSReport("3 Goomba %d: %f, %f \n", i, this->goombas[i]->rot.x, this->goombas[i]->rot.y);

				dStageActor_c* goombaTemp = this->goombas[i];

				OSReport("4 Goomba %d: %f, %f \n", i, this->goombas[i]->rot.x, this->goombas[i]->rot.y);

				for (int j = i + 1; j <= this->stackSize; j++)
				{
					OSReport("5 Goomba %d, %d: %f, %f \n", i, j, this->goombas[i]->rot.x, this->goombas[i]->rot.y);

					if (this->goombas[j]->scale.x == 0 || j == this->stackSize)
					{
						OSReport("6 Goomba %d, %d: %f, %f \n", i, j, this->goombas[i]->rot.x, this->goombas[i]->rot.y);
						this->goombas[j - 1] = goombaTemp;
					}
					else
					{
						OSReport("7 Goomba %d, %d: %f, %f \n", i, j, this->goombas[i]->rot.x, this->goombas[i]->rot.y);
						this->goombas[j - 1] = this->goombas[j];
					}
				} */
			}
			else if(!hasAlreadyTurned)
			{
				bool wall = this->goombas[i]->collMgr.calculateAdjacentCollision(0);

				OSReport("Pi Goomba %d: %d \n", i, wall);

				if (wall)
				{
					hasAlreadyTurned = true;

					((dEn_c*)this->goombas[0])->doStateChange((dStateBase_c*)&StateID_Turn__Goomba);

					//this->goombas[0]->direction *= -1;
				}
			}
		}


		u8 nulloombas = 0;
		for (int i = 0; i < this->stackSize; i++)     //i auf 0 gendert
		{
			if (this->goombas[i] == 0)
			{
				nulloombas += 1;
			}
			else
			{
				this->goombas[i]->pos.x = this->goombas[0]->pos.x;
				this->goombas[i]->pos.y = this->goombas[0]->pos.y + (17 * (i - nulloombas));
				this->goombas[i]->pos.z = this->goombas[0]->pos.z - (500 * (i - nulloombas));

				this->goombas[i]->speed.x = this->goombas[0]->speed.x;
				this->goombas[i]->speed.y = this->goombas[0]->speed.y;
				this->goombas[i]->speed.z = this->goombas[0]->speed.z;

				this->goombas[i]->direction = this->goombas[0]->direction;

				/*if (this->goombasDirection[i] != this->goombas[i]->direction)
				{
					for (int j = 0; i < this->stackSize; i++)
					{
						//this->goombas[j]->direction = this->goombas[i]->direction;
						//this->goombasDirection[j] = this->goombas[i]->direction;
						((dEn_c*)this->goombas[j])->acState.setState((dStateBase_c*)StateID_Turn__Goomba);
					}
				}*/
			}

			turnstate = ((dEn_c*)this->goombas[0])->acState.getCurrentState();

			//OSReport("State: %p, %p\n", turnstate, &StateID_Turn__Goomba);
			if (turnstate == &StateID_Turn__Goomba) OSReport("A Goomba Turn\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");

		}

		//if (goombas[0] != 0 && goombas[0]->direction != goombaTurn) {
			//turnstate = ((dEn_c*)this->goombas[0])->acState.getCurrentState();

			
			//OSReport("Goomba State %s: %p \n", turnstate->getName(), turnstate);
		//}


		if (goombas[0] != 0)
		{
			this->pos.x = goombas[0]->pos.x;
			this->pos.y = goombas[0]->pos.y;
			this->pos.z = goombas[0]->pos.z;

		}
		else
		{
			this->Delete(1);
		}

	}

	return true;
}
//
// processed\../src/busuBusu.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "path.h"

const char* BusuBusuFileList[] = { "busuBusu", 0 };


class daEnBusuBusu_c : public dEnPath_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile resFileAnim;
	m3d::mdl_c bodyModel;

	m3d::anmChr_c chrAnimation;

	bool leftRight;

	bool facingRight;
	u8 wSpeed;
	u8 wDistance;

	int stepCount;

	static dActor_c* build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	//bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);

	//setDeathInfo_IceBreak -> what should be done when in an iceblock and crashes a wall -> normally the sprite should die
	void _vf148();
	//setDeathInfo_IceVanish -> what should be done when collision with an iceblock thrown by Mario -> normally the sprite should die
	void _vf14C();
	//create an ice block when collided with Iceball
	bool CreateIceActors();

	//void addScoreWhenHit(void* other);
};

const SpriteData BusuBusuSpriteData = { ProfileId::BusuBusu, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile BusuBusuProfile(&daEnBusuBusu_c::build, SpriteId::BusuBusu, BusuBusuSpriteData, ProfileId::BusuBusu, ProfileId::BusuBusu, "BusuBusu", BusuBusuFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnBusuBusu_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	DamagePlayer(this, apThis, apOther);
}
void daEnBusuBusu_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
}
bool daEnBusuBusu_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnBusuBusu_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnBusuBusu_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnBusuBusu_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	if ((this->facingRight && apOther->owner->pos.x < this->pos.x) || (!this->facingRight && apOther->owner->pos.x > this->pos.x))
	{
		this->Delete(1);
		return true;
	}
	return false;
}

bool daEnBusuBusu_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
/*bool daEnBusuBusu_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}*/
bool daEnBusuBusu_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daEnBusuBusu_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnBusuBusu_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}

bool daEnBusuBusu_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}


void daEnBusuBusu_c::_vf148() {
	dEn_c::_vf148();
}

void daEnBusuBusu_c::_vf14C() {
	dEn_c::_vf14C();
}

//this does weird shit, but it creates the iceblock around it
bool daEnBusuBusu_c::CreateIceActors() {
	struct DoSomethingCool my_struct = { 0, this->pos, {1.5, 2.0, 1.8}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	this->frzMgr.Create_ICEACTORs((void*)&my_struct, 1);
	__destroy_arr((void*)&my_struct, sub_80024C20, 0x3C, 1);
	//this->chrAnimation.setCurrentFrame(0.0);
	this->chrAnimation.setUpdateRate(0.0);
	//this->frozen = true;
	return true;
}


dActor_c* daEnBusuBusu_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnBusuBusu_c));
	daEnBusuBusu_c* c = new(buffer) daEnBusuBusu_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

void daEnBusuBusu_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate)
{
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daEnBusuBusu_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("busuBusu", "g3d/busuBusu.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("BusuBusu");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	this->resFileAnim.data = getResource("busuBusu", "g3d/busuBusuAnim.brres");
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr("fly");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	this->leftRight = settings >> 31 & 1;

	this->facingRight = settings >> 30 & 1;
	this->wDistance = settings >> 20 & 0b11111111;
	this->wSpeed = settings >> 16 & 0b1111;

	//OSReport("fr: %d, wD: %d, wS: %d\n", this->facingRight, this->wDistance, this->wSpeed);


	// Stuff I do understand
	this->scale = (Vec){ 0.1, 0.1, 0.1 };

	this->rot.x = 0;
	if (facingRight)
	{
		this->rot.y = 0x4000;
	}
	else
	{
		this->rot.y = 0x4000;
		this->rot.y *= -1;
	}
	this->rot.z = 0;

	this->pos.z = 4000;


	bindAnimChr_and_setUpdateRate("fly", 1, 0.0, 1.0);

	OSReport("LeftRight: %d\n", this->leftRight);
	if(this->leftRight) {
		doStateChange(&StateID_Wait);
	} else {
		beginState_Init();
		executeState_Init();
		
		if (this->stepVector.x > 0) {
			this->rot.y = 0x4000;
		}
		
		OSReport("currentNodeNum: %d\n", this->currentNodeNum);
		OSReport("pathID: %d\n", this->pathID);
		doStateChange(&StateID_FollowPath);
	}

	this->onExecute();
	return true;
}


int daEnBusuBusu_c::onDelete() {
	return true;
}

int daEnBusuBusu_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnBusuBusu_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnBusuBusu_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();

	//OSReport("fr: %d, wD: %d, wS: %d, stepCount: %d\n", this->facingRight, this->wDistance, this->wSpeed, this->stepCount);

	if(this->leftRight) {
		if (this->facingRight) {
			this->rot.y = 0x4000;

			this->pos.x += this->wSpeed;
			this->stepCount += 1;

			if ((stepCount * wSpeed) > wDistance) {
				this->facingRight = false;
				this->stepCount = 0;
			}
		} else {
			this->rot.y = 0x4000;
			this->rot.y *= -1;

			this->pos.x -= this->wSpeed;
			this->stepCount += 1;

			if ((stepCount * wSpeed) > wDistance) {
				this->facingRight = true;
				this->stepCount = 0;
			}
		}
	} else {
		acState.execute();
		if (this->stepsDone == this->stepCount) {
			if (this->rotateNext) {
				if (this->stepVector.x > 0) {
					this->rot.y = 0x4000;
				} else {
					this->rot.y = -0x4000;
				}
			}
		}
	}
	if (this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	return true;
}
//
// processed\../src/fireball.cpp
//

#include "fireball.h"


class daGoldFireBall_c : public daFireBall_Base_c {
public:
	int onCreate(); //0x80040960
	int onExecute();
	int onDelete(); //0x8011AC90

	int playerId;
	int countedTwice;
	int unk;
	int isGold;
	int isDying;
	int radius;
	int waitingTime;
	daEnBlockMain_c* dataBank;
	daEnBlockMain_c* dataBank2;

	daGoldFireBall_c(); //0x8011A5B0

	void vf138(); //0x8011A690, just a blr
	void vf13C(); //0x8011A6A0, just a blr
	void updateSpawnLimits(); //0x8011A6B0
	void setZOrder_maybe(); //0x8011A730
	void calledInOnCreate_b(); //0x8011A7C0
	void calledInOnCreate_c(); //0x8011A8F0
	void initialAdjacentCheck(); //0x8011A940
	void theFuck(); //0x8011A9F0
	void doFireSplash(); //0x8011AAB0

	void collisionCallback(ActivePhysics *one, ActivePhysics *two); //0x8011AB90

	void checkSomethingAboutSlopesAndQuicksand(); //0x8011AED0
	void querySomethingByRCollDetector(); //0x8011AF60
	void checkSomethingElseAboutCSensor(); //0x8011AFC0
	void setSpeed(); //0x8011AFD0
	void CheckFireballLimit(); //0x8011B060

	static daGoldFireBall_c *build(); //0x8011A5B0
	~daGoldFireBall_c(); //0x8011B0B0

	int onCreate_orig();
	int onExecute_orig();
	void beginState_Move_orig();
	void executeState_Move_orig();
	void endState_Move_orig();

	//void doGoldTileChange();
	void doTileThing(int tX, int tY);
	int checkForTriggerableBlock();

	USING_STATES(daGoldFireBall_c);
	DECLARE_STATE(Move);
};

daGoldFireBall_c *daGoldFireBall_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daGoldFireBall_c));

	return new(buffer) daGoldFireBall_c;
}

CREATE_STATE(daGoldFireBall_c, Move);

/*void daGoldFireBall_c::doGoldTileChange() {
	int currentX = this->pos.x;
	int currentY = this->pos.y;

	int moduloX = currentX % 16;
	int moduloY = currentY % 16;

	int tileX = ((currentX - moduloX) / 16);
	int tileY = -((currentY - moduloY) / 16);

	this->isDying = 1;
}*/

int daGoldFireBall_c::checkForTriggerableBlock() {
	int currentX = this->pos.x;
	int currentY = this->pos.y - 16;

	int moduloX = currentX % 16;
	int moduloY = currentY % 16;

	int roundedX = currentX - moduloX - 16;
	int roundedY = currentY - moduloY - 16;

	int tileX = ((currentX - moduloX) / 16);
	int tileY = ((currentY - moduloY) / 16);

	int tn = (int)(dBgGm_c::instance->getTileNumAtPositionWithoutSpecial(currentX, -currentY, 0));
	u32 tilebehaviour0 = collMgr.getTileBehaviour1At((float)(currentX), (float)(currentY), 0);

	if((tn == 0x30 || tn == 0x31) && (tilebehaviour0 == 0x10 || tilebehaviour0 == 0x5)) {
		return 1;
	}

    while (true) {
		if(dataBank != (daEnBlockMain_c*)1) {
			dataBank = (daEnBlockMain_c*) fBase_c::search(EN_OBJ_HATENA_BLOCK, dataBank);
		}
		if(dataBank2 != (daEnBlockMain_c*)1) {
			dataBank2 = (daEnBlockMain_c*) fBase_c::search(EN_OBJ_RENGA_BLOCK, dataBank2);
		}

		if(dataBank == 0) { dataBank = (daEnBlockMain_c*)1; }
		if(dataBank2 == 0) { dataBank2 = (daEnBlockMain_c*)1; }

		if (dataBank == (daEnBlockMain_c*)1 && dataBank2 == (daEnBlockMain_c*)1) {
			dataBank = 0;
			dataBank2 = 0;
			break;
		}

        if (dataBank->pos.x == roundedX && dataBank->pos.y == roundedY && dataBank->_68D == 0) {
			dataBank = 0;
			dataBank2 = 0;
            return 1;
        }
        if (dataBank2->pos.x == roundedX && dataBank2->pos.y == roundedY && dataBank2->_68D == 0) {
			dataBank = 0;
			dataBank2 = 0;
            return 1;
        }
    }  

	return 0;
}

int daGoldFireBall_c::onCreate() {
	this->isGold = 1;
	this->radius = 16;

	int orig_val = this->onCreate_orig();

	/*OSReport("Hello :p\n");
	OSReport("Sprite: %d %X\n", this->name, this->name);
	dAcPy_c::findByID(this->which_player)->addMyActivePhysics();*/

	return orig_val;
}

int uh5[] = {-64, -48, -32, -16, 0, 16, 32, 48, 64};
int questionIDs[] = {2, 0, 1, 2, 0xA, 0xD, 0x19, 0x15, 0x11, 0x18, 0xE};
int brickIDs[] = {0x20, 0x22, 0x22, 0x20, 0x21, 0x27, 0x2A, 0x39, 0x35, 0x31, 0x2C, 0x2E};

extern "C" u32 getBlockTypeFromTilenum(void* actor, u32 tilenum);
extern u8 returnByteAtPointer(u32 pointer, u32 fromHowMuch);

void daGoldFireBall_c::doTileThing(int tX, int tY) {
	/*u32 tilebehaviour = collMgr.getTileBehaviour1At((float)(tileX + uh5[j]), (float)(tileY + uh5[i]), currentLayerID);
	u32 tilebehaviour2 = collMgr.getTileBehaviour2At((float)(tileX + uh5[j]), (float)(tileY + uh5[i]), currentLayerID);
	OSReport("tilebehaviour=%8X %8X\n", tilebehaviour, tilebehaviour2);
	if(tilebehaviour == 0x00000010) {
		dBgGm_c::instance->placeTile(tileX + uh5[j], -tileY + uh5[i] + 32, currentLayerID, 0);
		Vec coinPos = (Vec){tileX + uh5[j], tileY + uh5[i], this->pos.z};
		CreateActor(401, 0, coinPos, 0, 0);
	}*/
	int ttX = tX / 16;
	int ttY = tY / 16;

	u32 tilebehaviour0 = collMgr.getTileBehaviour1At((float)(tX), (float)(tY), 0);
	//u32 tilebehaviour2 = collMgr.getTileBehaviour2At((float)(tX), (float)(tY), 0);
	int tng = (int)(dBgGm_c::instance->getTileNumAtPosition(tX, -tY, 0, 1));
	int tn = tng & 0xFF;
	int tv = (tng >> 8) / 4;
	//u32 bt = getBlockTypeFromTilenum(this, tn);
	//u64 bh = dBgGm_c::instance->getBehaviourForTileNum(tn);
	//u64 tb = dBgGm_c::instance->getTileBit(tX, -tY, 0);
	//u64 tb2 = dBgGm_c::instance->getTileBit(tX, tY, 0);
	//u32 pt = dBgGm_c::instance->getPointerToTile2(tX, -tY, 0);
	//u32 vv = *((unsigned int*)((u32)pt+0x7));
	//u32 newptr = pt+0x2;
	//u32 moduloptr = newptr % 4;
	//newptr = newptr - moduloptr;
	//u8 vv = returnByteAtPointer(newptr, moduloptr);
	u32 ci = dBgGm_c::instance->getCollisionInfo(tX, -tY, 0);
	u32 ci2 = dBgGm_c::instance->getCollisionInfo(tX, tY, 0);

	if(tn == 0x30 || tn == 0x31) {
		if(tilebehaviour0 == 0x10 || tilebehaviour0 == 0x5) {
			/*//OSReport("tilebehaviour=%X-%X-%d-%d-%X-%X-%X at %d %d\n", tilebehaviour0, tilebehaviour2, tn, bt, bh, tb, tb2, tX, tY);
			OSReport("tilebehaviour=%X-", tilebehaviour0);
			OSReport("%X-%X-", tn, tv);
			//OSReport("%d-%X-", bt, bh);
			//OSReport("%X-%X-", tb, tb2);
			//OSReport("%X-%X-%X-", pt, newptr, vv);
			OSReport("%X-%X ", ci, ci2);
			OSReport("at %d %d ", tX, tY);
			OSReport("/ %d %d\n", ttX, ttY);*/

			dBgGm_c::instance->placeTile(tX, -tY, currentLayerID, 0);
			if(tilebehaviour0 & 0x10 && tv == 0) {
				Vec coinPos = (Vec){tX, tY, this->pos.z};
				CreateActor(401, 0, coinPos, 0, 0); //EN_COIN
			}
			else {
				Vec blockPos = (Vec){tX, tY, this->pos.z};
				int idx = ((tilebehaviour0 & 0x10) ? brickIDs[tv] : questionIDs[tv]);
				int blockSettings = 0x01080000 | (this->which_player << 16) | idx;
				//OSReport("Spawning with settings %X (%X)\n", blockSettings, idx);
				CreateActor(59, blockSettings, blockPos, 0, 0); //EN_BLOCK
			}
		}
	}
}

int daGoldFireBall_c::onExecute() {
	int orig_val = this->onExecute_orig();

	if(this->isDying) {
		//OSReport("isDying\n");
		int i = 0;

		int curx = this->pos.x;
		int cury = this->pos.y;

		int tileX = (this->pos.x - (curx % 16));
		int tileY = (this->pos.y - (cury % 16));
		if(this->radius == 16) {
			for(int i = 3; i < 6; i++) {
				for(int j = 3; j < 6; j++) {
					doTileThing(tileX + uh5[j], tileY + uh5[i]);
				}
			}
			Vec effScale = {0.2f, 0.2f, 0.2f};
			SpawnEffect("Wm_ob_powgold_ind", 0, &this->pos, 0, &effScale);
		}
		if(this->radius == 32) {
			for(int i = 1; i < 7; i++) {
				for(int j = 1; j < 7; j++) {
					if((i == 1 || i == 7) && (j == 1 || j == 2 || j == 6 || j == 7)) {
						continue;
					}
					if((i == 1 || i == 2 || i == 6 || i == 7) && (j == 1 || j == 7)) {
						continue;
					}
					doTileThing(tileX + uh5[j], tileY + uh5[i]);
				}
			}
		}
		if(this->radius == 48) {
			for(int i = 0; i < 8; i++) {
				for(int j = 0; j < 8; j++) {
					if((i == 0 || i == 8) && (j == 0 || j == 1 || j == 7 || j == 8)) {
						continue;
					}
					if((i == 0 || i == 1 || i == 7 || i == 8) && (j == 0 || j == 8)) {
						continue;
					}
					doTileThing(tileX + uh5[j], tileY + uh5[i]);
				}
			}
		}

		while(this->radius <= 64 && this->waitingTime == 0) {
			if(dataBank != (daEnBlockMain_c*)1) {
				dataBank = (daEnBlockMain_c*) fBase_c::search(EN_OBJ_HATENA_BLOCK, dataBank);
			}
			if(dataBank2 != (daEnBlockMain_c*)1) {
				dataBank2 = (daEnBlockMain_c*) fBase_c::search(EN_OBJ_RENGA_BLOCK, dataBank2);
			}

			if(dataBank == 0) { dataBank = (daEnBlockMain_c*)1; }
			if(dataBank2 == 0) { dataBank2 = (daEnBlockMain_c*)1; }

			if (dataBank == (daEnBlockMain_c*)1 && dataBank2 == (daEnBlockMain_c*)1) {
				this->radius += 16;
				this->waitingTime = 5;
				dataBank = 0;
				dataBank2 = 0;
			}

			if((((dataBank->pos.x-this->pos.x) * (dataBank->pos.x-this->pos.x)) + ((dataBank->pos.y-this->pos.y) * (dataBank->pos.y-this->pos.y))) < (this->radius * this->radius)) //(x-center_x)^2 + (y - center_y)^2 < radius^2
			{
				dataBank->_67F = 1;
			}
			if((((dataBank2->pos.x-this->pos.x) * (dataBank2->pos.x-this->pos.x)) + ((dataBank2->pos.y-this->pos.y) * (dataBank2->pos.y-this->pos.y))) < (this->radius * this->radius)) //(x-center_x)^2 + (y - center_y)^2 < radius^2
			{
				if(dataBank2->settings & 0xF != 0) {
					dataBank2->_67F = 1;
				}
				else {
					//dBgGm_c::instance->placeTile(dataBank2->pos.x - 8, -dataBank2->pos.y - 16.0f, currentLayerID, 0x801E); //Coin Tile
					Vec coinPos = (Vec){dataBank2->pos.x - 8, dataBank2->pos.y + 16, dataBank2->pos.z};
					CreateActor(401, 0, coinPos, 0, 0); //EN_COIN=401=147
					dataBank2->Delete(1);
				}
			}

			//OSReport("i = %d; dataBank = %d; dataBank2 = %d\n", i, dataBank, dataBank2);
			i++;
		}

		if(this->radius > 64 && this->waitingTime < -1) {
			this->Delete(1);
		}
		this->waitingTime--;
	}

	return orig_val;
}



void daGoldFireBall_c::beginState_Move() { 
	this->beginState_Move_orig();
}

void daGoldFireBall_c::endState_Move() { 
	this->executeState_Move_orig();
}

void daGoldFireBall_c::executeState_Move() { 
	this->endState_Move_orig();
}
//
// processed\../src/newSfx.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>

const char* SoundEffects[] = {
	"sfx/GoldFlower_hit",			//2000
	"sfx/GoldFlower_out",			//2001
	"sfx/GoldFlower_get",			//2002
	"sfx/GoldFlower_throw",			//2003
	"sfx/GoldFlower_get",			//2004
	"sfx/FlipPanel"					//2005
};

extern "C" void PlaySoundWithFunctionB4(void *spc, nw4r::snd::SoundHandle *handle, int id, int unk);
static nw4r::snd::StrmSoundHandle handlee;

u8 hijackMusicWithSongName(const char *songName, int themeID, bool hasFast, int channelCount, int trackCount, int *wantRealStreamID, bool doTheResetThing);

int NewSFXPlayer(int id, bool withFunctionB4 = false) {
	if (handlee.Exists())
		handlee.Stop(0);

	int sID;
	hijackMusicWithSongName(SoundEffects[id], -1, false, 2, 1, &sID, true);
	OSReport("sID: %d\n", sID);
	if(withFunctionB4) PlaySoundWithFunctionB4(SoundRelatedClass, &handlee, sID, 1);
	return sID;
}

void newPlaySoundFromPosition(SoundPlayingClass *pointer, int ID, Vec2 *pos, u32 flags) {
	int sID = NewSFXPlayer(ID - 2000);
	pointer->PlaySoundAtPosition(sID, pos, flags);
}

void newPlaySoundFromPosition2(SoundPlayingClass *pointer, int ID, u32 dunno, u32 *handle) {
	int sID = NewSFXPlayer(ID - 2000);
	pointer->PlaySoundForSoundPlayingClass(sID, dunno, handle);
}
//
// processed\../src/poihana.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>


const char* PoihanaFileList [] = { "cataquack", NULL };

void shyCollisionCallback(ActivePhysics *apThis, ActivePhysics *apOther);
void ChuckleAndKnuckles(ActivePhysics *apThis, ActivePhysics *apOther);

class daPoihana_c : public dEn_c {
public:
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;

	m3d::mdl_c bodyModel;

	m3d::anmChr_c chrAnimation;

	mEf::es2 effect;

	int timer;
	int jumpCounter;
	float dying;
	float Baseline;
	char damage;
	char isDown;
	int distance;
	float XSpeed;
	u32 cmgr_returnValue;
	bool isBouncing;
	char backFire;
	int directionStore;
	bool stillFalling;

	StandOnTopCollider giantRider;
	ActivePhysics Chuckle;
	ActivePhysics Knuckles;

	static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();
	bool calculateTileCollisions();

	void spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);

	//void bouncePlayerWhenJumpedOn(void *player);
	
	void _vf148();
	void _vf14C();
	bool CreateIceActors();

	bool willWalkOntoSuitableGround();

	USING_STATES(daPoihana_c);
	DECLARE_STATE(RealWalk);
	DECLARE_STATE(RealTurn);

	DECLARE_STATE(GoDizzy);
	DECLARE_STATE(FireKnockBack);
	DECLARE_STATE(FlameHit);
	DECLARE_STATE(Recover);

	DECLARE_STATE(Die);

	int type;
};

dActor_c *daPoihana_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daPoihana_c));
	return new(buffer) daPoihana_c;
}

const SpriteData PoihanaSpriteData = { ProfileId::Poihana, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile PoihanaProfile(&daPoihana_c::build, SpriteId::Poihana, PoihanaSpriteData, ProfileId::Poihana, ProfileId::Poihana, "Poihana", PoihanaFileList);


///////////////////////
// Externs and States
///////////////////////
extern "C" bool SpawnEffect(const char*, int, Vec*, S16Vec*, Vec*);

//FIXME make this dEn_c->used...
extern "C" char usedForDeterminingStatePress_or_playerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther, int unk1);
extern "C" int SomeStrangeModification(dStageActor_c* actor);
extern "C" void DoStuffAndMarkDead(dStageActor_c *actor, Vec vector, float unk);
extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);

extern "C" bool HandlesEdgeTurns(dEn_c* actor);
extern "C" void dAcPy_vf3F8(void* player, dEn_c* monster, int t);

CREATE_STATE(daPoihana_c, RealWalk);
CREATE_STATE(daPoihana_c, RealTurn);

CREATE_STATE(daPoihana_c, GoDizzy);
CREATE_STATE(daPoihana_c, FireKnockBack);
CREATE_STATE(daPoihana_c, FlameHit);
CREATE_STATE(daPoihana_c, Recover);

CREATE_STATE(daPoihana_c, Die);

////////////////////////
// Collision Functions
////////////////////////

void ChuckleAndKnuckles(ActivePhysics *apThis, ActivePhysics *apOther) {
	if (apOther->owner->name != PLAYER) { return; }
	((dEn_c*)apThis->owner)->_vf220(apOther->owner);
}


void daPoihana_c::spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	u16 name = ((dEn_c*)apOther->owner)->name;

	if (name == EN_COIN || name == EN_EATCOIN || name == AC_BLOCK_COIN || name == EN_COIN_JUGEM || name == EN_COIN_ANGLE
		|| name == EN_COIN_JUMP || name == EN_COIN_FLOOR || name == EN_COIN_VOLT || name == EN_COIN_WIND
		|| name == EN_BLUE_COIN || name == EN_COIN_WATER || name == EN_REDCOIN || name == EN_GREENCOIN
		|| name == EN_JUMPDAI || name == EN_ITEM)
		{ return; }

	if (acState.getCurrentState() == &StateID_RealWalk) {

		pos.x = ((pos.x - ((dEn_c*)apOther->owner)->pos.x) > 0) ? pos.x + 1.5 : pos.x - 1.5;
		doStateChange(&StateID_RealTurn); }

	if (acState.getCurrentState() == &StateID_FireKnockBack) {
		float distance = pos.x - ((dEn_c*)apOther->owner)->pos.x;
		pos.x = pos.x + (distance / 4.0);
	}

	dEn_c::spriteCollision(apThis, apOther);
}

void daPoihana_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	dStateBase_c *stateVar;
	dStateBase_c *deathState;
	dStageActor_c *player = apOther->owner;
	char hitType;
	stateVar = &StateID_GoDizzy;
	deathState = &StateID_Die;
	this->playEnemyDownSound1();
	doStateChange(stateVar); 
	bouncePlayer(player, 7.0f);
	OSReport("BOUNCING TO THE SKYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY");
	PlaySound(this, SE_EMY_CMN_STEP);
}

void daPoihana_c::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->playerCollision(apThis, apOther);
}
bool daPoihana_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	PlaySound(this, SE_EMY_DOWN);
	S16Vec nullRot = {0,0,0};
	Vec oneVec = {1.0f, 1.0f, 1.0f};
	SpawnEffect("Wm_mr_hardhit", 0, &pos, &nullRot, &oneVec);
	doStateChange(&StateID_Die);
	return true;
}
bool daPoihana_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	return this->collisionCatD_Drill(apThis, apOther);
}
bool daPoihana_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	return this->collisionCatD_Drill(apThis, apOther);
}
bool daPoihana_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
	return this->collisionCatD_Drill(apThis, apOther);
}
bool daPoihana_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){
	return this->collisionCatD_Drill(apThis, apOther);
}
bool daPoihana_c::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther){
	return this->collisionCatD_Drill(apThis, apOther);
}
bool daPoihana_c::collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther){
	return this->collisionCatD_Drill(apThis, apOther);
}
bool daPoihana_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
	StageE4::instance->spawnCoinJump(pos, 0, 2, 0);
	return this->collisionCatD_Drill(apThis, apOther);
}

bool daPoihana_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){
	bool wut = dEn_c::collisionCat3_StarPower(apThis, apOther);
	doStateChange(&StateID_Die);
	return wut;
}

bool daPoihana_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){
	doStateChange(&StateID_DieSmoke);
	return true;
}
bool daPoihana_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->damage += 1;
	dStateBase_c *stateVar;
	stateVar = &StateID_DieSmoke;
	if (this->type < 6) {
		backFire = apOther->owner->direction ^ 1;
		StageE4::instance->spawnCoinJump(pos, 0, 1, 0);
		doStateChange(&StateID_DieSmoke);
	}

	if (this->damage > 1) {
		nw4r::snd::SoundHandle handle;
		PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_EMY_DOWN, 1);
		StageE4::instance->spawnCoinJump(pos, 0, 1, 0);
		doStateChange(&StateID_DieSmoke);
	}
	else {
		nw4r::snd::SoundHandle handle;
		PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_EMY_KURIBO_L_DAMAGE_01, 1);
		doStateChange(stateVar);
	}
	return true;
}

// These handle the ice crap
void daPoihana_c::_vf148() {
	dEn_c::_vf148();
	doStateChange(&StateID_Die);
}
void daPoihana_c::_vf14C() {
	dEn_c::_vf14C();
	doStateChange(&StateID_Die);
}

extern "C" void sub_80024C20(void);
extern "C" void __destroy_arr(void*, void(*)(void), int, int);

bool daPoihana_c::CreateIceActors() {
	struct DoSomethingCool my_struct = { 0, this->pos, {1.9, 1.7, 2.5}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	this->frzMgr.Create_ICEACTORs( (void*)&my_struct, 1 );
	__destroy_arr( (void*)&my_struct, sub_80024C20, 0x3C, 1 );
	chrAnimation.setUpdateRate(0.0f);
	return true;
}

bool daPoihana_c::calculateTileCollisions() {
	// Returns true if sprite should turn, false if not.

	HandleXSpeed();
	HandleYSpeed();
	doSpriteMovement();

	cmgr_returnValue = collMgr.isOnTopOfTile();
	collMgr.calculateBelowCollisionWithSmokeEffect();

	if (isBouncing) {
		stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);
		if (speed.y != 0.0f)
			isBouncing = false;
	}

	float xDelta = pos.x - last_pos.x;
	if (xDelta >= 0.0f)
		direction = 0;
	else
		direction = 1;

	if (collMgr.isOnTopOfTile()) {
		// Walking into a tile branch

		if (cmgr_returnValue == 0)
			isBouncing = true;

		if (speed.x != 0.0f) {
		}

		speed.y = 0.0f;
		max_speed.x = (direction == 1) ? -XSpeed : XSpeed;
	} else {
		x_speed_inc = 0.0f;
	}

	// Bouncing checks
	if (_34A & 4) {
		Vec v = (Vec){0.0f, 1.0f, 0.0f};
		collMgr.pSpeed = &v;

		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;

		collMgr.pSpeed = &speed;

	} else {
		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;
	}

	collMgr.calculateAdjacentCollision(0);

	// Switch Direction
	if (collMgr.outputMaybe & (0x15 << direction)) {
		if (collMgr.isOnTopOfTile()) {
			isBouncing = true;
		}
		return true;
	}
	return false;
}

void daPoihana_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daPoihana_c::onCreate() {
	this->type = this->settings >> 28 & 0xF;
	this->distance = this->settings >> 12 & 0xF;

	stillFalling = 0;

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->deleteForever = 1;
	this->resFile.data = getResource("cataquack", "g3d/cataquack.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("poihana");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);

	// Animations start here
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("walk");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	// Stuff I do understand
	this->scale = (Vec){0.1, 0.1, 0.1};

	this->pos.y += 36.0;
	this->rot.x = 0; // X is vertical axis
	this->rot.y = 0xD800; // Y is horizontal axis
	this->rot.z = 0; // Z is ... an axis >.>
	this->direction = 1; // Heading left.

	this->speed.x = 0.0;
	this->speed.y = 0.0;
	this->max_speed.x = 0.6;
	this->x_speed_inc = 0.15;
	this->Baseline = this->pos.y;
	this->XSpeed = 0.6;


	ActivePhysics::Info HitMeBaby;

	// Note: if this gets changed, also change the point where the default
	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 12.0;
	HitMeBaby.xDistToEdge = 8.0;
	HitMeBaby.yDistToEdge = 12.0;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &shyCollisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	// Tile collider

	// These fucking rects do something for the tile rect
	spriteSomeRectX = 28.0f;
	spriteSomeRectY = 32.0f;
	_320 = 0.0f;
	_324 = 16.0f;

	// These structs tell stupid collider what to collide with - these are from koopa troopa
	static const lineSensor_s below(-5<<12, 5<<12, 0<<12);
	static const pointSensor_s above(0<<12, 12<<12);
	static const lineSensor_s adjacent(6<<12, 9<<12, 6<<12);

	collMgr.init(this, &below, &above, &adjacent);
	collMgr.calculateBelowCollisionWithSmokeEffect();
	cmgr_returnValue = collMgr.isOnTopOfTile();



	if (collMgr.isOnTopOfTile())
		isBouncing = false;
	else
		isBouncing = true;


	// State Changers

	if (type == 0) {
		bindAnimChr_and_setUpdateRate("walk", 1, 0.0, 1.5);
		doStateChange(&StateID_RealWalk);
	}
	else if (type == 1) {
		bindAnimChr_and_setUpdateRate("walk", 1, 0.0, 1.5);
		doStateChange(&StateID_RealWalk);
	}

	return true;
}

int daPoihana_c::onDelete() {
	return true;
}

int daPoihana_c::onExecute() {
	acState.execute();
	updateModelMatrices();
	bodyModel._vf1C();

	return true;
}

int daPoihana_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}

void daPoihana_c::updateModelMatrices() {
	// This won't work with wrap because I'm lazy.

/*	if (this->frzMgr._mstate == 1)
		matrix.translation(pos.x, pos.y, pos.z);
	else*/
	matrix.translation(pos.x, pos.y + 20, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

///////////////
// Real Walk State
///////////////
bool daPoihana_c::willWalkOntoSuitableGround() {
	static const float deltas[] = {2.5f, -2.5f};
	VEC3 checkWhere = {
			pos.x + deltas[direction],
			4.0f + pos.y,
			pos.z};

	u32 props = collMgr.getTileBehaviour2At(checkWhere.x, checkWhere.y, currentLayerID);

	//if (getSubType(props) == B_SUB_LEDGE)
	if (((props >> 16) & 0xFF) == 8)
		return false;

	float someFloat = 0.0f;
	if (collMgr.sub_800757B0(&checkWhere, &someFloat, currentLayerID, 1, -1)) {
		if (someFloat < checkWhere.y && someFloat > (pos.y - 5.0f))
			return true;
	}

	return false;
}


void daPoihana_c::beginState_RealWalk() {
	//inline this piece of code
	this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
	this->speed.x = (direction) ? -0.6f : 0.6f;

	this->max_speed.y = -4.0;
	this->speed.y = -4.0;
	this->y_speed_inc = -0.1875;
}
void daPoihana_c::executeState_RealWalk() {
	chrAnimation.setUpdateRate(1.5f);
	if (distance) {
		if (collMgr.isOnTopOfTile()) {
			stillFalling = false;

			if (!willWalkOntoSuitableGround()) {
				pos.x = direction ? pos.x + 1.5 : pos.x - 1.5;
				doStateChange(&StateID_RealTurn);
			}
		}
		else {
			if (!stillFalling) {
				stillFalling = true;
				pos.x = direction ? pos.x + 1.5 : pos.x - 1.5;
				doStateChange(&StateID_RealTurn);
			}
		}
	}

	bool ret = calculateTileCollisions();
	if (ret) {
		doStateChange(&StateID_RealTurn);
	}

	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}
}
void daPoihana_c::endState_RealWalk() { }

///////////////
// Real Turn State
///////////////
void daPoihana_c::beginState_RealTurn() {

	this->direction ^= 1;
	this->speed.x = 0.0;
}
void daPoihana_c::executeState_RealTurn() {

	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
	int done = SmoothRotation(&this->rot.y, amt, 0x800);

	if(done) {
		this->doStateChange(&StateID_RealWalk);
	}
}
void daPoihana_c::endState_RealTurn() {
}

///////////////
// GoDizzy State
///////////////
void daPoihana_c::beginState_GoDizzy() {
	bindAnimChr_and_setUpdateRate("throw", 1, 0.0, 1.0);

	// SpawnEffect("Wm_en_spindamage", 0, &(Vec){this->pos.x, this->pos.y + 24.0, 0}, &(S16Vec){0,0,0}, &(Vec){1.0, 1.0, 1.0});

	this->max_speed.x = 0;
	this->speed.x = 0;
	this->x_speed_inc = 0;

	this->max_speed.y = -4.0;
	this->speed.y = -4.0;
	this->y_speed_inc = -0.1875;

	this->timer = 0;
	this->jumpCounter = 0;
	this->isDown = 1;
}
void daPoihana_c::executeState_GoDizzy() {
	calculateTileCollisions();

	Vec efPos = {this->pos.x, this->pos.y + 24.0f, 0};
	S16Vec nullRot = {0,0,0};
	Vec oneVec = {1.0f, 1.0f, 1.0f};
	//effect.spawn("Wm_en_spindamage", 0, &efPos, &nullRot, &oneVec);

	/*if (this->jumpCounter == 0) {
		if(this->chrAnimation.isAnimationDone()) {
			this->jumpCounter = 1;
			bindAnimChr_and_setUpdateRate("walk", 1, 0.0, 1.0);
		}
	}

	else {*/
		if(this->chrAnimation.isAnimationDone()) {
			this->chrAnimation.setCurrentFrame(0.0);
			doStateChange(&StateID_Recover);
			damage = 0;
		}

		/*if (this->timer > 600) {
			doStateChange(&StateID_Recover);
			damage = 0;
		}*/

		this->timer += 1;
	//}
}
void daPoihana_c::endState_GoDizzy() {}

///////////////
// FireKnockBack State
///////////////
void daPoihana_c::beginState_FireKnockBack() {
	bindAnimChr_and_setUpdateRate("overturn", 1, 0.0, 1.0);

	// Backfire 0 == Fireball to the right
	// Backfire 1 == Fireball to the left

	directionStore = this->direction;
	speed.x = (this->backFire) ? this->XSpeed : -this->XSpeed;
	speed.x *= 1.2f;
	max_speed.x = speed.x;
	x_speed_inc = 0.0f;
}
void daPoihana_c::executeState_FireKnockBack() {

	calculateTileCollisions();
	// move backwards here
	this->speed.x = this->speed.x / 1.02f;

	if(this->chrAnimation.isAnimationDone()) {
		if (aPhysics.result1 == 0 && aPhysics.result2 == 0 && aPhysics.result3 == 0) {
			bindAnimChr_and_setUpdateRate("walk", 1, 0.0, 1.5);
			doStateChange(&StateID_RealWalk);
		}
	}
}
void daPoihana_c::endState_FireKnockBack() {
	this->direction = directionStore;
}

///////////////
// FlameHit State
///////////////
void daPoihana_c::beginState_FlameHit() {
	bindAnimChr_and_setUpdateRate("overturn", 1, 0.0, 1.0);
}
void daPoihana_c::executeState_FlameHit() {

	if(this->chrAnimation.isAnimationDone()) {
	}
}
void daPoihana_c::endState_FlameHit() {}

///////////////
// Recover State
///////////////
void daPoihana_c::beginState_Recover() {
	//bindAnimChr_and_setUpdateRate("c18_L_DMG_F_4_R", 1, 0.0, 1.0);
}
void daPoihana_c::executeState_Recover() {

	calculateTileCollisions();

	//if(this->chrAnimation.isAnimationDone()) {
		bindAnimChr_and_setUpdateRate("walk", 1, 0.0, 1.5);
		doStateChange(&StateID_RealWalk);
	//}
}
void daPoihana_c::endState_Recover() {
	this->isDown = 0;
	this->rot.y = (direction) ? 0xD800 : 0x2800;
}

///////////////
// Die State
///////////////
void daPoihana_c::beginState_Die() {
	// dEn_c::dieFall_Begin();
	this->removeMyActivePhysics();

	bindAnimChr_and_setUpdateRate("overturn", 1, 0.0, 2.0);
	this->timer = 0;
	this->dying = -10.0;
	this->Baseline = this->pos.y;
	this->rot.y = 0;
	this->rot.x = 0;

	if (type > 5 && type < 9) {
		Vec efPos = {this->pos.x, this->pos.y - 32.0f, 0};
		S16Vec nullRot = {0,0,0};
		Vec oneVec = {1.0f, 1.0f, 1.0f};
		SpawnEffect("Wm_en_explosion_ln", 0, &efPos, &nullRot, &oneVec);
	}
}
void daPoihana_c::executeState_Die() {

	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	this->timer += 1;

	// this->pos.x += 0.5;
	this->pos.y = Baseline + (-0.2 * dying * dying) + 20.0;

	this->dying += 0.5;

	if (this->timer > 450) {
		OSReport("Killing");
		this->kill();
		this->Delete(this->deleteForever);
	}

	// dEn_c::dieFall_Execute();

}
void daPoihana_c::endState_Die() { }
//
// processed\../src/flippanel.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>

const char *FlipPanelFileList[] = {"FlipSwapPanel", 0};

class daEnFlipPanel_c : public dEn_c {
public:
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	Physics physics;
	Physics::Info physicsInfo;

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c model;
	m3d::anmChr_c chrAnimation;

	s16 frame;
	bool flipClockWise;
	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate, int frame);
	void flipThisPanel();

	USING_STATES(daEnFlipPanel_c);
	DECLARE_STATE(Wait);
	DECLARE_STATE(Flipping);

	static dActor_c *build();
};

const SpriteData flipPanelSpriteData = { ProfileId::FlipPanel, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile flipPanelProfile(&daEnFlipPanel_c::build, SpriteId::FlipPanel, flipPanelSpriteData, ProfileId::FlipPanel, ProfileId::FlipPanel, "FlipPanel", FlipPanelFileList);


CREATE_STATE(daEnFlipPanel_c, Wait);
CREATE_STATE(daEnFlipPanel_c, Flipping);


void flipAllPanels() {
	daEnFlipPanel_c *panel = (daEnFlipPanel_c*)fBase_c::search(FlipPanel, 0);
	if(panel) {
		panel->flipThisPanel();
		while((panel = (daEnFlipPanel_c*)fBase_c::search(FlipPanel, panel)) != 0) {
			panel->flipThisPanel();
		}
		NewSFXPlayer(5, true);
	}
}

s16 flipPanelRotations[] = { 0x0, 0x13, 0x14, 0x39, 0xb6, 0x183, 0x280, 0x3b9, 0x53e, 0x71c, 0x93b, 0xb76, 0xdcd, 0x103c, 0x12c4, 0x1563, 0x1816, 0x1add, 0x1db6, 0x209f, 0x2398, 0x269e, 0x29b0, 0x2ccc, 0x2ff2, 0x331f, 0x3652, 0x3989, 0x3cc4, 0x4000, 0x433c, 0x4677, 0x49ae, 0x4ce1, 0x500e, 0x5334, 0x5650, 0x5962, 0x5c68, 0x5f61, 0x624a, 0x6523, 0x67ea, 0x6a9d, 0x6d3c, 0x6fc4, 0x7233, 0x748a, 0x76c5, 0x78e4, 0x7ac3, 0x7c49, 0x7d84, 0x7e80, 0x7f4a, 0x7fcc, 0x7ffc, 0x7ffd, 0x7ff3, 0x8000 };

void daEnFlipPanel_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate, int frame) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->model, anmChr, unk);
	chrAnimation.setCurrentFrame(frame);
	this->model.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

void daEnFlipPanel_c::flipThisPanel() {
	if(acState.getCurrentState() == &StateID_Wait) {
		if(frame <= 0) {
			frame = 0;
			flipClockWise = false;
		}
		if(frame >= 59) {
			frame = 59;
			flipClockWise = true;
		}
		if(flipClockWise) {
			bindAnimChr_and_setUpdateRate("rotatePlateClockR-L", 1, 0.0, 1.0f, 0);
		} else {
			bindAnimChr_and_setUpdateRate("rotatePlateCounterL-R", 1, 0.0, 1.0f, 0);
		}
		doStateChange(&StateID_Flipping);
	} else {
		flipClockWise = !flipClockWise;
		if(flipClockWise) {
			bindAnimChr_and_setUpdateRate("rotatePlateClockR-L", 1, 0.0, 1.0f, 59-frame);
		} else {
			bindAnimChr_and_setUpdateRate("rotatePlateCounterL-R", 1, 0.0, 1.0f, frame);
		}
	}
}

void daEnFlipPanel_c::beginState_Wait() {}
void daEnFlipPanel_c::executeState_Wait() {}
void daEnFlipPanel_c::endState_Wait() {}

void daEnFlipPanel_c::beginState_Flipping() {}
void daEnFlipPanel_c::executeState_Flipping() {
	if(frame < 0 || frame > 59) {
		doStateChange(&StateID_Wait);
	} else {
		physics.setPtrToRotation(&flipPanelRotations[frame]);
		if(flipClockWise) {
			frame--;
		} else {
			frame++;
		}
	}
}
void daEnFlipPanel_c::endState_Flipping() {}

int daEnFlipPanel_c::onCreate() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	resFile.data = getResource("FlipSwapPanel", "g3d/FlipSwapPanel.brres");
	nw4r::g3d::ResMdl mdl = resFile.GetResMdl("FlipSwapPanel");
	model.setup(mdl, &allocator, 0, 1, 0);
	//SetupTextures_MapObj(&model, 0);

	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("rotatePlateClockR-L");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	scale = (Vec){0.25, 0.25, 0.25};
	
	physicsInfo.x1 = -50;
	physicsInfo.y1 = 6;
	physicsInfo.x2 = 3;
	physicsInfo.y2 = -6;

	//Callbacks from magicplatform.cpp because daEnBlockMain_c callbacks crash the game somehow
	physicsInfo.otherCallback1 = (void*)&PhysCB1;
	physicsInfo.otherCallback2 = (void*)&PhysCB2;
	physicsInfo.otherCallback3 = (void*)&PhysCB3;

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.flagsMaybe = 0x260;
	physics.callback1 = (void*)&PhysCB4;
	physics.callback2 = (void*)&PhysCB5;
	physics.callback3 = (void*)&PhysCB6;
	physics.addToList();

	if(this->settings & 1) {	//bit 48: dual box start left or start right
		OSReport("Start right\n");
		bindAnimChr_and_setUpdateRate("rotatePlateCounterL-R", 1, 0.0, 1.0f, 59);
		frame = 59;
		flipClockWise = true;
		physics.setPtrToRotation(&flipPanelRotations[frame]);
	} else {
		bindAnimChr_and_setUpdateRate("rotatePlateClockR-L", 1, 0.0, 1.0f, 59);
	}

	doStateChange(&daEnFlipPanel_c::StateID_Wait);

	return true;
}


int daEnFlipPanel_c::onDelete() {
	physics.removeFromList();

	return true;
}


int daEnFlipPanel_c::onExecute() {
	acState.execute();
	
	physics.update();

	// now check zone bounds based on state
	/*if (acState.getCurrentState()->isEqual(&StateID_Wait)) {
		checkZoneBoundaries(0);
	}*/

	return true;
}


int daEnFlipPanel_c::onDraw() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	model.setDrawMatrix(matrix);
	model.setScale(&scale);
	model.calcWorld(false);
	model.scheduleForDrawing();
	model._vf1C();

	return true;
}


dActor_c *daEnFlipPanel_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daEnFlipPanel_c));
	daEnFlipPanel_c *c = new(buffer) daEnFlipPanel_c;

	return c;
}
//
// processed\../src/byugo.cpp
//

const char* ByugoNameList [] = { "Byugo", NULL };

class daByugo_c : public dEn_c {
public:

	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	void updateModelMatrices();
	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	static dActor_c* build();

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c animationChr;
	nw4r::g3d::ResFile resFile;

	int loopCount;
	float radius;

	mEf::es2 effect;

	USING_STATES(daByugo_c);
	DECLARE_STATE(Wait);
	DECLARE_STATE(Sign);
	DECLARE_STATE(Start);
	DECLARE_STATE(Loop);
	DECLARE_STATE(End);
};

CREATE_STATE(daByugo_c, Wait);
CREATE_STATE(daByugo_c, Sign);
CREATE_STATE(daByugo_c, Start);
CREATE_STATE(daByugo_c, Loop);
CREATE_STATE(daByugo_c, End);

void daByugo_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y - 16, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


void daByugo_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->animationChr.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->animationChr, unk2);
	this->animationChr.setUpdateRate(rate);
}

dActor_c* daByugo_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daByugo_c));
	return new(buffer) daByugo_c;
}

const SpriteData ByugoSpriteData = { ProfileId::Byugo, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile ByugoProfile(&daByugo_c::build, SpriteId::Byugo, ByugoSpriteData, ProfileId::Byugo, ProfileId::Byugo, "Byugo", ByugoNameList);


int daByugo_c::onCreate() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	resFile.data = getResource("Byugo", "g3d/Byugo.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("Byugo");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("Wait");
	this->animationChr.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink(); 

	this->scale = (Vec){0.7, 0.7, 0.7};

	doStateChange(&StateID_Wait);

	return true;
}

extern float layerZPositionForByugoHack;

int daByugo_c::onExecute() {
	acState.execute();

	updateModelMatrices();
	bodyModel._vf1C();

	for(int i = 0; i < 4; i++) {
		dAcPy_c *player;
		if(player = dAcPy_c::findByID(i)) {
			if(player->currentLayerID == 2) return true;
		}
	}
	layerZPositionForByugoHack = -1800.0f;	//reset value if no player hit by Ty-Foo --> doesn't work if e.g. a player uses a pipe at the same time, since that also makes the player switch to currentLayerID 2
	
	return true;
}

int daByugo_c::onDelete() {
	return true;
}

int daByugo_c::onDraw() {
	bodyModel.scheduleForDrawing();

	return true;
}

extern "C" u32 GenerateRandomNumber(int max);
void daByugo_c::beginState_Wait() {
	bindAnimChr_and_setUpdateRate("Wait", 1, 0.0, 1.0);
}
void daByugo_c::executeState_Wait() {
	if (this->animationChr.isAnimationDone()) {
		if(GenerateRandomNumber(5) == 0) {
			doStateChange(&StateID_Sign);
		} else {
			this->animationChr.setCurrentFrame(0.0);
		}
	}
}
void daByugo_c::endState_Wait() {}

void daByugo_c::beginState_Sign() {
	bindAnimChr_and_setUpdateRate("BlowSign", 1, 0.0, 1.0);
}
void daByugo_c::executeState_Sign() {
	if (this->animationChr.isAnimationDone()) {
		doStateChange(&StateID_Start);
	}
}
void daByugo_c::endState_Sign() {}

void daByugo_c::beginState_Start() {
	bindAnimChr_and_setUpdateRate("BlowStart", 1, 0.0, 1.0);
}
void daByugo_c::executeState_Start() {
	if (this->animationChr.isAnimationDone()) {
		doStateChange(&StateID_Loop);
	}
}
void daByugo_c::endState_Start() {}

void daByugo_c::beginState_Loop() {
	bindAnimChr_and_setUpdateRate("BlowLoop", 1, 0.0, 1.0);
	loopCount = 0;
	radius = 8.0f;
}
void daByugo_c::executeState_Loop() {
	for(int i = 0; i < 4; i++) {
		dAcPy_c *player;
		if(player = dAcPy_c::findByID(i)) {
			float dx = this->pos.x - player->pos.x;
			float dy = this->pos.y - player->pos.y;
			if(sqrtf(dx*dx + dy*dy) <= this->radius * 3) {
				if(player->states2.getCurrentState() != &daPlBase_c::StateID_Quake) {
					player->stunPlayer();
				}
			}
		}
	}


	S16Vec nullRot = {0,0,0};
	Vec oneVec = {0.75f*radius, 0.75f*radius, 0.75f*radius};
	effect.spawn("Wm_mr_slipsmoke", 0, &(Vec){pos.x, pos.y - 16, 0}, &nullRot, &oneVec);

	radius += 0.1f;

	if (this->animationChr.isAnimationDone()) {
		if(loopCount >= 9) {
			doStateChange(&StateID_End);
		} else {
			this->animationChr.setCurrentFrame(0.0);
			loopCount++;
		}
	}
}
void daByugo_c::endState_Loop() {
	for(int i = 0; i < 4; i++) {
		dAcPy_c *player;
		if(player = dAcPy_c::findByID(i)) {
			if(player->states2.getCurrentState() == &daPlBase_c::StateID_Quake) {
				player->unstunPlayer();
				player->currentLayerID = 2;
				layerZPositionForByugoHack = 5500.0f;
			}
		}
	}
}

void daByugo_c::beginState_End() {
	bindAnimChr_and_setUpdateRate("BlowEnd", 1, 0.0, 1.0);
}
void daByugo_c::executeState_End() {
	if (this->animationChr.isAnimationDone()) {
		doStateChange(&StateID_Wait);
	}
}
void daByugo_c::endState_End() {}



const char* SwitchLayerFileList [] = { NULL };

class daSwitchLayer_c : public dEn_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();

	static dActor_c* build();

	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
};

dActor_c* daSwitchLayer_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daSwitchLayer_c));
	return new(buffer) daSwitchLayer_c;
}

const SpriteData SwitchLayerSpriteData = { ProfileId::SwitchLayer, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile SwitchLayerProfile(&daSwitchLayer_c::build, SpriteId::SwitchLayer, SwitchLayerSpriteData, ProfileId::SwitchLayer, ProfileId::SwitchLayer, "SwitchLayer", SwitchLayerFileList);

int daSwitchLayer_c::onCreate() {
	ActivePhysics::Info HitMeBaby; 
	HitMeBaby.xDistToCenter = 0.0; 
	HitMeBaby.yDistToCenter = 0.0; 
	HitMeBaby.xDistToEdge = this->settings; 
	HitMeBaby.yDistToEdge = 3.0; 
	HitMeBaby.category1 = 0x3; 
	HitMeBaby.category2 = 0x0; 
	HitMeBaby.bitfield1 = 0x4F; 
	HitMeBaby.bitfield2 = 0xFFFFFFFF; 
	HitMeBaby.unkShort1C = 0; 
	HitMeBaby.callback = &dEn_c::collisionCallback; 
	this->aPhysics.initWithStruct(this, &HitMeBaby); 
	this->aPhysics.addToList(); 

	return true;
}

int daSwitchLayer_c::onExecute() {
	return true;
}

int daSwitchLayer_c::onDelete() {
	return true;
}

void daSwitchLayer_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	dAcPy_c* player = (dAcPy_c*)apOther->owner;
	if(player->speed.y > 0) {
		player->currentLayerID = 0;
	}
}
//
// processed\../src/randomLooperEvent.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>


class randomLooperEvent : public dStageActor_c {
public:
	u8 minDelayActivate, maxDelayActivate, minDelayDeactivate, maxDelayDeactivate, repeated;
	int timer;
	bool active;

	void changeTriggerEventState();

	int onCreate();
	int onExecute();

	static dActor_c *build();
};

const char *RandomLooperEventFileList[] = {0};
const SpriteData randomLooperEventSpriteData = { ProfileId::RandomLooperEvent, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile randomLooperEventProfile(&randomLooperEvent::build, SpriteId::RandomLooperEvent, randomLooperEventSpriteData, ProfileId::RandomLooperEvent, ProfileId::RandomLooperEvent, "RandomLooperEvent", RandomLooperEventFileList);


dActor_c  *randomLooperEvent::build() {
	void *buffer = AllocFromGameHeap1(sizeof(randomLooperEvent));
	randomLooperEvent *c = new(buffer) randomLooperEvent;

	return c;
}


/*
target event id
trigger event id
min delay
max delay
min delay2
max delay2
repeat x times
*/

int randomLooperEvent::onCreate() {
	this->minDelayActivate = (this->settings & 0xFF);
	this->maxDelayActivate = (this->settings >> 8 & 0xFF);
	this->minDelayDeactivate = (this->settings >> 16 & 0xFF);
	this->maxDelayDeactivate = (this->settings >> 24 & 0xFF);

	this->timer = GenerateRandomNumber(this->maxDelayDeactivate - this->minDelayDeactivate) + this->minDelayDeactivate;;
	this->repeated = 0;

	return true;
}


int randomLooperEvent::onExecute() {
	if(this->currentLayerID != 0) {
		repeated++;
		if(this->currentLayerID > repeated) {
			this->Delete(1);
		}
	}
	
	bool flagOn = ((dFlagMgr_c::instance->flags & (1ULL << (eventId2 - 1))) != 0);
	//OSReport("Is flag on: %s\n", flagOn ? "true" : "false");
	if(flagOn) {
		if(this->timer <= 0) {
			if(active) {
				timer = GenerateRandomNumber(this->maxDelayDeactivate - this->minDelayDeactivate) + this->minDelayDeactivate;
			} else {
				timer = GenerateRandomNumber(this->maxDelayActivate - this->minDelayActivate) + this->minDelayActivate;
			}
			active = !active;

			this->changeTriggerEventState();
		} else {
			timer--;
		}
	}
	return true;
}


void randomLooperEvent::changeTriggerEventState() {
	dFlagMgr_c::instance->set(this->eventId1, 0, !dFlagMgr_c::instance->active(this->eventId1), false, false);
}
//
// processed\../src/greenRing.cpp
//

// <<< Green Ring i Green Coins>>>

// First, we're gonna declare the needed headers.
#include <common.h>     // Common functions
#include <game.h>       // Everything related with the game
#include <g3dhax.h>     // 3d models and graphics
#include <sfx.h>        // Sound effects

const char* GreenRingAndCoinFileList [] = { "green_ring", "obj_coin", NULL };

class daGreenCoin_c;

// Now we declare the dEn_c class, which will be the class of our sprite
class daGreenRing_c: public dEn_c { 
    // Common functions:
    int onCreate();     // This is executed when created (if returned 0, it's executed next frame)
    int onDelete();     // This is executed when a sprite is deleted
    int onExecute();    // This is a loop, every frame will be called
    int onDraw();       // This draws the sprite, every frame

    // This is needed for assigning enough RAM to the sprite
    mHeapAllocator_c allocator; 

    // File with the 3D models and animations (.brres)
    nw4r::g3d::ResFile resFile;
    // 3D-bodyModel actual (.brres -> .mdl0-file)
    m3d::mdl_c bodyModel;
    // Actual animation (.brres -> .chr0-file)
    m3d::anmChr_c chrAnimation;

    // -------------------
    // Stardard variables
    // -------------------

    int timer;
    float dying;
    bool damage;
    bool ringCollected;
    Vec initialPos;

    // ------------
    //   My stuff
    // ------------

    // Every time a green coin is collected, this is called
    public: int coinCollected();

    // Cantity of coins collected
    public: int collected;

    // This variable will make our sprite to execute one frame later. If not, it may be unable to find the coins.
    bool runOnce;

    // This is our ring's id
    public: int ringID;

    // Item rewarded
    int reward;

    // Now we declare an array containing all the coins.
    daGreenCoin_c* coins[5];

    // -------- 
    //  More...  
    // -------- 

    // We'll use this from the .yaml to create the sprite.
    static dActor_c* build();

    
    void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate); // This starts the animation.
    void updateModelMatrices();     // This draws the 3D model.
    
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther); // Is the player colliding with the sprite?
    
	/*
	bool calculateTileCollisions(); // Are we hitting a wall? This is useful to rotate the sprite if hitting a wall.

    // Some important collisions
    void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther); // Is the player colliding with the sprite?
    void spriteCollision(ActivePhysics* apThis, ActivePhysics* apOther); // If the sprite is colliding with... another sprite?
    void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);  // If the sprite is colliding with... Yoshi?



    // Those collisions are about...

    // Mario...
    bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);        // With a star
    bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);            // Sliding
    bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);            // Drilling with a propeller
    bool collisionCat8_FencePunch(ActivePhysics *apThis, ActivePhysics *apOther);	    // Doing a hit behind a wall
    bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);      // Ground pounding
    bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);	// Ground pounding with yoshi
    bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);	    // Sliding with a penguin
    bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);      // Thrown from a pipe
    
    // Other objects...
    bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);		// Sliding (Koopas, barrels)
    bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther); // Fire balls
    bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);	// Ice balls
    bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);	            // Hammers (from the hammer-suite)
    bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);	        // Yoshi's fireballs 
	*/
};

// I'm gonna declare now the green coin here, because both the green coin and the green ring will interact together.
class daGreenCoin_c: public dEn_c { 
    // Commun functions:
    int onCreate();     // This is executed when created (if returned 0, it's executed next frame)
    int onDelete();     // This is executed when a sprite is deleted
    int onExecute();    // This is a loop, every frame will be called
    int onDraw();       // This draws the sprite, every frame

    // This is needed for assigning enough RAM to the sprite
    mHeapAllocator_c allocator; 

    // File with the 3D models and animations (.brres)
    nw4r::g3d::ResFile resFile;
    // 3D-bodyModel actual (.brres -> .mdl0-file)
    m3d::mdl_c bodyModel;
    // Actual animation (.brres -> .chr0-file)
    m3d::anmChr_c chrAnimation;

    // -------------------
    // Standard variables
    // -------------------

    int timer;
    float dying;
    bool damage;
    bool isDown;
    Vec initialPos;

    // ------------
    //   My stuff
    // ------------

    public: int makeVisible(); // This will make visible the coin

    // This is the id of the money
    public: int groupId;

    // This is the id of the ring
    public: int ringID;
	public: daGreenRing_c* ring;

    // This tells us if the money is visible or isn't
    public: bool visible;

    // -------
    // More...
    // -------

    // We'll use this from the .yaml to create the sprite.
    static dActor_c* build();

    
    void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate); // This starts the animation.
    void updateModelMatrices();     // This draws the 3D model.
    
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther); // Is the player colliding with the sprite?
    
	/*bool calculateTileCollisions(); // Are we hitting a wall? This is useful to rotate the sprite if hitting a wall.

    // Some important collisions
    void spriteCollision(ActivePhysics* apThis, ActivePhysics* apOther); // If the sprite is colliding with... another sprite?
    void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);  // If the sprite is colliding with... Yoshi?



    // Those collisions are about...

    // Mario...
    bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);        // With a star
    bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);            // Sliding
    bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);            // Drilling with a propeller
    bool collisionCat8_FencePunch(ActivePhysics *apThis, ActivePhysics *apOther);	    // Doing a hit behind a wall
    bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);      // Ground pounding
    bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);	// Ground pounding with yoshi
    bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);	    // Sliding with a penguin
    bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);      // Thrown from a pipe
    
    // Other objects...
    bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);		// Sliding (Koopas, barrels)
    bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther); // Fire balls
    bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);	// Ice balls
    bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);	            // Hammers (from the hammer-suite)
    bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);	        // Yoshi's fireballs
	*/
};

//  Here starts the real code!

//  # ------ #
//  #  RING  #
//  # ------ #

// We'll access this from the .yaml
dActor_c *daGreenRing_c::build() {
    void *buffer = AllocFromGameHeap1(sizeof(daGreenRing_c));
    return new(buffer) daGreenRing_c;
}

const SpriteData GreenRingSpriteData = { ProfileId::GreenRing, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile GreenRingProfile(&daGreenRing_c::build, SpriteId::GreenRing, GreenRingSpriteData, ProfileId::GreenRing, ProfileId::GreenRing, "Green Ring", GreenRingAndCoinFileList);

// When the green ring is created...
int daGreenRing_c::onCreate() {
	OSReport("onCreate\n");

    // Everything will be executed one frame later
    if (this->runOnce == false) {
        this->runOnce = true;
        return false;
    }

    // Those settings are inserted from Reggie 
    this->ringID = this->settings >> 28 & 0xF;
    this->reward = this->settings >> 24 & 0xF;

    // This is an iterator pointer (so we can always access it), and it will always be a daGreenCoin_c class
    daGreenCoin_c *iter = 0;

    // Now, this gets the green coins. 
    while(iter = (daGreenCoin_c*)fBase_c::search(GreenCoin, iter)) {
        // If the coin found is linked to the same ring than our (there might be different rings), then...
        if (iter->ringID == this->ringID) {
            // Add this found money to our coins array, to the position declared in the coin ID.
            this->coins[iter->groupId] = iter;
			iter->ring = this;
        }
    }

    // Do what you always do...

    allocator.link(-1, GameHeaps[0], 0, 0x20);
    nw4r::g3d::ResFile rf(getResource("green_ring", "g3d/green_ring.brres")); // THIS MIGHT NOT BE REAL
    bodyModel.setup(rf.GetResMdl("red_ring"), &allocator, 0x224, 1, 0);
    SetupTextures_MapObj(&bodyModel, 0);

    allocator.unlink();

    // Let's start the physics (ActivePhysics)
    ActivePhysics::Info HitMeBaby;
    HitMeBaby.xDistToCenter = 0.0;
    HitMeBaby.yDistToCenter = 0.0;
    HitMeBaby.xDistToEdge = 15.0;
    HitMeBaby.yDistToEdge = 20.0;
    HitMeBaby.category1 = 0x5;
    HitMeBaby.category2 = 0x0;
    HitMeBaby.bitfield1 = 0x4F; // TODO
    HitMeBaby.bitfield2 = 0xFFBAFFFE; // TODO
    HitMeBaby.unkShort1C = 0;
    HitMeBaby.callback = &dEn_c::collisionCallback;

    this->aPhysics.initWithStruct(this, &HitMeBaby);
    this->aPhysics.addToList();

    // Here we set the scale
    this->scale.x = 1.0;
    this->scale.y = 1.0;
    this->scale.z = 1.0;

    // And the position
    //this->pos.x = 120.0;
    //this->pos.y = 3300.0;

    return true;
}

// Every time a coin is collected...
int daGreenRing_c::coinCollected() {
    // Increase the collected coins var
    this->collected++;

    // If there are less than 5 moneys collected...
    if (this->collected < 5) {
        // Make visible next coin
        this->coins[this->collected]->makeVisible();
    }
    else {
        // REWARD, TODO
    }
}

int daGreenRing_c::onDelete() {
	return true;
}

int daGreenRing_c::onDraw() {
	if(!ringCollected) {
		bodyModel.scheduleForDrawing();
	}

	return true;
}

int daGreenRing_c::onExecute() {
	if(!ringCollected) {
		updateModelMatrices();
		bodyModel._vf1C();
	}
}

void daGreenRing_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


void daGreenRing_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	timer = 180;
	this->coins[0]->makeVisible();
	aPhysics.removeFromList();
	ringCollected = true;
}














//  # ------ #
//  #  COIN  #
//  # ------ #

// We'll access this function from the .yaml
dActor_c *daGreenCoin_c::build() {
    void *buffer = AllocFromGameHeap1(sizeof(daGreenCoin_c));
    return new(buffer) daGreenCoin_c;
}

const SpriteData GreenCoinSpriteData = { ProfileId::GreenCoin, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile GreenCoinProfile(&daGreenCoin_c::build, SpriteId::GreenCoin, GreenCoinSpriteData, ProfileId::GreenCoin, ProfileId::GreenCoin, "Green Coin", GreenRingAndCoinFileList);

// We make the coin visible and we activate everything, including models and animations
int daGreenCoin_c::makeVisible() {
    // Make the coin visible (so now the onExecute() function will work)
    this->visible = true;

    // Enable the model
    allocator.link(-1, GameHeaps[0], 0, 0x20);
    nw4r::g3d::ResFile rf(getResource("obj_coin", "g3d/obj_coin.brres")); 
    bodyModel.setup(rf.GetResMdl("obj_coin_green"), &allocator, 0x224, 1, 0);
    SetupTextures_MapObj(&bodyModel, 0);

    allocator.unlink();

    // Start the physics (ActivePhysics)
    ActivePhysics::Info HitMeBaby;
    HitMeBaby.xDistToCenter = 0.0;
    HitMeBaby.yDistToCenter = 0.0;
    HitMeBaby.xDistToEdge = 15.0;
    HitMeBaby.yDistToEdge = 20.0;
    HitMeBaby.category1 = 0x5;
    HitMeBaby.category2 = 0x0;
    HitMeBaby.bitfield1 = 0x4F; // TODO
    HitMeBaby.bitfield2 = 0xFFBAFFFE; // TODO
    HitMeBaby.unkShort1C = 0;
    HitMeBaby.callback = &dEn_c::collisionCallback;

    this->aPhysics.initWithStruct(this, &HitMeBaby);
    this->aPhysics.addToList();

    // Here we set the scale
    this->scale.x = 1.0;
    this->scale.y = 1.0;
    this->scale.z = 1.0;

    // And the position
    //this->pos.x = 120.0;
    //this->pos.y = 3300.0;
}

// This will happen firstly
int daGreenCoin_c::onCreate() {

    // We get some vars from Reggie
    this->ringID = this->settings >> 28 & 0xF;
    this->groupId = this->settings >> 24 & 0xF;

    return true;
}

int daGreenCoin_c::onExecute() {
    if (this->visible) {
        // TODO
		updateModelMatrices();
		bodyModel._vf1C();
    }
}

int daGreenCoin_c::onDraw() {
	bodyModel.scheduleForDrawing();

	return true;
}

void daGreenCoin_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daGreenCoin_c::onDelete() {
	return true;
}

void daGreenCoin_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	ring->coinCollected();
	this->Delete(1);
}
//
// processed\../src/barrelCannon.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "path.h"

extern "C" dCourse_c::rail_s *GetRail(int id);

const char* BarrelCannonFileList[] = { "barrelCannon", 0 };

class daBarrelCannon_c : public dEnPath_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;

	u8 rotation;
	
	dAcPy_c* players[4];
	u8 delays[4];

	s16 rotationS16;

	static dActor_c *build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	
	USING_STATES(daBarrelCannon_c);
	
	DECLARE_STATE(Wait);
};

CREATE_STATE(daBarrelCannon_c, Wait);


void daBarrelCannon_c::beginState_Wait() {}
void daBarrelCannon_c::executeState_Wait() {
	dStageActor_c* player = (dStageActor_c*)FindActorByType(PLAYER, 0);

	dx = player->pos.x - this->pos.x;
	dy = player->pos.y - this->pos.y;

	distance = sqrtf(pow(dx, 2) + pow(dy, 2));

	if (distance <= 64) {
		doStateChange(&StateID_FollowPath);
	}
}
void daBarrelCannon_c::endState_Wait() {}






const SpriteData BarrelCannonSpriteData = { ProfileId::BarrelCannon, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile BarrelCannonProfile(&daBarrelCannon_c::build, SpriteId::BarrelCannon, BarrelCannonSpriteData, ProfileId::BarrelCannon, ProfileId::BarrelCannon, "BarrelCannon", BarrelCannonFileList);


void daBarrelCannon_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	dAcPy_c* player = (dAcPy_c*)apOther->owner;
	if (delays[player->characterID] == 0) {
		players[player->characterID] = player;
		delays[player->characterID] = 60;
	}
}
void daBarrelCannon_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {

}
bool daBarrelCannon_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBarrelCannon_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBarrelCannon_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBarrelCannon_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daBarrelCannon_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBarrelCannon_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBarrelCannon_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daBarrelCannon_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daBarrelCannon_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daBarrelCannon_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daBarrelCannon_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daBarrelCannon_c));
	daBarrelCannon_c* c = new(buffer) daBarrelCannon_c;

	return c;
}

int daBarrelCannon_c::onCreate() {
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("barrelCannon", "g3d/barrelCannon.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("barrelCannon");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	allocator.unlink();

	this->rotation = this->settings >> 29 & 0b111;
	this->rot.z = 0x2000*this->rotation;


	ActivePhysics::Info HitMeBaby;

	// Note: if this gets changed, also change the point where the default
	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 12.0;
	HitMeBaby.xDistToEdge = 12.0;
	HitMeBaby.yDistToEdge = 12.0;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x4F;
	HitMeBaby.bitfield2 = 0x0;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();
	

	this->disableEatIn();


	this->scale = (Vec){2, 2, 2};

	this->pos.z = 4000;

	players[0] = 0;
	players[1] = 0;
	players[2] = 0;
	players[3] = 0;
	
	delays[0] = 0;
	delays[1] = 0;
	delays[2] = 0;
	delays[3] = 0;
	
	beginState_Init();
	executeState_Init();
	doStateChange(&StateID_Wait);
	
	this->onExecute();
	return true;
}


int daBarrelCannon_c::onDelete() {
	return true;
}

int daBarrelCannon_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daBarrelCannon_c::updateModelMatrices() {
	Vec p = this->pos;
	switch (this->rotation) {
		case 1:
			p.y += 3;
			p.x += 9;
			break;
		case 2:
			p.y += 12;
			p.x += 12;
			break;
		case 3:
			p.y += 18;
			p.x += 9;
			break;
		case 4:
			p.y += 24;
			break;
		case 5:
			p.y += 21;
			p.x -= 9;
			break;
		case 6:
			p.y += 12;
			p.x -= 12;
			break;
		case 7:
			p.y += 3;
			p.x -= 12;
			break;
		case 0:
		default:
		
	}

	matrix.translation(p.x, p.y, p.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daBarrelCannon_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();
	acState.execute();

	int i = 0;
	while (i < 4) {
		if(delays[i] != 0) {
			delays[i]--;
		}
		
		if(players[i] != 0) {
			players[i]->pos.x = this->pos.x;
			players[i]->pos.y = this->pos.y + 7;
			players[i]->setFlag(0xbb);
			if(players[i]->input.heldButtons & WPAD_TWO) {
				players[i]->clearFlag(0xbb);
				float x = 0.0f, y = 0.0f;
				switch (this->rotation) {
					case 1:
						x = -10.6066f;
						y = 10.6066f;
						break;
					case 2:
						x = -15.0f;
						y = 0.0f;
						break;
					case 3:
						x = -10.6066f;
						y = -10.6066f;
						break;
					case 4:
						x = 0.0f;
						y = -15.0f;
						break;
					case 5:
						x = 10.6066f;
						y = -10.6066f;
						break;
					case 6:
						x = 15.0f;
						y = 0.0f;
						break;
					case 7:
						x = 10.6066f;
						y = 10.6066f;
						break;
					case 0:
					default:
						x = 0.0f;
						y = 15.0f;
				}
				players[i]->pipeCannonShot(0, y, x);
				players[i] = 0;
			}
		}
		i++;
	}
}



//
// processed\../src/tikiAirship.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "path.h"

extern "C" dCourse_c::rail_s *GetRail(int id);

const char* TikiAirshipFileList[] = { "tikiAirship", 0 };

class daTikiAirship_c : public dEnPath_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;

	u8 moveDirection;
	Physics physics0;
	Physics::Info physicsInfo1;
	Physics physics1;
	Physics::Info physicsInfo2;
	Physics physics2;
	Physics::Info physicsInfo3;
	Physics physics3;
	StandOnTopCollider sotCollider;
	StandOnTopCollider sotCollider1;
	StandOnTopCollider sotCollider2;

	static dActor_c *build();

	void updateModelMatrices();
	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	
	USING_STATES(daTikiAirship_c);
	
	DECLARE_STATE(Wait);
};

CREATE_STATE(daTikiAirship_c, Wait);


void daTikiAirship_c::beginState_Wait() {}
void daTikiAirship_c::executeState_Wait() {
	dStageActor_c* player = (dStageActor_c*)FindActorByType(PLAYER, 0);

	dx = player->pos.x - this->pos.x;
	dy = player->pos.y - this->pos.y;

	distance = sqrtf(pow(dx, 2) + pow(dy, 2));

	if (distance <= 64) {
		doStateChange(&StateID_FollowPath);
	}
}
void daTikiAirship_c::endState_Wait() {}






const SpriteData TikiAirshipSpriteData = { ProfileId::TikiAirship, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile TikiAirshipProfile(&daTikiAirship_c::build, SpriteId::TikiAirship, TikiAirshipSpriteData, ProfileId::TikiAirship, ProfileId::TikiAirship, "TikiAirship", TikiAirshipFileList);


void daTikiAirship_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
}
void daTikiAirship_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {

}
bool daTikiAirship_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daTikiAirship_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daTikiAirship_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daTikiAirship_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daTikiAirship_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daTikiAirship_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daTikiAirship_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}
bool daTikiAirship_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daTikiAirship_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}

bool daTikiAirship_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}


dActor_c* daTikiAirship_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daTikiAirship_c));
	daTikiAirship_c* c = new(buffer) daTikiAirship_c;

	return c;
}

int daTikiAirship_c::onCreate() {
	this->deleteForever = true;

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("tikiAirship", "g3d/TikiAirship.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("TikiAirship");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	//SetupTextures_Player(&bodyModel, 0);

	allocator.unlink();


	//middle bottom
	physicsInfo1.x1 = -34;
	physicsInfo1.y1 = 4;
	physicsInfo1.x2 = 24;
	physicsInfo1.y2 = 0;

	physicsInfo1.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo1.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo1.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics1.setup(this, &physicsInfo1, 3, currentLayerID);
	physics1.flagsMaybe = 0x260;
	physics1.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics1.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics1.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics1.addToList();
	
	
	//left bottom
	physicsInfo2.x1 = -60;//-34;
	physicsInfo2.y1 = 20;
	physicsInfo2.x2 = -30;
	physicsInfo2.y2 = 0;

	physicsInfo2.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo2.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo2.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics2.setup(this, &physicsInfo2, 3, currentLayerID);
	physics2.flagsMaybe = 0x260;
	physics2.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics2.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics2.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics2.addToList();


	//right bottom
	physicsInfo3.x1 = 20;
	physicsInfo3.y1 = 20;
	physicsInfo3.x2 = 58;//24;
	physicsInfo3.y2 = 0;

	physicsInfo3.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo3.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo3.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics3.setup(this, &physicsInfo3, 3, currentLayerID);
	physics3.flagsMaybe = 0x260;
	physics3.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics3.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics3.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics3.addToList();
	
	

	sotCollider.init(this, 0, 16, -8, 24, -34, 0, 1);
	sotCollider._47 = 0xA;
	sotCollider.flags = 0x80180 | 0xC00;
	sotCollider.addToList();

	sotCollider1.init(this, 0, 16, 4.1f, -30, -60, 0, 1);
	sotCollider1._47 = 0xA;
	sotCollider1.flags = 0x80180 | 0xC00;
	sotCollider1.addToList();
	
	sotCollider2.init(this, 0, 16, 4.1f, 58, 20, 0, 1);
	sotCollider2._47 = 0xA;
	sotCollider2.flags = 0x80180 | 0xC00;
	sotCollider2.addToList();
	
	this->disableEatIn();
	
	this->scale = (Vec){-0.75, 0.75, 0.75};

	this->rot.x = 0;
	this->rot.y = 0x4000;
	this->rot.z = 0;

	this->pos.z = -4000;

	beginState_Init();
	executeState_Init();
	doStateChange(&StateID_Wait);
	
	this->onExecute();
	return true;
}


int daTikiAirship_c::onDelete() {
	return true;
}

int daTikiAirship_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daTikiAirship_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y + 80, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daTikiAirship_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();
	acState.execute();

	
	sotCollider.update();
	sotCollider1.update();
	sotCollider2.update();
	physics1.update();
	physics2.update();
	physics3.update();
}
//
// processed\../src/mummyMe.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
#include <profile.h>

extern void shyCollisionCallback(ActivePhysics *apThis, ActivePhysics *apOther);
const char* MummyMeFileList [] = {
	"mummyMe",
	NULL	
};




class daMummyMe_c : public dEn_c {
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile anmFile;

	m3d::mdl_c bodyModel;
	m3d::anmChr_c chrAnimation;
	mEf::es2 effect;

	int timer;
	int type;
	float dying;
	float Baseline;
	char damage;
	char isDown;
	Vec initialPos;
	int distance;
	float XSpeed;
	u32 cmgr_returnValue;
	bool isBouncing;
	int directionStore;

	public: static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();
	bool calculateTileCollisions();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);

	void powBlockActivated(bool isNotMPGP);

	void _vf148();
	void _vf14C();
	bool CreateIceActors();
	void addScoreWhenHit(void *other);
	void bouncePlayerWhenJumpedOn(void *player);

	void spawnHitEffectAtPosition(Vec2 pos);
	void doSomethingWithHardHitAndSoftHitEffects(Vec pos);
	void playEnemyDownSound2();
	void playHpdpSound1(); // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
	void playEnemyDownSound1();
	void playEnemyDownComboSound(void *player); // AcPy_c/daPlBase_c?
	void playHpdpSound2(); // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
	void _vf260(void *other); // AcPy/PlBase? plays the SE_EMY_FUMU_%d sounds based on some value
	void _vf264(dStageActor_c *other); // if other is player or yoshi, do Wm_en_hit and a few other things
	void _vf268(void *other); // AcPy/PlBase? plays the SE_EMY_DOWN_SPIN_%d sounds based on some value
	void _vf278(void *other); // AcPy/PlBase? plays the SE_EMY_YOSHI_FUMU_%d sounds based on some value

	USING_STATES(daMummyMe_c);
	DECLARE_STATE(RealWalk);
	DECLARE_STATE(RealTurn);
	DECLARE_STATE(Die);
};

const SpriteData MummyMeSpriteData = {ProfileId::MummyMe, 0x5, -0x31, 0, 0x10, 0x10, 0x40, 0x40, 0x40, 0, 0, 0};
Profile MummyMeProfile(&daMummyMe_c::build, SpriteId::MummyMe, MummyMeSpriteData, ProfileId::MummyMe, ProfileId::MummyMe, "Mummy-Me", MummyMeFileList);

dActor_c *daMummyMe_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daMummyMe_c));
	return new(buffer) daMummyMe_c;
}

///////////////////////
// Externs and States
///////////////////////
extern "C" bool SpawnEffect(const char*, int, Vec*, S16Vec*, Vec*);

//FIXME make this dEn_c->used...
extern "C" char usedForDeterminingStatePress_or_playerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther, int unk1);
extern "C" int SomeStrangeModification(dStageActor_c* actor);
extern "C" void DoStuffAndMarkDead(dStageActor_c *actor, Vec vector, float unk);
extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);

// Collision related
extern "C" void BigHanaPlayer(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" void BigHanaYoshi(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" bool BigHanaWeirdGP(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" bool BigHanaGroundPound(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" bool BigHanaFireball(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" bool BigHanaIceball(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);

extern "C" void dAcPy_vf3F8(void* player, dEn_c* monster, int t);

CREATE_STATE(daMummyMe_c, RealWalk);
CREATE_STATE(daMummyMe_c, RealTurn);
CREATE_STATE(daMummyMe_c, Die);

////////////////////////
// Collision Functions
////////////////////////

void daMummyMe_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) { 
	apOther->someFlagByte |= 2;

	dStageActor_c *player = apOther->owner;

	char hitType;
	hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);
	if (hitType > 0) {
		PlaySound(this, SE_EMY_CMN_STEP);
		this->counter_504[apOther->owner->which_player] = 0xA;
	} else {
		this->dEn_c::playerCollision(apThis, apOther);
		this->_vf220(apOther->owner);
		if (Player_VF3D4(player)) {
			// WE'VE GOT A STAR, FOLKS
			if (apThis->_18 == 1 && !player->collMgr.isOnTopOfTile() && player->pos.y > apThis->bottom()) {
				bouncePlayer(player, 3.0f);
				PlaySound(this, SE_EMY_CMN_STEP);
			} else {
				dAcPy_vf3F8(player, this, 3);
			}
			this->counter_504[apOther->owner->which_player] = 0xA;

		}
	} 
}			
void daMummyMe_c::_vf278(void *other) {
	PlaySound(this, SE_EMY_HANACHAN_STOMP);
}

void daMummyMe_c::bouncePlayerWhenJumpedOn(void *player) {
	bouncePlayer(player, 5.0f);
}

void daMummyMe_c::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->playerCollision(apThis, apOther);
}
bool daMummyMe_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaWeirdGP(this, apThis, apOther);
}
bool daMummyMe_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaGroundPound(this, apThis, apOther);
}
bool daMummyMe_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaGroundPound(this, apThis, apOther);
}

bool daMummyMe_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
	apOther->owner->kill();
	return true;
}
bool daMummyMe_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){
	dAcPy_vf3F8(apOther->owner, this, 3);
	this->counter_504[apOther->owner->which_player] = 0xA;
	return true;
}
bool daMummyMe_c::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther){
	return true;
}
bool daMummyMe_c::collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther){
	return true;
}
bool daMummyMe_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true;
}
bool daMummyMe_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){
	/*int hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);
	if (hitType == 1 || hitType == 3) {
		PlaySound(this, SE_EMY_CMN_STEP);
		bouncePlayerWhenJumpedOn(apOther->owner);
	} else {
		dAcPy_vf3F8(apOther->owner, this, 3);
	}

	this->counter_504[apOther->owner->which_player] = 0xA;
	return true;*/
	return false;
}

bool daMummyMe_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){
	return BigHanaFireball(this, apThis, apOther);
}
bool daMummyMe_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaFireball(this, apThis, apOther);
}
bool daMummyMe_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaIceball(this, apThis, apOther);
}

// These handle the ice crap
void daMummyMe_c::_vf148() {
	dEn_c::_vf148();
	doStateChange(&StateID_Die);
}
void daMummyMe_c::_vf14C() {
	dEn_c::_vf14C();
	doStateChange(&StateID_Die);
}

extern "C" void sub_80024C20(void);
extern "C" void __destroy_arr(void*, void(*)(void), int, int);

bool daMummyMe_c::CreateIceActors() {
	struct DoSomethingCool my_struct = { 0, this->pos, {2.4, 3.0, 3.0}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	this->frzMgr.Create_ICEACTORs( (void*)&my_struct, 1 );
	__destroy_arr( (void*)&my_struct, sub_80024C20, 0x3C, 1 );
	return true;
}

void daMummyMe_c::addScoreWhenHit(void *other) { }

void daMummyMe_c::spawnHitEffectAtPosition(Vec2 pos) { }
void daMummyMe_c::doSomethingWithHardHitAndSoftHitEffects(Vec pos) { }
void daMummyMe_c::playEnemyDownSound2() { }
void daMummyMe_c::playHpdpSound1() { } // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
void daMummyMe_c::playEnemyDownSound1() { }
void daMummyMe_c::playEnemyDownComboSound(void *player) { } // AcPy_c/daPlBase_c?
void daMummyMe_c::playHpdpSound2() { } // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
void daMummyMe_c::_vf260(void *other) { } // AcPy/PlBase? plays the SE_EMY_FUMU_%d sounds based on some value
void daMummyMe_c::_vf264(dStageActor_c *other) { } // if other is player or yoshi, do Wm_en_hit and a few other things
void daMummyMe_c::_vf268(void *other) { } // AcPy/PlBase? plays the SE_EMY_DOWN_SPIN_%d sounds based on some value

void daMummyMe_c::powBlockActivated(bool isNotMPGP) {
}

bool daMummyMe_c::calculateTileCollisions() {
	// Returns true if sprite should turn, false if not.

	HandleXSpeed();
	HandleYSpeed();
	doSpriteMovement();

	cmgr_returnValue = collMgr.isOnTopOfTile();
	collMgr.calculateBelowCollisionWithSmokeEffect();

	if (isBouncing) {
		stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);
		if (speed.y != 0.0f)
			isBouncing = false;
	}

	float xDelta = pos.x - last_pos.x;
	if (xDelta >= 0.0f)
		direction = 0;
	else
		direction = 1;

	if (collMgr.isOnTopOfTile()) {
		// Walking into a tile branch

		if (cmgr_returnValue == 0)
			isBouncing = true;

		if (speed.x != 0.0f) {
			//playWmEnIronEffect();
		}

		speed.y = 0.0f;

		// u32 blah = collMgr.s_80070760();
		// u8 one = (blah & 0xFF);
		// static const float incs[5] = {0.00390625f, 0.0078125f, 0.015625f, 0.0234375f, 0.03125f};
		// x_speed_inc = incs[one];
		max_speed.x = (direction == 1) ? -this->XSpeed : this->XSpeed;
	} else {
		x_speed_inc = 0.0f;
	}

	// Bouncing checks
	if (_34A & 4) {
		Vec v = (Vec){0.0f, 1.0f, 0.0f};
		collMgr.pSpeed = &v;

		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;

		collMgr.pSpeed = &speed;

	} else {
		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;
	}

	collMgr.calculateAdjacentCollision(0);

	// Switch Direction
	if (collMgr.outputMaybe & (0x15 << direction)) {
		if (collMgr.isOnTopOfTile()) {
			isBouncing = true;
		}
		return true;
	}
	return false;
}

void daMummyMe_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daMummyMe_c::onCreate() {
	OSReport("Spawning Mummy Me\n");

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("mummyMe", "g3d/mummyMe.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("MummyMe");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);

	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("walk");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);


	allocator.unlink();

	this->pos.y += 32.0;
	this->rot.x = 0; // X is vertical axis
	this->rot.y = 0xD800; // Y is horizontal axis
	this->rot.z = 0; // Z is ... an axis >.>
	this->direction = 1; // Heading left.
	
	this->speed.x = 0.0;
	this->speed.y = 0.0;
	this->Baseline = this->pos.y;

	ActivePhysics::Info HitMeBaby;
	float anmSpeed;

	this->scale = (Vec){1.0f, 1.0f, 1.0f};

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 16.0;

	HitMeBaby.xDistToEdge = 10.0;
	HitMeBaby.yDistToEdge = 16.0;

	this->XSpeed = 0.4;
	anmSpeed = 1.25;

	static const lineSensor_s below(-5<<12, 5<<12, 0<<12);
	static const lineSensor_s adjacent(10<<12, 9<<12, 10<<12);
	collMgr.init(this, &below, 0, &adjacent);

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x1;
	HitMeBaby.bitfield2 = 0x820A4;
	HitMeBaby.unkShort1C = 0x0;
	HitMeBaby.callback = &shyCollisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	collMgr.calculateBelowCollisionWithSmokeEffect();

	cmgr_returnValue = collMgr.isOnTopOfTile();

	if (collMgr.isOnTopOfTile())
		isBouncing = false;
	else
		isBouncing = true;

	bindAnimChr_and_setUpdateRate("walk", 1, 0.0, anmSpeed); 
	doStateChange(&StateID_RealWalk);

	this->onExecute();
	return true;
}

int daMummyMe_c::onDelete() {
	return true;
}

int daMummyMe_c::onExecute() {
	acState.execute();
	updateModelMatrices();

	return true;
}

int daMummyMe_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}

void daMummyMe_c::updateModelMatrices() {
	float yoff;

	yoff = 1.25;//-5.0;
	
	matrix.translation(pos.x, pos.y + yoff, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


///////////////
// Real Walk State
///////////////
void daMummyMe_c::beginState_RealWalk() {
	//inline this piece of code
	this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
	this->speed.x = (direction) ? -this->XSpeed : this->XSpeed;

	this->max_speed.y = -4.0;
	this->speed.y = -4.0;
	this->y_speed_inc = -0.1875;
}
void daMummyMe_c::executeState_RealWalk() { 
	bodyModel._vf1C();

	bool ret = calculateTileCollisions();
	if (ret) {
		doStateChange(&StateID_RealTurn);
	}

	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}
}
void daMummyMe_c::endState_RealWalk() { }

///////////////
// Real Turn State
///////////////
void daMummyMe_c::beginState_RealTurn() {

	this->direction ^= 1;
	this->speed.x = 0.0;
}
void daMummyMe_c::executeState_RealTurn() { 
	bodyModel._vf1C();

	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
	int done = SmoothRotation(&this->rot.y, amt, 0x800);

	if(done) {
		this->doStateChange(&StateID_RealWalk);
	}
}
void daMummyMe_c::endState_RealTurn() {
}

///////////////
// Die State
///////////////
void daMummyMe_c::beginState_Die() {
	// dEn_c::dieFall_Begin();
	this->removeMyActivePhysics();

	bindAnimChr_and_setUpdateRate("walk", 1, 0.0, 2.0); 
	this->timer = 0;
	this->dying = -10.0;
	this->Baseline = this->pos.y;
	this->rot.y = 0;
	this->rot.x = 0;
}
void daMummyMe_c::executeState_Die() { 
	bodyModel._vf1C();

	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	this->timer += 1;
			
	// this->pos.x += 0.5; 
	this->pos.y = Baseline + (-0.2 * dying * dying) + 20.0;
	
	this->dying += 0.5;
		
	if (this->timer > 450) {
		this->kill();
		this->Delete(this->deleteForever);
	}

	// dEn_c::dieFall_Execute();

}
void daMummyMe_c::endState_Die() {
}


//
// processed\../src/tenten.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "path.h"

const char* WingTentenFileList[] = { "TentenWing", 0 };


class daEnParaTenten_c : public dEnPath_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile resFileAnim;
	m3d::mdl_c bodyModel;

	nw4r::g3d::ResAnmTexPat anmPat;

	m3d::anmChr_c chrAnimation;
	m3d::anmTexPat_c patAnimation;

	bool leftRight;

	bool facingRight;
	u8 wSpeed;
	u8 wDistance;

	int stepCount;

	bool ranOnce;

	static dActor_c* build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	//bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);

	//setDeathInfo_IceBreak -> what should be done when in an iceblock and crashes a wall -> normally the sprite should die
	void _vf148();
	//setDeathInfo_IceVanish -> what should be done when collision with an iceblock thrown by Mario -> normally the sprite should die
	void _vf14C();
	//create an ice block when collided with Iceball
	bool CreateIceActors();

	//void addScoreWhenHit(void* other);
};

const SpriteData WingTentenSpriteData = { ProfileId::WingTenten, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile WingTentenProfile(&daEnParaTenten_c::build, SpriteId::WingTenten, WingTentenSpriteData, ProfileId::WingTenten, ProfileId::WingTenten, "WingTenten", WingTentenFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnParaTenten_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	char hitType;
	hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);

	if(hitType == 1) {	// regular jump
		apOther->someFlagByte |= 2;
		this->Delete(1);
	}
	else if(hitType == 3) {	// spinning jump or whatever?
		apOther->someFlagByte |= 2;
		this->Delete(1);
	}
	else if(hitType == 0) {
		EN_LandbarrelPlayerCollision(this, apThis, apOther);
		DamagePlayer(this, apThis, apOther);
	} else {
		DamagePlayer(this, apThis, apOther);
	}
}
void daEnParaTenten_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {}
bool daEnParaTenten_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnParaTenten_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnParaTenten_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnParaTenten_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	if ((this->facingRight && apOther->owner->pos.x < this->pos.x) || (!this->facingRight && apOther->owner->pos.x > this->pos.x))
	{
		this->Delete(1);
		return true;
	}
	return false;
}

bool daEnParaTenten_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
/*bool daEnParaTenten_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}*/
bool daEnParaTenten_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnParaTenten_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnParaTenten_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}

bool daEnParaTenten_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}


void daEnParaTenten_c::_vf148() {
	dEn_c::_vf148();
}

void daEnParaTenten_c::_vf14C() {
	dEn_c::_vf14C();
}

//this does weird shit, but it creates the iceblock around it
bool daEnParaTenten_c::CreateIceActors() {
	struct DoSomethingCool my_struct = { 0, this->pos, {1.5, 2.0, 1.8}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	this->frzMgr.Create_ICEACTORs((void*)&my_struct, 1);
	__destroy_arr((void*)&my_struct, sub_80024C20, 0x3C, 1);
	//this->chrAnimation.setCurrentFrame(0.0);
	this->chrAnimation.setUpdateRate(0.0);
	//this->frozen = true;
	return true;
}


dActor_c* daEnParaTenten_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnParaTenten_c));
	daEnParaTenten_c* c = new(buffer) daEnParaTenten_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

void daEnParaTenten_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate)
{
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daEnParaTenten_c::onCreate() {
	if(!this->ranOnce) {
		this->ranOnce = true;
		return false;
	}
	
	this->deleteForever = true;

	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("TentenWing", "g3d/TentenWing.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("TentenWing");
	bodyModel.setup(mdl, &allocator, 0x227, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	this->resFileAnim.data = getResource("TentenWing", "g3d/TentenWing.brres");
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr("FlyWait");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	this->anmPat = this->resFile.GetResAnmTexPat("TentenWing");
	this->patAnimation.setup(mdl, anmPat, &this->allocator, 0, 1);
	this->patAnimation.bindEntry(&this->bodyModel, &anmPat, 0, 1);
	this->patAnimation.setFrameForEntry(((this->eventId1 & 0b111) % 5), 0);
	this->patAnimation.setUpdateRateForEntry(0.0f, 0);
	this->bodyModel.bindAnim(&this->patAnimation);

	allocator.unlink();

	ActivePhysics::Info HitMeBaby;

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 0.0;

	HitMeBaby.xDistToEdge = 7.5;
	HitMeBaby.yDistToEdge = 7.5;

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x6F;
	HitMeBaby.bitfield2 = 0xffbafffe;
	HitMeBaby.unkShort1C = 0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();


	this->leftRight = settings >> 31 & 1;

	this->facingRight = settings >> 30 & 1;
	this->wDistance = settings >> 20 & 0b11111111;
	this->wSpeed = settings >> 16 & 0b1111;

	this->scale = (Vec){0.4, 0.4, 0.4};

	this->rot.x = 0;
	if (facingRight)
	{
		this->rot.y = 0x4000;
	}
	else
	{
		this->rot.y = 0x4000;
		this->rot.y *= -1;
	}
	this->rot.z = 0;

	this->pos.z = 4000;

	bindAnimChr_and_setUpdateRate("FlyWait", 1, 0.0, 1.0);

	if(this->leftRight) {
		doStateChange(&StateID_Wait);
	} else {
		beginState_Init();
		if (this->rotateNext) {
			if (this->stepVector.x > 0) {
				this->rot.y = 0x4000;
			} else {
				this->rot.y = -0x4000;
			}
		} else if (this->rotate0XNext) {
			this->rot.y = 0x0;
		}
		executeState_Init();
		doStateChange(&StateID_FollowPath);
	}

	this->onExecute();
	return true;
}


int daEnParaTenten_c::onDelete() {
	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_EMY_DOWN, 1);
	StageE4::instance->spawnCoinJump(pos, 0, 1, 0);
	return true;
}

int daEnParaTenten_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnParaTenten_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y - 8, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

int daEnParaTenten_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();

	//OSReport("fr: %d, wD: %d, wS: %d, stepCount: %d\n", this->facingRight, this->wDistance, this->wSpeed, this->stepCount);

	if(this->leftRight) {
		if (this->facingRight) {
			this->rot.y = 0x4000;

			this->pos.x += this->wSpeed;
			this->stepCount += 1;

			if ((stepCount * wSpeed) > wDistance) {
				this->facingRight = false;
				this->stepCount = 0;
			}
		} else {
			this->rot.y = 0x4000;
			this->rot.y *= -1;

			this->pos.x -= this->wSpeed;
			this->stepCount += 1;

			if ((stepCount * wSpeed) > wDistance) {
				this->facingRight = true;
				this->stepCount = 0;
			}
		}
	} else {
		acState.execute();
		if (this->stepsDone == this->stepCount) {
			if (this->rotateNext) {
				if (this->stepVector.x > 0) {
					this->rot.y = 0x4000;
				} else {
					this->rot.y = -0x4000;
				}
			} else if (this->rotate0XNext) {
				this->rot.y = 0x0;
			}
		}
	}
	if (this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	return true;
}
//
// processed\../src/darkStar.cpp
//

const char* DarkStarFileList [] = { "shroobUfo", NULL };

class daDarkStar_c : public dEn_c {
public:

	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	void updateModelMatrices();
	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	static dActor_c* build();

	//void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	//bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat8_FencePunch(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther); 
	//bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c animationChr;
	nw4r::g3d::ResFile resFile;
	
	u16 unk1;	//0xdd4
	u16 unk2;	//0xdd8
	int unk3;	//0xd88

	USING_STATES(daDarkStar_c);
	DECLARE_STATE(StarMove);
	
	bool FUN_80a290c0();
	void FUN_80a288d0();
	void FUN_80a29280();
};

CREATE_STATE(daDarkStar_c, StarMove);

void daDarkStar_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


void daDarkStar_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->animationChr.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->animationChr, unk2);
	this->animationChr.setUpdateRate(rate);
}

dActor_c* daDarkStar_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daDarkStar_c));
	return new(buffer) daDarkStar_c;
}

const SpriteData DarkStarSpriteData = { ProfileId::DarkStar, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile DarkStarProfile(&daDarkStar_c::build, SpriteId::DarkStar, DarkStarSpriteData, ProfileId::DarkStar, ProfileId::DarkStar, "Dark Star", DarkStarFileList);


int daDarkStar_c::onCreate() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	resFile.data = getResource("shroobUfo", "g3d/shroobUfo.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("shroobUfo");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);
	//nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("FlyNoTurret");
	//this->animationChr.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink(); 

	ActivePhysics::Info HitMeBaby; 
	HitMeBaby.xDistToCenter = 0.0; 
	HitMeBaby.yDistToCenter = 0.0; 
	HitMeBaby.xDistToEdge = 0.0; 
	HitMeBaby.yDistToEdge = 0.0; 
	HitMeBaby.category1 = 0x3; 
	HitMeBaby.category2 = 0x0; 
	HitMeBaby.bitfield1 = 0x4F; 
	HitMeBaby.bitfield2 = 0xFFFFFFFF; 
	HitMeBaby.unkShort1C = 0; 
	HitMeBaby.callback = &dEn_c::collisionCallback; 
	this->aPhysics.initWithStruct(this, &HitMeBaby); 
	this->aPhysics.addToList(); 

	this->scale = (Vec){0.1, 0.1, 0.1};
	
	this->rot.y = -0x2000;
	
	//this->disableEatIn();

	//MakeMarioEnterDemoMode();

	doStateChange(&StateID_StarMove);

	return true;
}

int daDarkStar_c::onExecute() {
	acState.execute();

	updateModelMatrices();
	bodyModel._vf1C();

	/*if (this->animationChr.isAnimationDone()) {
		this->animationChr.setCurrentFrame(0.0);
	}*/

	return true;
}

int daDarkStar_c::onDelete() {
	return true;
}

int daDarkStar_c::onDraw() {
	bodyModel.scheduleForDrawing();

	return true;
}




void daDarkStar_c::beginState_StarMove() {
  //if (*(char *)((int)this->acState.ac1.statemgr.vtable + 3) == 0) {
  if(true) {
	this->speed.y = 4.0f;
    this->speed.x = (this->direction ? -1.0f : 1.0f);
  } else {
    this->speed.x = 0.0f;
    this->speed.y = 0.0f;
  }
  checkLiquidImmersionAndKillIfTouchingLava(&this->pos, 1.0f);
  this->FUN_80a290c0();
  return;
}


void daDarkStar_c::FUN_80a288d0() {
	if (unk2 == 0) {
		return;
	}
	if (unk1 != 0) {
		unk1 -= 1;
	}
	if (unk1 != 0) {
		return;
	}
	unk2 = 0;
	return;
}


bool daDarkStar_c::FUN_80a290c0() {
  int iVar1 = this->EnWaterFlagCheck(&this->pos);
  if (iVar1) {
    this->isImmersedInLiquid_maybe = 1;
  }
  return iVar1 != 0;
}


void daDarkStar_c::FUN_80a29280(){
  if (unk3 == 3) {
    return;
  }
  //EnItem_BindAnimation(this,3);
  return;
}


extern "C" int SomeStrangeModification(dStageActor_c* actor);
extern "C" float EnItem_GetZPosToUse(dEn_c* item);
extern "C" void FUN_80a28e00(dActor_c* item);
extern "C" void FUN_80a28d10(dActor_c* item);
extern "C" void FUN_80a29110(dActor_c* item);
extern "C" void FUN_80a286c0(dActor_c* item);

void daDarkStar_c::executeState_StarMove(){
  //bool bVar1;
  uint uVar3;
  bool bVar5;
  int iVar4;
  float fVar6;
  
  this->HandleYSpeed();
  this->doSpriteMovement();
  this->FUN_80a288d0();
  //FUN_80a28bb0(this);
  if (this->unk2 == 0) {
    uVar3 = SomeStrangeModification(this);
    FUN_80a28e00(this);
    if (uVar3 & 1) {
      if (this->isOnQuickSand == 0) {
        if (this->isImmersedInLiquid_maybe == 0) {
          this->speed.y = 4.0f;
        } else {
          this->speed.y = 2.0f;
        }
        FUN_80a28d10(this);
        this->FUN_80a29280();
		Vec2 soundPos;
        ConvertStagePositionToScreenPosition(&soundPos,&this->pos);
        SoundPlayingClass::instance2->PlaySoundAtPosition(SE_OBJ_STAR_BOUND,&soundPos,0);
      }
      /*if (*(char *)((int)&this[2]._.acState.ac1.statemgr.vtable + 3) == '\x01') {
        bVar1 = this->direction;
        *(undefined *)((int)&this[2]._.acState.ac1.statemgr.vtable + 3) = 2;
        this->speed.x = (this->direction ? -1.0f : 1.0f);
      }*/
    }
    if (uVar3 & 2) {
      this->speed.y = -2.0f;
    }
    if (uVar3 & 4) {
      this->direction ^= 1;
      this->speed.x = -this->speed.x;
    }
    FUN_80a29110(this);
    
    if (this->checksSomething()) {
      FUN_80a286c0(this);
      return;
    }
  }
  
  this->pos.z = EnItem_GetZPosToUse(this);
  iVar4 = 0;//FUN_80a282f0(this);
  if (iVar4 == 0) {
    //FUN_80a28770(this);
  }
  //FUN_80a28230(this);
  return;
}


void daDarkStar_c::endState_StarMove() {}
//
// processed\../src/eggblock.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
extern "C" void PlaySoundWithFunctionB4(void *spc, nw4r::snd::SoundHandle *handle, int id, int unk);


// Egg Block

class daEggBlock_c : public daEnBlockMain_c {
public:
	TileRenderer tile;
	Physics::Info physicsInfo;

	int wasIHit;
	int waitUntilNextDownMove;

	int onCreate();
	int onDelete();
	int onExecute();

	void calledWhenUpMoveExecutes();
	void calledWhenDownMoveExecutes();

	void blockWasHit(bool isDown);

	USING_STATES(daEggBlock_c);
	DECLARE_STATE(Wait);

	static dActor_c *build();
};


CREATE_STATE(daEggBlock_c, Wait);


int daEggBlock_c::onCreate() {
	this->pos.y -= 8;
	blockInit(pos.y);
	this->sub_80021740();

	physicsInfo.x1 = -8;
	physicsInfo.y1 = 16;
	physicsInfo.x2 = 8;
	physicsInfo.y2 = 0;

	physicsInfo.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
	physicsInfo.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
	physicsInfo.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.flagsMaybe = 0x260;
	physics.callback1 = &daEnBlockMain_c::PhysicsCallback1;
	physics.callback2 = &daEnBlockMain_c::PhysicsCallback2;
	physics.callback3 = &daEnBlockMain_c::PhysicsCallback3;
	physics.addToList();

	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->add(&tile);

	this->_68B = 1;
	physics._D8 &= ~0b00101000;

	this->wasIHit = 0.0f;
	this->pos.z = 200.0f;

	tile.x = pos.x - 8;
	tile.y = -(16 + pos.y);
	/*if((this->settings >> 24 & 0xF) == 0) {
		tile.tileNumber = 0x0; //0x0 is invisible, 0x30 is brick and 0x31 is question
	}
	if((this->settings >> 24 & 0xF) == 1) {
		tile.tileNumber = 0x30; //0x0 is invisible, 0x30 is brick and 0x31 is question
	}
	if((this->settings >> 24 & 0xF) == 2) {
		tile.tileNumber = 0x31; //0x0 is invisible, 0x30 is brick and 0x31 is question
	}*/
	switch(this->settings & 0xF) {
		case 0:
			tile.tileNumber = 0x8C;		//light blue
			break;

		case 1:
			tile.tileNumber = 0x8D;		//pink
			break;

		case 2:
			tile.tileNumber = 0x8E;		//yellow
			break;

		case 3:
			tile.tileNumber = 0x9C;		//green
			break;

		case 4:
			tile.tileNumber = 0x9D;		//blue
			break;

		case 5:
			tile.tileNumber = 0x9E;		//red
			break;

		case 6:
			tile.tileNumber = 0x9F;		//orange
			break;

		case 7:
			tile.tileNumber = 0xAC;		//brown
			break;

		case 8:
			tile.tileNumber = 0xAD;		//white
			break;

		case 9:
			tile.tileNumber = 0xAE;		//purple
			break;

		case 10:
		default:
			tile.tileNumber = 0xAF;		//all - rainbow
			break;
	}

	this->spriteSomeRectX = 6000.0f;

	doStateChange(&daEggBlock_c::StateID_Wait);

	return true;
}


int daEggBlock_c::onDelete() {
	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->remove(&tile);

	physics.removeFromList();

	return true;
}


int daEggBlock_c::onExecute() {
	acState.execute();
	physics.update();
	blockUpdate();

	tile.setPosition(pos.x-8, -(16+pos.y), pos.z);
	tile.setVars(scale.x);

	if (acState.getCurrentState()->isEqual(&StateID_Wait)) {
		checkZoneBoundaries(0);
	}

	return true;
}


dActor_c *daEggBlock_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daEggBlock_c));
	return new(buffer) daEggBlock_c;
}

const char *EggBlockFileList[] = {0};
const SpriteData EggBlockSpriteData = { ProfileId::EggBlock, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile EggBlockProfile(&daEggBlock_c::build, SpriteId::EggBlock, EggBlockSpriteData, ProfileId::EggBlock, ProfileId::EggBlock, "EggBlock", EggBlockFileList);


void daEggBlock_c::blockWasHit(bool isDown) {
	pos.y = initialY;
	int shroomSettings = isGroundPound ? 1 : 0;
	//dStageActor_c *PoisonMushroom = dStageActor_c::create(PoisonShroom, shroomSettings, &this->pos, 0, 0); //Creating Poison Mushroom
	//PoisonMushroom->pos.z = this->pos.z - 200;
	
	u32 set;
	/*switch(this->settings & 0b1111) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			set = 0x0B000000;
			break;
		default:
			break;
	}*/
	
	Vec eggPos = pos;
	eggPos.y += (isDown ? -8 : 8);
	
	u8 color = this->settings & 0xF;	//0 = light blue; 1 = pink; 2 = yellow; 3 = green; 4 = blue; 5 = red; 6 = orange; 7 = brown; 8 = white; 9 = purple.
	CreateActor(AC_YOSHI_EGG, /*set*/(color > 9 ? 0 : (u32)(1 << 21 | color)), &eggPos, 0, this->currentLayerID);
	
	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_PLY_YOSHI_EGG_APPEAR, 1);
	//this->wasIHit = 1;


	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.addToList();
	
	doStateChange(&StateID_Wait);
}



void daEggBlock_c::calledWhenUpMoveExecutes() {
	if (initialY >= pos.y)
		blockWasHit(false);
}

void daEggBlock_c::calledWhenDownMoveExecutes() {
	if (initialY <= pos.y)
		blockWasHit(true);
}



void daEggBlock_c::beginState_Wait() {
}

void daEggBlock_c::endState_Wait() {
}

void daEggBlock_c::executeState_Wait() {
	int result = blockResult();


	if (result == 0)
		return;

	OSReport("blockResult: %d\n", result);

	dAcPy_c *player = (dAcPy_c*)GetSpecificPlayerActor(0);
	OSReport("Flag: %d\n", player->testFlag(0x1E));

	if (result == 1) {
		
		doStateChange(&daEnBlockMain_c::StateID_UpMove);
		anotherFlag = 2;
		isGroundPound = false;
	} else {
		//if(waitUntilNextDownMove > 0) {
		//	waitUntilNextDownMove--;
		//} else {
			doStateChange(&daEnBlockMain_c::StateID_DownMove);
			anotherFlag |= 1;
			isGroundPound = true;
			physics._D8 &= ~0b00101000;
			//_660 = 8;
		//	waitUntilNextDownMove = 6;
		//}
	}
}
//
// processed\../src/soundtest.cpp
//

#include "soundtest.h"

dScSoundTest_c *dScSoundTest_c::instance = 0;

dScSoundTest_c *dScSoundTest_c::build() {
	// return new dScSoundTest_c;
	void *buffer = AllocFromGameHeap1(sizeof(dScSoundTest_c));
	dScSoundTest_c *c = new(buffer) dScSoundTest_c;

	instance = c;
	return c;
}



dScSoundTest_c::dScSoundTest_c() {
	layoutLoaded = false;
}

int dScSoundTest_c::onCreate() {
	*CurrentDrawFunc = WorldMapDrawFunc;

	if(!layoutLoaded) {
		if (!layout.loadArc("soundtest.arc", false))
			return false;

		static const char *brlanNames[4] = {
			"soundtest_asuAppear.brlan",
			"soundtest_upText.brlan",
			"soundtest_idleText.brlan",
			"soundtest_downText.brlan",
		};

		static const char *groupNames[4] = {
			"A00_asu", 
			"B00_textBox", "B00_textBox", "B00_textBox",
		};

		static const int groupIDs[4] = {
			0,
			1, 2, 3,
		};

		layout.build("soundtest.brlyt");

		layout.loadAnimations(brlanNames, 4);
		layout.loadGroups(groupNames, groupIDs, 4);
		layout.disableAllAnimations();

		// layout.drawOrder = 140;

		layoutLoaded = true;

		T_SFXTxt_00 = layout.findTextBoxByName("T_SFXTxt_00");
		T_SFXSha_00 = layout.findTextBoxByName("T_SFXSha_00");
		T_SFXNumTxt_00 = layout.findTextBoxByName("T_SFXNumTxt_00");
		T_SFXNumSha_00 = layout.findTextBoxByName("T_SFXNumSha_00");

		char sfxName[150];
		wchar_t text[150];
		sprintf(sfxName, "-> %s <-", sfxNames[this->selectedSFX]);
		mbstowcs(text, sfxName, 150);

		T_SFXTxt_00->SetString(text);
		T_SFXSha_00->SetString(text);
	}

	*CurrentDrawFunc = SoundTestDrawFunc;
	isVisible = true;

	return true;
}

int dScSoundTest_c::onDelete() {
	return layout.free();
}

extern void callSoundTestState(dScSoundTest_c* handler, u32 state);
extern "C" u32 GenerateRandomNumber(int max);

int dScSoundTest_c::onExecute() {
	int nowPressed = Remocon_GetPressed(GetActiveRemocon());

	// Let's get our shit started

	callSoundTestState(this, currentStateID);

	if(nowPressed & WPAD_A) {
		if(handles[currentSFXHandle].Exists()) {
			handles[currentSFXHandle].Stop(1);
		}
		currentSFXHandle = !currentSFXHandle;
		PlaySoundWithFunctionB4(SoundRelatedClass, &handles[currentSFXHandle], this->selectedSFX, 1);
	}

	if(nowPressed & WPAD_B) {
		if(handles[currentSFXHandle].Exists()) {
			handles[currentSFXHandle].Stop(1);
		}
	}

	if(nowPressed & WPAD_ONE) {
		this->finish();
	}

	if(!layout.isAnimOn(0)) {
		if(GenerateRandomNumber(18000) == 1) {
			layout.enableNonLoopAnim(0);
		}
	}
	
	layout.execAnimations();
	layout.update();

	return true;
}

void dScSoundTest_c::state0_whatever() {
	int nowPressed = Remocon_GetPressed(GetActiveRemocon());
	int nowHeld = Remocon_GetButtons(GetActiveRemocon());

	if(nowHeld & WPAD_PLUS || nowHeld & WPAD_MINUS) {
		layout.enableNonLoopAnim(1);
		currentStateID++;
		return;
	}

	if(nowPressed & WPAD_UP) {
		this->selectedSFX++;
		layout.enableNonLoopAnim(1);
		currentStateID++;
	}
	else if(nowPressed & WPAD_DOWN) {
		this->selectedSFX--;
		layout.enableNonLoopAnim(1);
		currentStateID++;
	}
}

void dScSoundTest_c::state1_whatever() {
	if (!layout.isAnimOn(1)) {
		int nowHeld = Remocon_GetButtons(GetActiveRemocon());
		if(!layout.isAnimOn(2)) {
			layout.enableNonLoopAnim(2);
		}

		if(nowHeld & WPAD_PLUS) {
			if(selectedSFX < 1977) {
				this->selectedSFX++;
			}
		}
		else if(nowHeld & WPAD_MINUS) {
			if(selectedSFX > 0) {
				this->selectedSFX--;
			}
		}
		else {
			layout.disableAnim(2);
			layout.enableNonLoopAnim(3);
			currentStateID++;
		}

		char sfxName[150];
		char sfxNum[150];
		wchar_t text[150];
		wchar_t number[150];
		sprintf(sfxName, "-> %s <-", sfxNames[this->selectedSFX]);
		sprintf(sfxNum, "%04d:", this->selectedSFX);
		mbstowcs(text, sfxName, 150);
		mbstowcs(number, sfxNum, 150);
		OSReport("set text to: %s\n", sfxName);

		T_SFXTxt_00->SetString(text);
		T_SFXSha_00->SetString(text);
		T_SFXNumTxt_00->SetString(number);
		T_SFXNumSha_00->SetString(number);
	}
}

void dScSoundTest_c::state2_whatever() {
	if (!layout.isAnimOn(3)) {
		currentStateID = 0;
	}
}

void dScSoundTest_c::state3_whatever() {

}

void dScSoundTest_c::state4_whatever() {

}

void dScSoundTest_c::state5_whatever() {

}

void dScSoundTest_c::state6_whatever() {

}

void dScSoundTest_c::state7_whatever() {
}

void dScSoundTest_c::state8_whatever() {

}




int dScSoundTest_c::onDraw() {
	if (isVisible) {
		layout.scheduleForDrawing();
	}

	return true;
}

void WorldMapDrawFunc();

void SoundTestDrawFunc() {
	Reset3DState();
	
	LinkScene(0);
	//DrawOpa();
	//DrawXlu();
	UnlinkScene(0);
	
	SetupLYTDrawing();
	DrawAllLayoutsBeforeX(0x81);
	RenderEffects(0, 3);
	RenderEffects(0, 2);
	GXDrawDone();
	RemoveAllFromScnRoot();
	Reset3DState();
	SetCurrentCameraID(1);
	DoSpecialDrawing1();
	
	LinkScene(1);
	DrawOpa();
	DrawXlu();
	UnlinkScene(1);
	
	SetCurrentCameraID(0);
	for (int i = 0; i < 4; i++)
		RenderEffects(0, 0xB+i);
	for (int i = 0; i < 4; i++)
		RenderEffects(0, 7+i);
	GXDrawDone();
	// Leaving out some stuff here
	DrawAllLayoutsAfterX(0x80);
	ClearLayoutDrawList();
	SetCurrentCameraID(0);
}

extern "C" u32 AssembleDefaultScWorldMapSettings();

void dScSoundTest_c::finish() {

	for (int i = 0; i < 2; i++)
		if (handles[i].Exists())
			handles[i].Stop(5);

	ActivateWipe(WIPE_FADE);
	DoSceneChange(WORLD_MAP, (AssembleDefaultScWorldMapSettings()), 0);
}


//
// processed\../src/parabones.cpp
//

#include <common.h>
#include <game.h>
#include <profile.h>
#include "path.h"

const char* paraBonesFileList[] = { "karon", "wing", 0 };


class daEnParaBones_c : public dEnPath_c {
public:
	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile resFileAnim;
	m3d::mdl_c bodyModel;

	nw4r::g3d::ResAnmTexPat anmPat;

	m3d::anmChr_c chrAnimation;
	m3d::anmTexPat_c patAnimation;

	bool leftRight;

	bool facingRight;
	u8 wSpeed;
	u8 wDistance;

	int stepCount;

	bool ranOnce;
	
	dEn_c* dryBone;

	static dActor_c* build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	void updateModelMatrices();
	void playerCollision(ActivePhysics* apThis, ActivePhysics* apOther);
	void yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther);

	bool collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther);
	//bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther);
	bool collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther);

	//setDeathInfo_IceBreak -> what should be done when in an iceblock and crashes a wall -> normally the sprite should die
	void _vf148();
	//setDeathInfo_IceVanish -> what should be done when collision with an iceblock thrown by Mario -> normally the sprite should die
	void _vf14C();
	//create an ice block when collided with Iceball
	bool CreateIceActors();

	//void addScoreWhenHit(void* other);
};

const SpriteData ParaBonesSpriteData = { ProfileId::ParaBones, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile ParaBonesProfile(&daEnParaBones_c::build, SpriteId::ParaBones, ParaBonesSpriteData, ProfileId::ParaBones, ProfileId::ParaBones, "ParaBones", paraBonesFileList);



u8 hijackMusicWithSongName(const char* songName, int themeID, bool hasFast, int channelCount, int trackCount, int* wantRealStreamID);

void daEnParaBones_c::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther) {
	char hitType;
	hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);

	if(hitType == 1) {	// regular jump
		apOther->someFlagByte |= 2;
		this->Delete(1);
	}
	else if(hitType == 3) {	// spinning jump or whatever?
		apOther->someFlagByte |= 2;
		this->Delete(1);
	}
	else if(hitType == 0) {
		EN_LandbarrelPlayerCollision(this, apThis, apOther);
		DamagePlayer(this, apThis, apOther);
	} else {
		DamagePlayer(this, apThis, apOther);
	}
}
void daEnParaBones_c::yoshiCollision(ActivePhysics* apThis, ActivePhysics* apOther) {}
bool daEnParaBones_c::collisionCat7_GroundPound(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnParaBones_c::collisionCat7_GroundPoundYoshi(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnParaBones_c::collisionCatD_Drill(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnParaBones_c::collisionCatA_PenguinMario(ActivePhysics* apThis, ActivePhysics* apOther) {
	if ((this->facingRight && apOther->owner->pos.x < this->pos.x) || (!this->facingRight && apOther->owner->pos.x > this->pos.x))
	{
		this->Delete(1);
		return true;
	}
	return false;
}

bool daEnParaBones_c::collisionCat1_Fireball_E_Explosion(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
/*bool daEnParaBones_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics* apThis, ActivePhysics* apOther) {

	return false;
}*/
bool daEnParaBones_c::collisionCat9_RollingObject(ActivePhysics* apThis, ActivePhysics* apOther) {
	return false;
}
bool daEnParaBones_c::collisionCat13_Hammer(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}
bool daEnParaBones_c::collisionCat14_YoshiFire(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}

bool daEnParaBones_c::collisionCat3_StarPower(ActivePhysics* apThis, ActivePhysics* apOther) {
	this->Delete(1);
	return true;
}


void daEnParaBones_c::_vf148() {
	dEn_c::_vf148();
}

void daEnParaBones_c::_vf14C() {
	dEn_c::_vf14C();
}

//this does weird shit, but it creates the iceblock around it
bool daEnParaBones_c::CreateIceActors() {
	struct DoSomethingCool my_struct = { 0, this->pos, {1.5, 2.0, 1.8}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	this->frzMgr.Create_ICEACTORs((void*)&my_struct, 1);
	__destroy_arr((void*)&my_struct, sub_80024C20, 0x3C, 1);
	//this->chrAnimation.setCurrentFrame(0.0);
	this->chrAnimation.setUpdateRate(0.0);
	//this->frozen = true;
	return true;
}


dActor_c* daEnParaBones_c::build() {
	void* buffer = AllocFromGameHeap1(sizeof(daEnParaBones_c));
	daEnParaBones_c* c = new(buffer) daEnParaBones_c;

	return c;
}


extern int getNybbleValue(u32 settings, int fromNybble, int toNybble);

void daEnParaBones_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate)
{
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daEnParaBones_c::onCreate() {
	if(!this->ranOnce) {
		this->ranOnce = true;
		return false;
	}
	
	this->deleteForever = false;

	dryBone = (dEn_c*)CreateActor(EN_KARON, 0, &pos, 0, this->currentLayerID);


	// Model creation	
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("wing", "g3d/wing.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("wing");
	bodyModel.setup(mdl, &allocator, 0x227, 1, 0);
	SetupTextures_Player(&bodyModel, 0);

	this->resFileAnim.data = getResource("wing", "g3d/wing.brres");
	nw4r::g3d::ResAnmChr anmChr = this->resFileAnim.GetResAnmChr("wing_pata");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();

	this->leftRight = settings >> 31 & 1;

	this->facingRight = settings >> 30 & 1;
	this->wDistance = settings >> 20 & 0b11111111;
	this->wSpeed = settings >> 16 & 0b1111;

	this->scale = (Vec){1, 1, 1};
	
	bindAnimChr_and_setUpdateRate("wing_pata", 1, 0.0, 1.0);

	if(this->leftRight) {
		doStateChange(&StateID_Wait);
	} else {
		beginState_Init();
		if (this->rotateNext) {
			if (this->stepVector.x > 0) {
				this->rot.y = 0x4000;
			} else {
				this->rot.y = -0x4000;
			}
		} else if (this->rotate0XNext) {
			this->rot.y = 0x0;
		}
		executeState_Init();
		doStateChange(&StateID_FollowPath);
	}
	
	
	this->onExecute();
	return true;
}


int daEnParaBones_c::onDelete() {
	nw4r::snd::SoundHandle handle;
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_EMY_DOWN, 1);
	StageE4::instance->spawnCoinJump(pos, 0, 1, 0);
	return true;
}

int daEnParaBones_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}


void daEnParaBones_c::updateModelMatrices() {
	matrix.translation(pos.x, pos.y+8, pos.z);
	matrix.applyRotationYXZ(&dryBone->rot.x, &dryBone->rot.y, &dryBone->rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

extern dStateBase_c daEnKanon_c__StateID_Walk;

int daEnParaBones_c::onExecute() {
	bodyModel._vf1C();
	updateModelMatrices();

	//OSReport("fr: %d, wD: %d, wS: %d, stepCount: %d\n", this->facingRight, this->wDistance, this->wSpeed, this->stepCount);


	acState.execute();
	
	if(dryBone->acState.getCurrentState() != &daEnKanon_c__StateID_Walk) {
		this->Delete(1);
	}
	
	/*if (this->stepsDone == this->stepCount) {
		if (this->rotateNext) {
			if (this->stepVector.x > 0) {
				dryBone->rot.y = 0x4000;
			} else {
				dryBone->rot.y = -0x4000;
			}
		} else if (this->rotate0XNext) {
			dryBone->rot.y = 0x0;
		}
	}*/
	
	dryBone->pos = this->pos;
	
	if (this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	return true;
}
//
// processed\../src/exclamationBlock.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>
#include <sfx.h>
extern "C" void PlaySoundWithFunctionB4(void *spc, nw4r::snd::SoundHandle *handle, int id, int unk);




/*
- direction
- length
- id
- sub id
- next block
*/



// Exclamation Block


class daExclamationBlock_c : public daEnBlockMain_c {
public:
	TileRenderer tile;
	TileRenderer tileList[16];
	Physics::Info physicsInfo;
	Physics physicsList[16];
	Physics::Info physicsInfoList[16];

	int z;
	//u8 direction;
	u8 maxLength;
	u8 blockId;
	u8 subId;
	u8 activatedLength;
	daExclamationBlock_c* next;

	bool ranOnce;

	int wasIHit;
	int waitUntilNextDownMove;
	
	int counter;

	int onCreate();
	int onDelete();
	int onExecute();

	void calledWhenUpMoveExecutes();
	void calledWhenDownMoveExecutes();

	void blockWasHit(bool isDown);
	
	bool activateEntirely;
	u8 activateEntirelyDelay;
	
	void activateOne();
	bool testOne();
	void deactivate();
	void switchMainPhysics(bool activate);

	USING_STATES(daExclamationBlock_c);
	DECLARE_STATE(Wait);

	static dActor_c *build();
};


CREATE_STATE(daExclamationBlock_c, Wait);


void daExclamationBlock_c::activateOne() {
	if (activatedLength < maxLength) {
		TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
		list->add(&tileList[activatedLength]);
		physicsList[activatedLength].addToList();
		activatedLength += 1;
	} else {
		if (next) {
			next->activateOne();
		}
	}
}

void daExclamationBlock_c::deactivate() {
	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	for (int i = 0; i < activatedLength; i++) {
		list->remove(&tileList[i]);
		physicsList[i].removeFromList();
	}
	activatedLength = 0;
	if (next) {
		next->deactivate();
	}
}

bool daExclamationBlock_c::testOne() {
	if (activatedLength < maxLength) {
		return true;
	} else {
		if (next) {
			return next->testOne();
		} else {
			return false;
		}
	}
}



int daExclamationBlock_c::onCreate() {
	direction = (this->settings & 0xF) % 4;
	maxLength = this->settings >> 4 & 0xF;
	blockId = this->settings >> 8 & 0xFF;
	subId = this->settings >> 16 & 0xFF;
	
	if (!ranOnce) {
		ranOnce = true;
		return false;
	}
	this->pos.y -= 8;
	blockInit(pos.y);
	this->sub_80021740();

	for (int i = 0; i < maxLength; i++) {
		physicsInfoList[i].x1 = -8;
		physicsInfoList[i].y1 = 16;
		physicsInfoList[i].x2 = 8;
		physicsInfoList[i].y2 = 0;

		switch(direction) {
			case 0:
				physicsInfoList[i].x1 += (i+1)*16;
				physicsInfoList[i].x2 += (i+1)*16;
				break;
			case 1:
				physicsInfoList[i].y1 -= (i+1)*16;
				physicsInfoList[i].y2 -= (i+1)*16;
				break;
			case 2:
				physicsInfoList[i].x1 -= (i+1)*16;
				physicsInfoList[i].x2 -= (i+1)*16;
				break;
			case 3:
				physicsInfoList[i].y1 += (i+1)*16;
				physicsInfoList[i].y2 += (i+1)*16;
				break;
			default:
				break;			
		}

		physicsInfoList[i].otherCallback1 = (void*)&PhysCB1;
		physicsInfoList[i].otherCallback2 = (void*)&PhysCB2;
		physicsInfoList[i].otherCallback3 = (void*)&PhysCB3;

		physicsList[i].setup(this, &physicsInfoList[i], 3, currentLayerID);
		physicsList[i].flagsMaybe = 0x260;
		physicsList[i].callback1 = (void*)&PhysCB4;
		physicsList[i].callback2 = (void*)&PhysCB5;
		physicsList[i].callback3 = (void*)&PhysCB6;
	}


	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	

	
	this->wasIHit = 0.0f;
	this->pos.z = 200.0f;

	tile.x = pos.x - 8;
	tile.y = -(16 + pos.y);
	/*if((this->settings >> 24 & 0xF) == 0) {
		tile.tileNumber = 0x0; //0x0 is invisible, 0x30 is brick and 0x31 is question
	}
	if((this->settings >> 24 & 0xF) == 1) {
		tile.tileNumber = 0x30; //0x0 is invisible, 0x30 is brick and 0x31 is question
	}
	if((this->settings >> 24 & 0xF) == 2) {
		tile.tileNumber = 0x31; //0x0 is invisible, 0x30 is brick and 0x31 is question
	}*/
	
	if (this->subId == 0) {
		this->_68B = 1;
		physics._D8 &= ~0b00101000;

		tile.tileNumber = 0x31;
		list->add(&tile);
		
		physicsInfo.x1 = -8;
		physicsInfo.y1 = 16;
		physicsInfo.x2 = 8;
		physicsInfo.y2 = 0;

		physicsInfo.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
		physicsInfo.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
		physicsInfo.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;

		physics.setup(this, &physicsInfo, 3, currentLayerID);
		physics.flagsMaybe = 0x260;
		physics.callback1 = &daEnBlockMain_c::PhysicsCallback1;
		physics.callback2 = &daEnBlockMain_c::PhysicsCallback2;
		physics.callback3 = &daEnBlockMain_c::PhysicsCallback3;
		physics.addToList();
	}
	
	for (int i = 0; i < maxLength; i++) {
		tileList[i].x = pos.x - 8;
		tileList[i].y = -(16 + pos.y);
		tileList[i].tileNumber = 0x32;
		
		switch(direction) {
			case 0:
				tileList[i].x += (i+1)*16;
				break;
			case 1:
				tileList[i].y += (i+1)*16;
				break;
			case 2:
				tileList[i].x -= (i+1)*16;
				break;
			case 3:
				tileList[i].y -= (i+1)*16;
				break;
			default:
				break;
		}
	}
	
	daExclamationBlock_c *blockIter = 0;
	while (blockIter = (daExclamationBlock_c*)dEn_c::search(ExclamationBlock, blockIter)) {
		if (blockIter->blockId == this->blockId) {
			if (blockIter->subId == this->subId+1) {
				OSReport("id: %d, sub: %d\n", blockIter->blockId, blockIter->subId);
				this->next = blockIter;
			}
		}
	}

	this->spriteSomeRectX = 6000.0f;

	doStateChange(&daExclamationBlock_c::StateID_Wait);

	return true;
}


int daExclamationBlock_c::onDelete() {
	TileRenderer::List *list = dBgGm_c::instance->getTileRendererList(0);
	list->remove(&tile);
	for (int i = 0; i < activatedLength; i++) {
		list->remove(&tileList[i]);
		physicsList[i].removeFromList();
	}

	physics.removeFromList();

	return true;
}

void daExclamationBlock_c::switchMainPhysics(bool activate) {
	if (activate) {
		physics.callback1 = &daEnBlockMain_c::PhysicsCallback1;
		physics.callback2 = &daEnBlockMain_c::PhysicsCallback2;
		physics.callback3 = &daEnBlockMain_c::PhysicsCallback3;
		
		physics.otherCallback1 = &daEnBlockMain_c::OPhysicsCallback1;
		physics.otherCallback2 = &daEnBlockMain_c::OPhysicsCallback2;
		physics.otherCallback3 = &daEnBlockMain_c::OPhysicsCallback3;
	} else {
		physics.otherCallback1 = (void*)&PhysCB1;
		physics.otherCallback2 = (void*)&PhysCB2;
		physics.otherCallback3 = (void*)&PhysCB3;

		physics.callback1 = (void*)&PhysCB4;
		physics.callback2 = (void*)&PhysCB5;
		physics.callback3 = (void*)&PhysCB6;
	}
}

int daExclamationBlock_c::onExecute() {
	acState.execute();
	physics.update();
	blockUpdate();

	tile.setPosition(pos.x-8, -(16+pos.y), pos.z);
	tile.setVars(scale.x);

	if(subId == 0 && activateEntirely) {
		if(activateEntirelyDelay < 2) {
			activateEntirelyDelay++;
		} else {
			if(testOne()) {
				activateOne();
			} else {
				tile.tileNumber = 0x32;
				activateEntirely = false;
				
				switchMainPhysics(false);
			}
			activateEntirelyDelay = 0;
		}
	}


	if (subId == 0 && activatedLength != 0) {		
		if (counter >= 600) {
			deactivate();
			tile.tileNumber = 0x31;
			switchMainPhysics(true);
			counter = 0;
		} else {
			counter++;
		}
	} else {
		counter = 0;
	}

	if (acState.getCurrentState()->isEqual(&StateID_Wait)) {
		checkZoneBoundaries(0);
	}

	return true;
}


dActor_c *daExclamationBlock_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daExclamationBlock_c));
	return new(buffer) daExclamationBlock_c;
}

const char *ExclamationBlockFileList[] = {0};
const SpriteData ExclamationBlockSpriteData = { ProfileId::ExclamationBlock, 8, -8 , 0 , 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile ExclamationBlockProfile(&daExclamationBlock_c::build, SpriteId::ExclamationBlock, ExclamationBlockSpriteData, ProfileId::ExclamationBlock, ProfileId::ExclamationBlock, "ExclamationBlock", ExclamationBlockFileList);


void daExclamationBlock_c::blockWasHit(bool isDown) {
	pos.y = initialY;
	
	if(isDown) {
		activateEntirely = true;
		activateEntirelyDelay = 0;
	}
	
	activateOne();
	if (!testOne()) {
		tile.tileNumber = 0x32;
	}


	physics.setup(this, &physicsInfo, 3, currentLayerID);
	physics.addToList();
	
	doStateChange(&StateID_Wait);
}



void daExclamationBlock_c::calledWhenUpMoveExecutes() {
	if (initialY >= pos.y)
		blockWasHit(false);
}

void daExclamationBlock_c::calledWhenDownMoveExecutes() {
	if (initialY <= pos.y)
		blockWasHit(true);
}



void daExclamationBlock_c::beginState_Wait() {
}

void daExclamationBlock_c::endState_Wait() {
}

void daExclamationBlock_c::executeState_Wait() {
	int result = blockResult();


	if (result == 0)
		return;

	OSReport("blockResult: %d\n", result);

	dAcPy_c *player = (dAcPy_c*)GetSpecificPlayerActor(0);
	OSReport("Flag: %d\n", player->testFlag(0x1E));

	if (result == 1) {
		
		doStateChange(&daEnBlockMain_c::StateID_UpMove);
		anotherFlag = 2;
		isGroundPound = false;
	} else {
		//if(waitUntilNextDownMove > 0) {
		//	waitUntilNextDownMove--;
		//} else {
			doStateChange(&daEnBlockMain_c::StateID_DownMove);
			anotherFlag |= 1;
			isGroundPound = true;
			physics._D8 &= ~0b00101000;
			//_660 = 8;
		//	waitUntilNextDownMove = 6;
		//}
	}
}
//
// processed\../src/cloudpropeller.cpp
//

#include <game.h>
#include <sfx.h>

const char* CPArcNameList [] = { "cloudpropeller", NULL };

class daCloudPropeller : public dEn_c {
public:

	int onCreate();
	int onExecute();
	int onDelete();
	int onDraw();


	void LoadModel(int id);
	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);

	static dActor_c* build();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void spriteCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	ActivePhysics bPhysics;

	int horizontalvertical; //0 = horizontal, ...
	int leftright; //0 = left, 1 = right
	double speed;
	double sizeofwind;
	double n;
	double m;
	double x;
	double y;

	mHeapAllocator_c allocator;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c animationChr;
	nw4r::g3d::ResFile resFile;

};


void daCloudPropeller::LoadModel(int id)
{
	nw4r::g3d::ResMdl mdl;

	if (id == 1)
	{
		resFile.data = getResource("cloudpropeller", "g3d/propeller1.brres");
		mdl = this->resFile.GetResMdl("KoopaShip");
		bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
		SetupTextures_MapObj(&bodyModel, 0);
	}

	else if (id == 2)
	{
		resFile.data = getResource("cloudpropeller", "g3d/propeller2.brres");
		mdl = this->resFile.GetResMdl("KoopaShip");
		bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
		SetupTextures_MapObj(&bodyModel, 0);
	}

	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("rotate");
	this->animationChr.setup(mdl, anmChr, &this->allocator, 0);

	return;
}


void daCloudPropeller::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->animationChr.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->animationChr, unk2);
	this->animationChr.setUpdateRate(rate);
}

dActor_c* daCloudPropeller::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daCloudPropeller));
	return new(buffer) daCloudPropeller;
}

const SpriteData CloudPropellerSpriteData = 
{ ProfileId::CloudPropeller, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };

Profile CloudPropellerProfile(&daCloudPropeller::build, SpriteId::CloudPropeller, CloudPropellerSpriteData, ProfileId::CloudPropeller, ProfileId::CloudPropeller, "CloudPropeller", CPArcNameList);

void daCloudPropeller::spriteCollision(ActivePhysics* apThis, ActivePhysics* apOther)
{
	
	if (apOther->owner->name == AC_WATER_BUBBLE_CANNON)
	{
		if (((daBoomerangHax_c*)apOther->owner)->variation == 4)
		{
			//FINALLY move cloud
			if (horizontalvertical == 0)
			{
				x = abs(pos.x - apOther->owner->pos.x);
				y = m*x+n;
				if (leftright == 0)
				{
					apOther->owner->pos.x -= y;
				}
				else
				{
					apOther->owner->pos.x += y;
				}
			}
			else
			{
				x = abs(pos.y - apOther->owner->pos.y);
				y = m*x+n;
				apOther->owner->pos.y += y;
			}
		}
	}
	
	return;

}

void daCloudPropeller::playerCollision(ActivePhysics* apThis, ActivePhysics* apOther)
{
	this->_vf220(apOther->owner);
}






int daCloudPropeller::onCreate() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	OSReport("daCloudPropeller init\n");

	if (settings >> 16 & 1) //Vertical
	{
		LoadModel(1);
		horizontalvertical = 1;
	}
	else //Horizontal
	{
		LoadModel(2);

		horizontalvertical = 0;

		if (settings >> 31 & 1)
		{
			leftright = 1;
		} 
		else 
		{
			leftright = 0;
		}
	}

	/*
	resFile.data = getResource("cloudpropeller", "g3d/propeller2.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("KoopaShip");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_MapOBJ(&bodyModel, 0);
	*/


	allocator.unlink(); 

	sizeofwind = (settings >> 20 & 0b111111) * 8;
	speed = (settings >> 8 & 0b1111) / 10.0;

	ActivePhysics::Info HitMeBaby; 

	if (horizontalvertical == 0)
	{
		if (leftright == 0) { HitMeBaby.xDistToCenter = -sizeofwind + 16;  }
		else { HitMeBaby.xDistToCenter = sizeofwind; }
		HitMeBaby.yDistToCenter = 0.0; 
		HitMeBaby.xDistToEdge = sizeofwind; 
		HitMeBaby.yDistToEdge = 64.0; 
		HitMeBaby.category1 = 0x3; 
		HitMeBaby.category2 = 0x0; 
		HitMeBaby.bitfield1 = 0x8; 
		HitMeBaby.bitfield2 = 0xFFC00000; 
		HitMeBaby.unkShort1C = 0; 
		HitMeBaby.callback = &dEn_c::collisionCallback; 
		this->aPhysics.initWithStruct(this, &HitMeBaby); 
		this->aPhysics.addToList();
		this->pos.y -= 8;
		this->scale.x = 0.5;
		this->scale.y = 0.5;
		this->scale.z = 0.5;
	}
	else
	{
		HitMeBaby.xDistToCenter = 0.0;
		HitMeBaby.yDistToCenter = sizeofwind; 
		HitMeBaby.xDistToEdge = 64.0; 
		HitMeBaby.yDistToEdge = sizeofwind; 
		HitMeBaby.category1 = 0x3; 
		HitMeBaby.category2 = 0x0; 
		HitMeBaby.bitfield1 = 0x8; 
		HitMeBaby.bitfield2 = 0xFFC00000; 
		HitMeBaby.unkShort1C = 0; 
		HitMeBaby.callback = &dEn_c::collisionCallback; 
		this->aPhysics.initWithStruct(this, &HitMeBaby); 
		this->aPhysics.addToList();

		this->scale.x = 0.3;
		this->scale.y = 0.3;
		this->scale.z = 0.3;
	}

	
	if (horizontalvertical == 0)
	{
		if (leftright == 0)
		{
			this->rot.y = 0x4000;
			matrix.translation(pos.x + 54, pos.y, pos.z);
		}
		else
		{
			this->rot.y = -(0x4000);
			matrix.translation(pos.x - 38, pos.y, pos.z);
		}
	}
	else
	{
		this->rot.y = 0x4000;
		matrix.translation(pos.x, pos.y + 8.0, pos.z);
	}
	bindAnimChr_and_setUpdateRate("rotate", 1, 0.0, 1.0);
	
	
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);
	
	//PlaySound(this, SE_DEMO_OP_SHIP_PROPELLER_1511f);
	PlaySoundWithFunctionB4(SoundRelatedClass, &handle, SE_AMB_SHIP_WIND, 1);
	
	n=2*speed;
	m=-n/(2 * sizeofwind);

	ActivePhysics::Info HitMePropeller;

	if (horizontalvertical == 0)
	{
		HitMePropeller.xDistToCenter = 8.0;
		HitMePropeller.yDistToCenter = 0.0; 
		HitMePropeller.xDistToEdge = 8.0; 
		HitMePropeller.yDistToEdge = 16.0; 
		HitMePropeller.category1 = 0x3; 
		HitMePropeller.category2 = 0x0; 
		HitMePropeller.bitfield1 = 0x1; 
		HitMePropeller.bitfield2 = 0xFFC00000; 
		HitMePropeller.unkShort1C = 0; 
		HitMePropeller.callback = &dEn_c::collisionCallback; 
		this->bPhysics.initWithStruct(this, &HitMePropeller); 
		this->bPhysics.addToList(); 
	}
	else 
	{
		HitMePropeller.xDistToCenter = 0.0;
		HitMePropeller.yDistToCenter = 8.0; 
		HitMePropeller.xDistToEdge = 18.0; 
		HitMePropeller.yDistToEdge = 6.0; 
		HitMePropeller.category1 = 0x3; 
		HitMePropeller.category2 = 0x0; 
		HitMePropeller.bitfield1 = 0x1; 
		HitMePropeller.bitfield2 = 0xFFC00000; 
		HitMePropeller.unkShort1C = 0; 
		HitMePropeller.callback = &dEn_c::collisionCallback; 
		this->bPhysics.initWithStruct(this, &HitMePropeller); 
		this->bPhysics.addToList(); 
	}


	this->onExecute();

	return true;
}

int daCloudPropeller::onExecute() {

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);


	bodyModel._vf1C();

	if (this->animationChr.isAnimationDone()) {
		this->animationChr.setCurrentFrame(0.0);
	}

	return true;
}

int daCloudPropeller::onDelete() {
	return true;
}

int daCloudPropeller::onDraw() {
	bodyModel.scheduleForDrawing();

	return true;
}
//
// processed\../src/blueShell.cpp
//

#include <game.h>
#include "daEnShell_c.h"
#include <common.h>
#include <g3dhax.h>
#include <sfx.h>
#include <profile.h>

class daNakedNokonoko_c : public dEn_c {
public:
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	nw4r::g3d::ResFile anmFile;

	m3d::mdl_c bodyModel;
	m3d::anmChr_c chrAnimation;
	mEf::es2 effect;

	int timer;
	int type;
	float dying;
	float Baseline;
	char damage;
	char isDown;
	Vec initialPos;
	int distance;
	float XSpeed;
	u32 cmgr_returnValue;
	bool isBouncing;
	int directionStore;
	
	int appearTimer;
	
	bool foundMyShell;
	u32 shellId;
	daEnShell_c* shell;

	public: static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();
	bool calculateTileCollisions();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	void yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther);

	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther);

	void powBlockActivated(bool isNotMPGP);

	void _vf148();
	void _vf14C();
	bool CreateIceActors();
	void addScoreWhenHit(void *other);
	void bouncePlayerWhenJumpedOn(void *player);

	void spawnHitEffectAtPosition(Vec2 pos);
	void doSomethingWithHardHitAndSoftHitEffects(Vec pos);
	void playEnemyDownSound2();
	void playHpdpSound1(); // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
	void playEnemyDownSound1();
	void playEnemyDownComboSound(void *player); // AcPy_c/daPlBase_c?
	void playHpdpSound2(); // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
	void _vf260(void *other); // AcPy/PlBase? plays the SE_EMY_FUMU_%d sounds based on some value
	void _vf264(dStageActor_c *other); // if other is player or yoshi, do Wm_en_hit and a few other things
	void _vf268(void *other); // AcPy/PlBase? plays the SE_EMY_DOWN_SPIN_%d sounds based on some value
	void _vf278(void *other); // AcPy/PlBase? plays the SE_EMY_YOSHI_FUMU_%d sounds based on some value

	USING_STATES(daNakedNokonoko_c);
	DECLARE_STATE(Appear);
	DECLARE_STATE(Appear2);
	DECLARE_STATE(Appear3);
	DECLARE_STATE(Appear4);
	DECLARE_STATE(Search);
	DECLARE_STATE(RealWalk);
	DECLARE_STATE(RealTurn);
	DECLARE_STATE(Die);
};


/*
- make sure no walking sounds can be heard
- only take damage when shell is destroyed
- add check that the shell pointers are valid
- fix rotate on wall collision
- prevent players from making damage to controlled shells?


*/


#define MIN_SHELL_SPEED 2.0f
#define MAX_SHELL_SPEED 4.5f
#define CHG_SHELL_SPEED 0.025f

CREATE_STATE(daPlBase_c, ShellConnect);

u32 blueShells[4];	//blue shell pointers
int blueShellTimers[4];		//blue shell timers

void daPlBase_c::beginState_ShellConnect() {
	this->setFlag(0xBB);	//makes invisible
	//this->setFlag(0x25);	//propeller indicator?
	//this->aPhysics.removeFromList();
	//ActivePhysics* ap1 = (ActivePhysics*)((int)this+4452);
	//ActivePhysics* ap1 = (ActivePhysics*)((int)this+4452);
	//this->setFlag(0x71);
	this->useDemoControl();
	blueShellTimers[this->settings % 4] = 0;
	daEnShell_c* shell = (daEnShell_c*)fBase_c::search(blueShells[this->settings % 4]);
	shell->speed.x = MIN_SHELL_SPEED + abs(this->speed.x / 2);
	if(shell->speed.x > MAX_SHELL_SPEED) {
		shell->speed.x = MAX_SHELL_SPEED;
	}
	if(this->rot.y < 0) {
		shell->speed.x *= -1;
	}
	shell->doStateChange(&daEnShell_c::StateID_Slide);
}

void daPlBase_c::executeState_ShellConnect(){
	daEnShell_c* shell = (daEnShell_c*)fBase_c::search(blueShells[this->settings % 4]);
	if (shell == 0) {
		((dAcPy_c*)this)->hurtPlayer_maybe(); //not sure whether this works - ghidra says this should get 2 more arguments
		this->states2.setState(&daPlBase_c::StateID_Jump);
		return;
	}
	Vec bindPos = shell->pos;
	bindPos.y -= 4;
	this->pos = bindPos;
	
	if(blueShellTimers[this->settings % 4] < 90) {
		blueShellTimers[this->settings % 4]++;
	} else {
		Remocon* con = GetRemoconMng()->controllers[this->settings % 4];
		if(con->isShaking != 0) {
			this->states2.setState(&daPlBase_c::StateID_Jump);
			shell->Delete(1);
		}
		
		if(con->nowPressed & WPAD_TWO && shell->collMgr.isOnTopOfTile()) { //add is on ground check here
			shell->speed.y = 6.0f;
		}
		
		if(con->heldButtons & WPAD_LEFT) {
			if(shell->speed.x > 0) {
				if(shell->speed.x > MIN_SHELL_SPEED) {
					shell->speed.x -= CHG_SHELL_SPEED;
				}
			} else {
				if(shell->speed.x > -MAX_SHELL_SPEED) {
					shell->speed.x -= CHG_SHELL_SPEED;
				}
			}
		}

		if(con->heldButtons & WPAD_RIGHT) {
			if(shell->speed.x > 0) {
				if(shell->speed.x < MAX_SHELL_SPEED) {
					shell->speed.x += CHG_SHELL_SPEED;
				}
			} else {
				if(shell->speed.x < -MIN_SHELL_SPEED) {
					shell->speed.x += CHG_SHELL_SPEED;
				}				
			}
		}

	}
}

void daPlBase_c::endState_ShellConnect() {
	this->clearFlag(0xBB);
	//this->clearFlag(0x71);
	this->disableDemoControl();
}



extern "C" dStageActor_c *Actor_SearchByID(u32 actorID);
void setPlayerStateBlueShell(dAcPy_c* player) {			//setPlayerStateBlueShell__FP7dAcPy_c
	dStageActor_c* carrying = Actor_SearchByID(*(u32*)((u32)(player)+0x2A78)); //Actor_SearchByID(player->idWeAreCarrying)
	//OSReport("ID: %d, Pointer: %p, Name: %d\n", player->idWeAreCarrying, carrying, carrying->name);
	if (carrying->name == 54 || carrying->name == 55) {	//if Koopa or Parakoopa Shell
		blueShells[player->settings % 4] = carrying->id;
		player->states2.setState(&daPlBase_c::StateID_ShellConnect);
		Vec spawnPos = player->pos;
		spawnPos.x += 10;
		daNakedNokonoko_c* nokonokoN = (daNakedNokonoko_c*)CreateActor(NakedNokonoko, 0, spawnPos, 0, 0);
		nokonokoN->speed.x = player->speed.x*2;
		nokonokoN->direction = player->direction;
		nokonokoN->shellId = carrying->id;
		if(player->direction == 0) {
			if(nokonokoN->speed.x < 2) {
				nokonokoN->speed.x = 2;
			}
		} else {
			if(nokonokoN->speed.x > -2) {
				nokonokoN->speed.x = -2;
			}
		}
		nokonokoN->speed.y = 3;
	}
}
















const char* NakedNokonokoFileList [] = {
	"nokonokoA",
	NULL	
};

const SpriteData NakedNokonokoSpriteData = {ProfileId::NakedNokonoko, 0x5, -0x31, 0, 0x10, 0x10, 0x40, 0x40, 0x40, 0, 0, 0};
Profile NakedNokonokoProfile(&daNakedNokonoko_c::build, SpriteId::NakedNokonoko, NakedNokonokoSpriteData, ProfileId::NakedNokonoko, ProfileId::NakedNokonoko, "Naked Nokonoko", NakedNokonokoFileList);

dActor_c *daNakedNokonoko_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daNakedNokonoko_c));
	return new(buffer) daNakedNokonoko_c;
}

///////////////////////
// Externs and States
///////////////////////
extern "C" bool SpawnEffect(const char*, int, Vec*, S16Vec*, Vec*);

//FIXME make this dEn_c->used...
extern "C" char usedForDeterminingStatePress_or_playerCollision(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther, int unk1);
extern "C" int SomeStrangeModification(dStageActor_c* actor);
extern "C" void DoStuffAndMarkDead(dStageActor_c *actor, Vec vector, float unk);
extern "C" int SmoothRotation(short* rot, u16 amt, int unk2);

// Collision related
extern "C" void BigHanaPlayer(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" void BigHanaYoshi(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" bool BigHanaWeirdGP(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" bool BigHanaGroundPound(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" bool BigHanaFireball(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);
extern "C" bool BigHanaIceball(dEn_c* t, ActivePhysics *apThis, ActivePhysics *apOther);

extern "C" void dAcPy_vf3F8(void* player, dEn_c* monster, int t);

CREATE_STATE(daNakedNokonoko_c, Appear);
CREATE_STATE(daNakedNokonoko_c, Appear2);
CREATE_STATE(daNakedNokonoko_c, Appear3);
CREATE_STATE(daNakedNokonoko_c, Appear4);
CREATE_STATE(daNakedNokonoko_c, Search);
CREATE_STATE(daNakedNokonoko_c, RealWalk);
CREATE_STATE(daNakedNokonoko_c, RealTurn);
CREATE_STATE(daNakedNokonoko_c, Die);

////////////////////////
// Collision Functions
////////////////////////

void daNakedNokonoko_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) { 
	apOther->someFlagByte |= 2;

	dStageActor_c *player = apOther->owner;

	char hitType;
	hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);
	if (hitType > 0) {
		PlaySound(this, SE_EMY_CMN_STEP);
		this->counter_504[apOther->owner->which_player] = 0xA;
	} else {
		this->dEn_c::playerCollision(apThis, apOther);
		this->_vf220(apOther->owner);
		if (Player_VF3D4(player)) {
			// WE'VE GOT A STAR, FOLKS
			if (apThis->_18 == 1 && !player->collMgr.isOnTopOfTile() && player->pos.y > apThis->bottom()) {
				bouncePlayer(player, 3.0f);
				PlaySound(this, SE_EMY_CMN_STEP);
			} else {
				dAcPy_vf3F8(player, this, 3);
			}
			this->counter_504[apOther->owner->which_player] = 0xA;

		}
	} 
}			
void daNakedNokonoko_c::_vf278(void *other) {
	PlaySound(this, SE_EMY_HANACHAN_STOMP);
}

void daNakedNokonoko_c::bouncePlayerWhenJumpedOn(void *player) {
	bouncePlayer(player, 5.0f);
}

void daNakedNokonoko_c::yoshiCollision(ActivePhysics *apThis, ActivePhysics *apOther) {
	this->playerCollision(apThis, apOther);
}
bool daNakedNokonoko_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaWeirdGP(this, apThis, apOther);
}
bool daNakedNokonoko_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaGroundPound(this, apThis, apOther);
}
bool daNakedNokonoko_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaGroundPound(this, apThis, apOther);
}

bool daNakedNokonoko_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) {
	apOther->owner->kill();
	return true;
}
bool daNakedNokonoko_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther){
	dAcPy_vf3F8(apOther->owner, this, 3);
	this->counter_504[apOther->owner->which_player] = 0xA;
	return true;
}
bool daNakedNokonoko_c::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther){
	return true;
}
bool daNakedNokonoko_c::collisionCat11_PipeCannon(ActivePhysics *apThis, ActivePhysics *apOther){
	return true;
}
bool daNakedNokonoko_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true;
}
bool daNakedNokonoko_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther){
	/*int hitType = usedForDeterminingStatePress_or_playerCollision(this, apThis, apOther, 0);
	if (hitType == 1 || hitType == 3) {
		PlaySound(this, SE_EMY_CMN_STEP);
		bouncePlayerWhenJumpedOn(apOther->owner);
	} else {
		dAcPy_vf3F8(apOther->owner, this, 3);
	}

	this->counter_504[apOther->owner->which_player] = 0xA;
	return true;*/
	return false;
}

bool daNakedNokonoko_c::collisionCat14_YoshiFire(ActivePhysics *apThis, ActivePhysics *apOther){
	return BigHanaFireball(this, apThis, apOther);
}
bool daNakedNokonoko_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaFireball(this, apThis, apOther);
}
bool daNakedNokonoko_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) {
	return BigHanaIceball(this, apThis, apOther);
}

// These handle the ice crap
void daNakedNokonoko_c::_vf148() {
	dEn_c::_vf148();
	doStateChange(&StateID_Die);
}
void daNakedNokonoko_c::_vf14C() {
	dEn_c::_vf14C();
	doStateChange(&StateID_Die);
}

extern "C" void sub_80024C20(void);
extern "C" void __destroy_arr(void*, void(*)(void), int, int);

bool daNakedNokonoko_c::CreateIceActors() {
	struct DoSomethingCool my_struct = { 0, this->pos, {2.4, 3.0, 3.0}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
	this->frzMgr.Create_ICEACTORs( (void*)&my_struct, 1 );
	__destroy_arr( (void*)&my_struct, sub_80024C20, 0x3C, 1 );
	return true;
}

void daNakedNokonoko_c::addScoreWhenHit(void *other) { }

void daNakedNokonoko_c::spawnHitEffectAtPosition(Vec2 pos) { }
void daNakedNokonoko_c::doSomethingWithHardHitAndSoftHitEffects(Vec pos) { }
void daNakedNokonoko_c::playEnemyDownSound2() { }
void daNakedNokonoko_c::playHpdpSound1() { } // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
void daNakedNokonoko_c::playEnemyDownSound1() { }
void daNakedNokonoko_c::playEnemyDownComboSound(void *player) { } // AcPy_c/daPlBase_c?
void daNakedNokonoko_c::playHpdpSound2() { } // plays PLAYER_SE_EMY/GROUP_BOOT/SE_EMY_DOWN_HPDP_S or _H
void daNakedNokonoko_c::_vf260(void *other) { } // AcPy/PlBase? plays the SE_EMY_FUMU_%d sounds based on some value
void daNakedNokonoko_c::_vf264(dStageActor_c *other) { } // if other is player or yoshi, do Wm_en_hit and a few other things
void daNakedNokonoko_c::_vf268(void *other) { } // AcPy/PlBase? plays the SE_EMY_DOWN_SPIN_%d sounds based on some value

void daNakedNokonoko_c::powBlockActivated(bool isNotMPGP) {
}

bool daNakedNokonoko_c::calculateTileCollisions() {
	// Returns true if sprite should turn, false if not.

	HandleXSpeed();
	HandleYSpeed();
	doSpriteMovement();

	cmgr_returnValue = collMgr.isOnTopOfTile();
	collMgr.calculateBelowCollisionWithSmokeEffect();

	if (isBouncing) {
		stuffRelatingToCollisions(0.1875f, 1.0f, 0.5f);
		if (speed.y != 0.0f)
			isBouncing = false;
	}

	float xDelta = pos.x - last_pos.x;
	if (xDelta >= 0.0f)
		direction = 0;
	else
		direction = 1;

	if (collMgr.isOnTopOfTile()) {
		// Walking into a tile branch

		if (cmgr_returnValue == 0)
			isBouncing = true;

		if (speed.x != 0.0f) {
			//playWmEnIronEffect();
		}

		speed.y = 0.0f;

		// u32 blah = collMgr.s_80070760();
		// u8 one = (blah & 0xFF);
		// static const float incs[5] = {0.00390625f, 0.0078125f, 0.015625f, 0.0234375f, 0.03125f};
		// x_speed_inc = incs[one];
		max_speed.x = (direction == 1) ? -this->XSpeed : this->XSpeed;
	} else {
		x_speed_inc = 0.0f;
	}

	// Bouncing checks
	if (_34A & 4) {
		Vec v = (Vec){0.0f, 1.0f, 0.0f};
		collMgr.pSpeed = &v;

		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;

		collMgr.pSpeed = &speed;

	} else {
		if (collMgr.calculateAboveCollision(collMgr.outputMaybe))
			speed.y = 0.0f;
	}

	collMgr.calculateAdjacentCollision(0);

	// Switch Direction
	if (collMgr.outputMaybe & (0x15 << direction)) {
		if (collMgr.isOnTopOfTile()) {
			isBouncing = true;
		}
		return true;
	}
	return false;
}

void daNakedNokonoko_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}

int daNakedNokonoko_c::onCreate() {
	OSReport("Spawning Naked Koopa\n");

	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("nokonokoA", "g3d/naked.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("nokonokoN");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	SetupTextures_Enemy(&bodyModel, 0);

	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("Walk");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);


	allocator.unlink();

	this->pos.y += 32.0;
	this->rot.x = 0; // X is vertical axis
	this->rot.y = 0xD800; // Y is horizontal axis
	this->rot.z = 0; // Z is ... an axis >.>
	this->direction = 1; // Heading left.
	
	//this->speed.x = 0.0;
	//this->speed.y = 0.0;
	this->Baseline = this->pos.y;

	ActivePhysics::Info HitMeBaby;
	float anmSpeed;

	this->scale = (Vec){0.4f, 0.4f, 0.4f};

	HitMeBaby.xDistToCenter = 0.0;
	HitMeBaby.yDistToCenter = 16.0;

	HitMeBaby.xDistToEdge = 10.0;
	HitMeBaby.yDistToEdge = 16.0;

	this->XSpeed = 1;
	anmSpeed = 1.25;

	static const lineSensor_s below(-5<<12, 5<<12, 0<<12);
	static const lineSensor_s adjacent(10<<12, 9<<12, 10<<12);
	collMgr.init(this, &below, 0, &adjacent);

	HitMeBaby.category1 = 0x3;
	HitMeBaby.category2 = 0x0;
	HitMeBaby.bitfield1 = 0x1;
	HitMeBaby.bitfield2 = 0x820A4;
	HitMeBaby.unkShort1C = 0x0;
	HitMeBaby.callback = &dEn_c::collisionCallback;

	this->aPhysics.initWithStruct(this, &HitMeBaby);
	this->aPhysics.addToList();

	collMgr.calculateBelowCollisionWithSmokeEffect();

	cmgr_returnValue = collMgr.isOnTopOfTile();

	if (collMgr.isOnTopOfTile())
		isBouncing = false;
	else
		isBouncing = true;

	bindAnimChr_and_setUpdateRate("Walk", 1, 0.0, anmSpeed); 
	doStateChange(&StateID_Appear);

	this->onExecute();
	return true;
}

int daNakedNokonoko_c::onDelete() {
	return true;
}

int daNakedNokonoko_c::onExecute() {
	this->shell = (daEnShell_c*)fBase_c::search(this->shellId);
	acState.execute();
	updateModelMatrices();
	bodyModel._vf1C();


	return true;
}

int daNakedNokonoko_c::onDraw() {
	bodyModel.scheduleForDrawing();
	return true;
}

void daNakedNokonoko_c::updateModelMatrices() {
	float yoff;

	yoff = 0;//-5.0;
	
	matrix.translation(pos.x, pos.y + yoff, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}


///////////////
// Real Walk State
///////////////
void daNakedNokonoko_c::beginState_RealWalk() {
	//inline this piece of code
	this->max_speed.x = (this->direction) ? -this->XSpeed : this->XSpeed;
	this->speed.x = (direction) ? -this->XSpeed : this->XSpeed;

	this->max_speed.y = -4.0;
	this->speed.y = -4.0;
	this->y_speed_inc = -0.1875;
}
void daNakedNokonoko_c::executeState_RealWalk() { 
	bool ret = calculateTileCollisions();
	if (ret) {
		doStateChange(&StateID_RealTurn);
	}

	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}
}
void daNakedNokonoko_c::endState_RealWalk() { }

///////////////
// Real Turn State
///////////////
void daNakedNokonoko_c::beginState_RealTurn() {

	this->direction ^= 1;
	this->speed.x = 0.0;
}
void daNakedNokonoko_c::executeState_RealTurn() { 
	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	u16 amt = (this->direction == 0) ? 0x2800 : 0xD800;
	int done = SmoothRotation(&this->rot.y, amt, 0x800);

	if(done) {
		this->doStateChange(&StateID_RealWalk);
	}
}
void daNakedNokonoko_c::endState_RealTurn() {
}


///////////////
// Appear State
///////////////
void daNakedNokonoko_c::beginState_Appear() {
	bindAnimChr_and_setUpdateRate("Fall", 1, 0.0, 1.0);
	appearTimer = 0;
}
void daNakedNokonoko_c::executeState_Appear() {
	if(collMgr.isOnTopOfTile()) {
		if(appearTimer > 40) {
			doStateChange(&StateID_Appear2);
			return;
		}
	}
	
	/*HandleXSpeed();
	HandleYSpeed();
	doSpriteMovement();*/
	calculateTileCollisions();

	if(appearTimer <= 40) {
		float appearScale = 0.01f*appearTimer;
		scale = (Vec){appearScale, appearScale, appearScale};
		appearTimer++;
	}
	
	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}
}
void daNakedNokonoko_c::endState_Appear() {
}

///////////////
// Appear2 State
///////////////
void daNakedNokonoko_c::beginState_Appear2() {
	bindAnimChr_and_setUpdateRate("Land", 1, 0.0, 1.0);
}
void daNakedNokonoko_c::executeState_Appear2() {
	if(this->chrAnimation.isAnimationDone()) {
		doStateChange(&StateID_Appear3);
	}
}
void daNakedNokonoko_c::endState_Appear2() {
}

///////////////
// Appear3 State
///////////////
void daNakedNokonoko_c::beginState_Appear3() {
	bindAnimChr_and_setUpdateRate("Recover", 1, 0.0, 1.0);
}
void daNakedNokonoko_c::executeState_Appear3() {
	if(this->chrAnimation.isAnimationDone()) {
		doStateChange(&StateID_Appear4);
	}
}
void daNakedNokonoko_c::endState_Appear3() {
}

///////////////
// Appear4 State
///////////////
void daNakedNokonoko_c::beginState_Appear4() {
	bindAnimChr_and_setUpdateRate("FindShell", 1, 0.0, 1.0);
}
void daNakedNokonoko_c::executeState_Appear4() {
	if(this->chrAnimation.isAnimationDone()) {
		doStateChange(&StateID_Search);
	}
}
void daNakedNokonoko_c::endState_Appear4() {
	//bindAnimChr_and_setUpdateRate("Run", 1, 0.0, 1.0);
}

///////////////
// Search State
///////////////
void daNakedNokonoko_c::beginState_Search() {
	bindAnimChr_and_setUpdateRate("FindShell", 1, 0.0, 1.0);
}
void daNakedNokonoko_c::executeState_Search() {
	
	/*if (direction == 0) {
		if (
	}*/

}
void daNakedNokonoko_c::endState_Search() {
	//bindAnimChr_and_setUpdateRate("Run", 1, 0.0, 1.0);
}

///////////////
// Die State
///////////////
void daNakedNokonoko_c::beginState_Die() {
	// dEn_c::dieFall_Begin();
	this->removeMyActivePhysics();

	bindAnimChr_and_setUpdateRate("Walk", 1, 0.0, 2.0); 
	this->timer = 0;
	this->dying = -10.0;
	this->Baseline = this->pos.y;
	this->rot.y = 0;
	this->rot.x = 0;
}
void daNakedNokonoko_c::executeState_Die() { 
	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}

	this->timer += 1;
			
	// this->pos.x += 0.5; 
	this->pos.y = Baseline + (-0.2 * dying * dying) + 20.0;
	
	this->dying += 0.5;
		
	if (this->timer > 450) {
		this->kill();
		this->Delete(this->deleteForever);
	}

	// dEn_c::dieFall_Execute();

}
void daNakedNokonoko_c::endState_Die() {
}









































//
// processed\../src/fishinBoo.cpp
//

#include <common.h>
#include <game.h>
#include <g3dhax.h>

#include "boss.h"

const char* FishingBooFileList [] = { "FishingBoo", NULL };

class daFishinBoo_c : public dEn_c {
public:
	int onCreate();
	int onDelete();
	int onExecute();
	int onDraw();

	mHeapAllocator_c allocator;
	nw4r::g3d::ResFile resFile;
	m3d::mdl_c bodyModel;
	m3d::anmChr_c chrAnimation;

	float Baseline;
	float SwoopSlope;
	float SpiralLoop;
	float yThreshold;
	float yAccel;
	Vec	swoopTarget;
	u32 timer;
	float xSpiralOffset;
	float ySpiralOffset;
	float swoopA;
	float swoopB;
	float swoopC;
	float swoopSpeed;
	float glowPos;
	short spinReduceZ;
	short spinReduceY;
	float spinStateOn;
	int dying;
	char sunDying;
	char killFlag;

	u64 eventFlag;

	u32 hookNodeID;

	void dieFall_Execute();
	static dActor_c *build();

	void bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate);
	void updateModelMatrices();

	void playerCollision(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther);
	bool collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther);

	USING_STATES(daFishinBoo_c);
	DECLARE_STATE(Follow);
	DECLARE_STATE(Swoop);
	DECLARE_STATE(Spiral);
	DECLARE_STATE(Spit);
	DECLARE_STATE(Spin);
	DECLARE_STATE(Wait);
};

dActor_c *daFishinBoo_c::build() {
	void *buffer = AllocFromGameHeap1(sizeof(daFishinBoo_c));
	return new(buffer) daFishinBoo_c;
}

const SpriteData FishingBooSpriteData = { ProfileId::FishingBoo, 0, 0, 0, 0, 0x100, 0x100, 0, 0, 0, 0, 0 };
Profile FishingBooProfile(&daFishinBoo_c::build, SpriteId::FishingBoo, FishingBooSpriteData, ProfileId::FishingBoo, ProfileId::FishingBoo, "Fishin' Boo", FishingBooFileList);




CREATE_STATE(daFishinBoo_c, Follow);
CREATE_STATE(daFishinBoo_c, Swoop);
CREATE_STATE(daFishinBoo_c, Spiral);
CREATE_STATE(daFishinBoo_c, Spit);
CREATE_STATE(daFishinBoo_c, Spin);
CREATE_STATE(daFishinBoo_c, Wait);

#define ACTIVATE	1
#define DEACTIVATE	0




void daFishinBoo_c::playerCollision(ActivePhysics *apThis, ActivePhysics *apOther) {  DamagePlayer(this, apThis, apOther); }

bool daFishinBoo_c::collisionCat1_Fireball_E_Explosion(ActivePhysics *apThis, ActivePhysics *apOther) {
	return true;
}
bool daFishinBoo_c::collisionCat2_IceBall_15_YoshiIce(ActivePhysics *apThis, ActivePhysics *apOther) { 
	
	if (this->settings == 1) {  // It's a moon
		if (apOther->owner->name == 0x76) { // BROS_ICEBALL
			return true; 
			}
	}
	return false;
}
bool daFishinBoo_c::collisionCat9_RollingObject(ActivePhysics *apThis, ActivePhysics *apOther) { 
	this->timer = 0; 
	PlaySound(this, SE_EMY_DOWN);
	doStateChange(&StateID_DieFall);
	return true;
}
bool daFishinBoo_c::collisionCat13_Hammer(ActivePhysics *apThis, ActivePhysics *apOther) { 
	this->timer = 0;
	PlaySound(this, SE_EMY_DOWN);
	doStateChange(&StateID_DieFall);
	return true;
}
bool daFishinBoo_c::collisionCat3_StarPower(ActivePhysics *apThis, ActivePhysics *apOther) { 
	this->timer = 0; 
	PlaySound(this, SE_EMY_DOWN);
	doStateChange(&StateID_DieFall);
	return true;
}
bool daFishinBoo_c::collisionCatD_Drill(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}
bool daFishinBoo_c::collisionCat7_GroundPound(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}
bool daFishinBoo_c::collisionCat7_GroundPoundYoshi(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}
bool daFishinBoo_c::collisionCatA_PenguinMario(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}
bool daFishinBoo_c::collisionCat5_Mario(ActivePhysics *apThis, ActivePhysics *apOther) {
	DamagePlayer(this, apThis, apOther);
	return true;
}


void daFishinBoo_c::dieFall_Execute() {
	
	if (this->killFlag == 1) { return; }

	this->timer = this->timer + 1;
	 
	this->dying = this->dying + 0.15;
	
	this->pos.x = this->pos.x + 0.15;
	this->pos.y = this->pos.y - ((-0.2 * (this->dying*this->dying)) + 5);
	
	this->dEn_c::dieFall_Execute();
		
	if (this->timer > 450) {
		
		if ((this->settings >> 28) > 0) { 		
			this->kill();
			this->pos.y = this->pos.y + 800.0; 
			this->killFlag = 1;
			return;
		}
		
		dStageActor_c *Player = GetSpecificPlayerActor(0);
		if (Player == 0) { Player = GetSpecificPlayerActor(1); }
		if (Player == 0) { Player = GetSpecificPlayerActor(2); }
		if (Player == 0) { Player = GetSpecificPlayerActor(3); }
		
	
		if (Player == 0) { 
			this->pos.x = 0;
			doStateChange(&StateID_Follow); }
		else {
			Player->pos;
			this->pos.x = Player->pos.x - 300;
		}
				
		this->pos.y = this->Baseline; 
		
		this->aPhysics.addToList();
		doStateChange(&StateID_Follow);
	}
}


int daFishinBoo_c::onCreate() {
	allocator.link(-1, GameHeaps[0], 0, 0x20);

	this->resFile.data = getResource("FishingBoo", "g3d/FishingBoo.brres");
	nw4r::g3d::ResMdl mdl = this->resFile.GetResMdl("FishingBoo");
	bodyModel.setup(mdl, &allocator, 0x224, 1, 0);
	//SetupTextures_Map(&bodyModel, 0);
	
	nw4r::g3d::ResNode hook = mdl.GetResNode("PowerUp");
	hookNodeID = hook.GetID();
	
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr("test_short_12deg");
	this->chrAnimation.setup(mdl, anmChr, &this->allocator, 0);

	allocator.unlink();
	
	bindAnimChr_and_setUpdateRate("test_short_12deg", 1, 0.0, 1.0);

	this->scale = (Vec){10, 10, 10};

	this->Baseline = this->pos.y;
	this->SwoopSlope = 0.0;
	this->SpiralLoop = 0;
	this->yThreshold = 15.0;
	this->yAccel = 0.2;
	this->timer = 0;
	this->xSpiralOffset = 0.0;
	this->ySpiralOffset = 0.0;
	this->dying = -5;
	this->sunDying = 0;
	this->killFlag = 0;
	
	if (this->settings == 1)
		this->pos.z = 6000.0f; // moon
	else
		this->pos.z = 5750.0f; // sun


	char eventNum	= (this->settings >> 16) & 0xFF;

	this->eventFlag = (u64)1 << (eventNum - 1);


	
	doStateChange(&StateID_Follow);

	// this->onExecute();
	return true;
}

int daFishinBoo_c::onDelete() {
	return true;
}

int daFishinBoo_c::onExecute() {
	acState.execute();
	updateModelMatrices();
	bodyModel._vf1C();
	
	Vec ropePos;
	bodyModel.getNodeWorldMtxMultVecZero(hookNodeID, &ropePos);
	//CreateActor(EN_COIN, 0, ropePos, 0, 0);
	
	
	if (dFlagMgr_c::instance->flags & this->eventFlag) {
		if (this->killFlag == 0 && acState.getCurrentState()->isNotEqual(&StateID_DieFall)) {
			this->kill();
			this->pos.y = this->pos.y + 800.0; 
			this->killFlag = 1;
			doStateChange(&StateID_DieFall);
		}
	}
	
	if(this->chrAnimation.isAnimationDone()) {
		this->chrAnimation.setCurrentFrame(0.0);
	}
		
	return true;
}

int daFishinBoo_c::onDraw() {
	bodyModel.scheduleForDrawing();

	return true;
}


void daFishinBoo_c::updateModelMatrices() {
	// This won't work with wrap because I'm lazy.
	matrix.translation(pos.x, pos.y, pos.z);
	matrix.applyRotationYXZ(&rot.x, &rot.y, &rot.z);

	bodyModel.setDrawMatrix(matrix);
	bodyModel.setScale(&scale);
	bodyModel.calcWorld(false);
}

void daFishinBoo_c::bindAnimChr_and_setUpdateRate(const char* name, int unk, float unk2, float rate) {
	nw4r::g3d::ResAnmChr anmChr = this->resFile.GetResAnmChr(name);
	this->chrAnimation.bind(&this->bodyModel, anmChr, unk);
	this->bodyModel.bindAnim(&this->chrAnimation, unk2);
	this->chrAnimation.setUpdateRate(rate);
}


// Follow State

void daFishinBoo_c::beginState_Follow() { 
	this->timer = 0;
}
void daFishinBoo_c::executeState_Follow() { 

	if (this->timer > 200) { this->doStateChange(&StateID_Wait); }

	this->direction = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
	
	float speedDelta;
	if ((this->settings & 0xF) == 0) { speedDelta = 0.1; } // It's a sun
	else { speedDelta = 0.15; } // It's a moon


	if (this->direction == 0) {
		this->speed.x = this->speed.x + speedDelta;
		
		if (this->speed.x < 0) { this->speed.x = this->speed.x + (speedDelta / 2); }
		if (this->speed.x < 6.0) { this->speed.x = this->speed.x + (speedDelta); }
	}
	else {
		this->speed.x = this->speed.x - speedDelta;

		if (this->speed.x > 0) { this->speed.x = this->speed.x - (speedDelta / 2); }
		if (this->speed.x > 6.0) { this->speed.x = this->speed.x - (speedDelta); }
	}
	
	this->HandleXSpeed();
	
	
	float yDiff;
	yDiff = (this->Baseline - this->pos.y) / 8;
	this->speed.y = yDiff;
		
	this->HandleYSpeed();

	this->UpdateObjectPosBasedOnSpeedValuesReal();

	this->timer = this->timer + 1;
}
void daFishinBoo_c::endState_Follow() { 
	this->speed.y = 0;
}


// Swoop State

void daFishinBoo_c::beginState_Swoop() { 
	
	// Not enough space to swoop, spit instead.
	if (this->swoopTarget.y < (this->pos.y - 50)) { doStateChange(&StateID_Spit); }
	if (((this->pos.x - 96) < this->swoopTarget.x) && (this->swoopTarget.x < (this->pos.x + 96))) { doStateChange(&StateID_Spit); }

	if ((this->settings & 0xF) == 0) { 
		this->swoopTarget.y = this->swoopTarget.y - 16;
	} // It's a sun
	
	else { 
		this->swoopTarget.y = this->swoopTarget.y - 4;
	} // It's a moon	
	
	
	float x1, x2, x3, y1, y2, y3;

	x1 = this->pos.x - this->swoopTarget.x;
	x2 = 0;
	x3 = -x1;

	y1 = this->pos.y - this->swoopTarget.y;
	y2 = 0;
	y3 = y1;
	
	float denominator = (x1 - x2) * (x1 - x3) * (x2 - x3);
	this->swoopA      = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denominator;
	this->swoopB      = (x3*x3 * (y1 - y2) + x2*x2 * (y3 - y1) + x1*x1 * (y2 - y3)) / denominator;
	this->swoopC      = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / denominator;

	this->swoopSpeed = x3 * 2 / 75;
	
	
	PlaySound(this, 284);
	
}
void daFishinBoo_c::executeState_Swoop() { 

	// Everything is calculated up top, just need to modify it.

	this->pos.x = this->pos.x + this->swoopSpeed;

	this->pos.y = ( this->swoopA*(this->pos.x - this->swoopTarget.x)*(this->pos.x - this->swoopTarget.x) + this->swoopB*(this->pos.x - this->swoopTarget.x) + this->swoopC ) + this->swoopTarget.y;

	if (this->pos.y > this->Baseline) { doStateChange(&StateID_Follow); }

}
void daFishinBoo_c::endState_Swoop() { 
	this->speed.y = 0;
}



// Spiral State

void daFishinBoo_c::beginState_Spiral() { 

	this->SpiralLoop = 0;
	this->xSpiralOffset = this->pos.x;
	this->ySpiralOffset = this->pos.y;

	PlaySound(this, 284);
}
void daFishinBoo_c::executeState_Spiral() { 

	float Loops;
	float Magnitude;
	float Period;

	Loops = 6.0;
	Magnitude = 11.0;

	// Use a period of 0.1 for the moon
	if ((this->settings & 0xF) == 0) { Period = 0.1; } // It's a sun
	else { Period = 0.125; } // It's a moon	

	this->pos.x = this->xSpiralOffset + Magnitude*((this->SpiralLoop * cos(this->SpiralLoop)));
	this->pos.y = this->ySpiralOffset + Magnitude*((this->SpiralLoop * sin(this->SpiralLoop)));

	this->SpiralLoop = this->SpiralLoop + Period;

	if (this->SpiralLoop > (3.14 * Loops)) { doStateChange(&StateID_Follow); }

}
void daFishinBoo_c::endState_Spiral() { }



// Spit State

void daFishinBoo_c::beginState_Spit() { 

	this->timer = 0;
	this->spinStateOn = 1;

}
void daFishinBoo_c::executeState_Spit() { 
	
	if (this->timer == 10) {

		PlaySound(this, 431);
	
		this->direction = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
		
		float neg = -1.0;
		if (this->direction == 0) { neg = 1.0; }
		

		if ((this->settings & 0xF) == 0) { 
			dStageActor_c *spawner = CreateActor(106, 0, this->pos, 0, 0);
			spawner->speed.x = 6.0 * neg;
			spawner->speed.y = -2.5;
			spawner->pos.z = 5550.0;
			
			spawner = CreateActor(106, 0, this->pos, 0, 0);
			spawner->speed.x = 0.0 * neg;
			spawner->speed.y = -6.0;
			spawner->pos.z = 5550.0;
		
			spawner = CreateActor(106, 0, this->pos, 0, 0);
			spawner->speed.x = 3.5 * neg;
			spawner->speed.y = -6.0;
			spawner->pos.z = 5550.0;
		} // It's a sun
		
		
		else { 
			dStageActor_c *spawner = CreateActor(118, 0, this->pos, 0, 0);
			spawner->speed.x = 6.0 * neg;
			spawner->speed.y = -2.5;
			spawner->pos.z = 5550.0;
			*((u32 *) (((char *) spawner) + 0x3DC)) = this->id;
			
			spawner = CreateActor(118, 0, this->pos, 0, 0);
			spawner->speed.x = 0.0 * neg;
			spawner->speed.y = -6.0;
			spawner->pos.z = 5550.0;
			*((u32 *) (((char *) spawner) + 0x3DC)) = this->id;
		
			spawner = CreateActor(118, 0, this->pos, 0, 0);
			spawner->speed.x = 3.5 * neg;
			spawner->speed.y = -6.0;
			spawner->pos.z = 5550.0;
			*((u32 *) (((char *) spawner) + 0x3DC)) = this->id;
		} // It's a moon	

	}
	
	this->timer = this->timer + 1;

	if (this->timer > 30) { doStateChange(&StateID_Follow); }

}
void daFishinBoo_c::endState_Spit() { 
	this->spinStateOn = 0;
}



// Spin State

void daFishinBoo_c::beginState_Spin() { 
	this->spinReduceZ = 0;
	this->spinReduceY = 0;
}
void daFishinBoo_c::executeState_Spin() { 
	
	PlaySound(this, 282);

	this->direction = dSprite_c__getXDirectionOfFurthestPlayerRelativeToVEC3(this, this->pos);
	
	if (this->direction == 0) {
		this->speed.x = this->speed.x + 0.2;

		if (this->speed.x < 0) { this->speed.x = this->speed.x + (0.2 / 2); }
		if (this->speed.x < 80.0) { this->speed.x = this->speed.x + (0.2 * 2); }
	}
	else {
		this->speed.x = this->speed.x - 0.2;

		if (this->speed.x > 0) { this->speed.x = this->speed.x - (0.2 / 2); }
		if (this->speed.x > 80.0) { this->speed.x = this->speed.x - (0.2 * 2); }
	}
	
	this->HandleXSpeed();
	this->UpdateObjectPosBasedOnSpeedValuesReal();

	this->timer = this->timer + 1;


	float spitspeed;
	if ((this->settings & 0xF) == 0) { spitspeed = 3.0; } // It's a sun
	else { spitspeed = 4.0;  } // It's a moon	

	int randomBall;
	randomBall = GenerateRandomNumber(8);
	if (randomBall == 1) {
		int direction;
		direction = GenerateRandomNumber(8);
		
		float xlaunch;
		float ylaunch;
		
		if (direction == 0) { 
			xlaunch = spitspeed;
			ylaunch = 0.0; }
		else if (direction == 1) { // SE
			xlaunch = spitspeed;
			ylaunch = spitspeed; }
		else if (direction == 2) { // S
			xlaunch = 0.0;
			ylaunch = spitspeed; }
		else if (direction == 3) { // SW
			xlaunch = -spitspeed;
			ylaunch = spitspeed; }
		else if (direction == 4) {	// W
			xlaunch = -spitspeed;
			ylaunch = 0.0; }
		else if (direction == 5) {	// NW
			xlaunch = -spitspeed;
			ylaunch = -spitspeed; }
		else if (direction == 6) {	// N
			xlaunch = 0.0;
			ylaunch = -spitspeed; }
		else if (direction == 7) {	// NE
			xlaunch = spitspeed;
			ylaunch = -spitspeed; }
		
		PlaySound(this, 431);

		if ((this->settings & 0xF) == 0) { 
			dStageActor_c *spawner = CreateActor(106, 0, this->pos, 0, 0);
			spawner->speed.x = xlaunch;
			spawner->speed.y = ylaunch;
			spawner->pos.z = 5550.0;
		} // It's a sun

		else { 
			dStageActor_c *spawner = CreateActor(118, 0, this->pos, 0, 0);
			spawner->speed.x = xlaunch;
			spawner->speed.y = ylaunch;
			spawner->pos.z = 5550.0;
			
			*((u32 *) (((char *) spawner) + 0x3DC)) = this->id;			
		} // It's a moon	
	}

	if (this->timer > 120) { this->doStateChange(&StateID_Follow); }
	
}
void daFishinBoo_c::endState_Spin() { 
	this->speed.x = 0;
}



// Wait State

void daFishinBoo_c::beginState_Wait() {


	this->timer = 0;
	this->speed.x = 0.0;

	dStageActor_c *Player = GetSpecificPlayerActor(0);
	if (Player == 0) { Player = GetSpecificPlayerActor(1); }
	if (Player == 0) { Player = GetSpecificPlayerActor(2); }
	if (Player == 0) { Player = GetSpecificPlayerActor(3); }
	if (Player == 0) { doStateChange(&StateID_Follow); }
	
	this->swoopTarget = Player->pos;
}
void daFishinBoo_c::executeState_Wait() { 
	int Choice;
	int TimerMax;
	
	if ((this->settings & 0xF) == 0) { TimerMax = 60; } // It's a sun
	else { TimerMax = 30; } // It's a moon	
	
	if (this->timer > TimerMax) {

		Choice = GenerateRandomNumber(9);


		/*if (Choice == 0) { doStateChange(&StateID_Spit); }
		else if (Choice == 1) { doStateChange(&StateID_Spit); }
		else if (Choice == 2) { doStateChange(&StateID_Spin); }
		else if (Choice == 3) { doStateChange(&StateID_Spiral); }
		else { doStateChange(&StateID_Swoop); }*/
		
	}

	this->timer = this->timer + 1;
}
void daFishinBoo_c::endState_Wait() {
	this->timer = 0;
}



